<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 疯子爱淡定</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 疯子爱淡定">
<meta name="author" content="疯子爱淡定">
<link rel="canonical" href="http://heketong.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://heketong.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://heketong.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://heketong.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://heketong.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://heketong.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://heketong.github.io/posts/index.xml">
<link rel="alternate" hreflang="en" href="http://heketong.github.io/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Posts" />
<meta property="og:description" content="疯子爱淡定 http://heketong.github.io/" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://heketong.github.io/posts/" />
<meta property="og:image" content="http://heketong.github.io/images/papermod-cover.png" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://heketong.github.io/images/papermod-cover.png" />
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="疯子爱淡定 http://heketong.github.io/"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://heketong.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://heketong.github.io/" accesskey="h" title="疯子爱淡定 (Alt + H)">疯子爱淡定</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://heketong.github.io/archives" title="📚 归档">
                    <span>📚 归档</span>
                </a>
            </li>
            <li>
                <a href="http://heketong.github.io/search/" title="🔍 查找">
                    <span>🔍 查找</span>
                </a>
            </li>
            <li>
                <a href="http://heketong.github.io/about/" title="🙋🏻‍♂️ 关于">
                    <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="http://heketong.github.io/categories/" title="🧩 分类">
                    <span>🧩 分类</span>
                </a>
            </li>
            <li>
                <a href="http://heketong.github.io/tags/" title="🧩 标签">
                    <span>🧩 标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://heketong.github.io/">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">致我的迷茫兄弟
    </h2>
  </header>
  <div class="entry-content">
    <p>乐队介绍 这是一支由彝族流浪诗人、山东三开流神医、东北夜行骑士、西南原始摩登人、淄博长发小贝所建立的摇滚乐队，成立于2001年初。他们来自不同的地方，有着不同的经历，他们的音乐中从平静到狂躁、从孤独到幸福，从自恋自伤到纵情高歌，听者往往会将自身最隐秘的情感释放出来，进入一种宣泄状态 前奏真好听，声音碎片的鼓真心不错，虽然无法解决你的迷茫，听起来有些释怀的感觉 听 致我的迷茫兄弟_qq音乐
致我的迷茫兄弟_声音碎片
致我的迷茫兄弟_歌词 你好 让我们一起忘掉今天 让我们一起抵抗虚无 请你把鼓声敲得响亮 飞扬的不该止于这里 让我们再次回到街上 像从前那样头脑清楚 哦是的 岁月让生命变得脆弱 机器让人性变得可疑 娱乐让思考变得可笑 当你在洪流之中挣扎 什么是你的救命稻草 你不能带着迷惑离开 你好 沙漠里不长虚弱的草 大海里没有无名之辈 你母亲让你独一无二 你不是谁的一颗棋子 你不要轻易变成工具 你发誓完整你的生命 哦不管 风会向哪个方向吹拂 握紧你手中琴和酒杯 听它在午夜叮当作响 这不是孤雁离群悲鸣 这声音来自西南之南 他孤独 可是无限清醒 </p>
  </div>
  <footer class="entry-footer"><span title='2024-06-13 19:02:58 +0800 +0800'>June 13, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;疯子爱淡定</footer>
  <a class="entry-link" aria-label="post link to 致我的迷茫兄弟" href="http://heketong.github.io/posts/%E8%87%B4%E6%88%91%E7%9A%84%E8%BF%B7%E8%8C%AB%E5%85%84%E5%BC%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">完美落地
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 原唱 乱弹阿翔，电影《翻滚吧!阿信》主题曲 目前能听到的大多是徐佳莹的这个版本 2个版本各有味道 最近很喜欢,作为手机铃声也不错 听 完美落地_徐佳莹qq音乐
完美落地
完美落地歌词 完美落地 - 徐佳莹 (LALA Xu) 词：乱弹阿翔 曲：乱弹阿翔 从现在我不会再逃避 重新的唤起 埋葬在我心底的血液 沉住气 我的心不再移 屏息不放弃 慢慢的朝着我的梦前进 忘了吧 混乱的事不再提 放了吧 把心思变唯一 我会用尽所有力 奋力的跃起在天际 迎着光明 我会更用力呼吸 飞到另一个灿烂天空 完美 落地 我相信有努力会开启 久违的光明 老天爷总是会看得清 重新又回到最初自己 每一次练习 我只想朝着我的梦前进 忘了吧 混乱的事不再提 放了吧 把心思变唯一 我会用尽所有力 奋力的跃起在天际 迎着光明 我会更用力呼吸 飞到另一个灿烂天空 完美 落地 </p>
  </div>
  <footer class="entry-footer"><span title='2024-06-13 10:02:58 +0800 +0800'>June 13, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;疯子爱淡定</footer>
  <a class="entry-link" aria-label="post link to 完美落地" href="http://heketong.github.io/posts/%E5%AE%8C%E7%BE%8E%E8%90%BD%E5%9C%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">100场马拉松
    </h2>
  </header>
  <div class="entry-content">
    <p>100-Marathons 1 广州花都半马赛事 2019.2.24 ​	【广州花都摇滚马组委会】祝贺贺 克通 完成2019广州花都摇滚马拉松半程马拉松项目，参赛号：C11949，枪声成绩：02:17:13，净成绩：02:13:56。此成绩仅供参考，最终成绩以组委会发布成绩证书上为准
2 清远半马赛事 2019 3.17 ​	【中体体育】祝贺贺克通完成2019时代中国清远马拉松赛 ，项目：半程马拉松，参赛号：C0085 ，枪声成绩：02:13:22 ，净成绩：02:05:10。此成绩仅供参考，解释权归组委会。
3 韶关全马赛事 2019.11.24 ​	第一次全马，竟然没收到短信，😓
4 阳江海陵岛全马赛事 2019.12.29 ​	【露营之家】恭喜您完成了十八子作·2019阳江海陵岛环岛国际马拉松赛“全程马拉松”，参赛号A0791，枪声成绩05:03:26，净成绩05:03:07。最终解释权归组委会所有。
疫情影响取消清远全马赛事 2020.3.22 ​	【清远马拉松】尊敬的贺克通，恭喜您中签2020时代中国清远马拉松，中签结果同步更新在微信公众号第一赛道，请及时关注。感谢您对清马的关注和支持，谢谢！2020.1.13 15:30，2020年太多事情发生，疫情影响，清远赛事取消，昨天看到消息，说癌症患者贺明发现自己病情后，想跑满100场马拉松，看后非常感动，是啊，每个不曾起舞的日子，都是对生命的辜负，癌症患者尚坚持跑了61场马拉松，自己又有什么不能的呢，当然这件事情也让我觉得更要珍惜自己的生命，不要等到事情真到了无可挽回的时候再决定找寻自己的健康，而应该在现在，此时此刻开始，运动起来，享受自己的人生。
​	戒烟这个事情反反复复说了太多遍，到现在还是没能如愿以偿，那就从此时此刻开始继续加油吧</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-12 22:45:46 +0800 +0800'>June 12, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;疯子爱淡定</footer>
  <a class="entry-link" aria-label="post link to 100场马拉松" href="http://heketong.github.io/posts/marathons/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">hugo搭建博客
    </h2>
  </header>
  <div class="entry-content">
    <p>搭建hugo静态博客记录 1 安装Hugo 我这里是imac所以就直接用brew 其它操作系统也很简单 google
brew install hugo 2 初始化站点目录 先cd到你想放置的磁盘目录 然后执行一下命令即可 会在当前目录创建站点名称同名目录
$ hugo new site blog $ cd blog 3 安装主题并修改 现在hugo主题商店挺多，这里选择了相对干净的PaperMod 如果没有git环境 可自行百度安装
$ git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 config.yml 配置文件主要修改项
baseURL 主页 menu 可以将下面的title改为对应的中文 donate 改为自己的微信和支付宝 profile 修改自己头像和介绍 4 写markdown文章 $ hugo new posts/create_hugo_blog /Users/ketonghe/blog/content/posts/create_hugo_blog 用markdown编辑器编辑文章
5 发布预览 $ hugo server -D | ZH &#43;------------------&#43;----&#43; Pages | 13 Paginator pages | 0 Non-page files | 0 Static files | 9 Processed images | 0 Aliases | 6 Sitemaps | 1 Cleaned | 0 Total in 91 ms Watching for changes in /Users/ketonghe/blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Users/ketonghe/blog/config....</p>
  </div>
  <footer class="entry-footer"><span title='2020-05-13 22:45:46 +0800 +0800'>May 13, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;疯子爱淡定</footer>
  <a class="entry-link" aria-label="post link to hugo搭建博客" href="http://heketong.github.io/posts/create_hugo_blog/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">TCP/IP
    </h2>
  </header>
  <div class="entry-content">
    <p>相关历史及分成模型 历史介绍 1969年 美国担心敌人会摧毁自己的网络，所以国防部高级研究计划局（Advanced Research Projects Agency，ARPA）下决心要建立一个高可用的网络，即使部分线路或者交换机的故障不会导致整个网络的瘫痪，于是有了后来的ARPANET（Advanced Research Project Agency Network）—最早只是一个简单的分组交换网 经过不断发展，原始的ARPANET慢慢变成了多个网络互联，逐步促成了互联网的出现。 1983年TCP/IP 协议成为 ARPANET 上的标准协议，现在互联网世界这么繁荣都得意与TCP/IP协议，当然任何一个行业越是繁荣昌盛，就越是有良好的协议标准，接口标准，TCP/IP就是网际互联中最流行的协议标准，也正是因为其流行，互联网才能越发发达。 分层模型 一般都会提到7层 4层 或者 5层，下面给出一张图做个简单对比 ​	左边是ISO/OSI的7层模型，分的更细，一般我们常说的右边的4层，咱们从上到下分层说
应用层 Application Layer 应用层的本质是规定了应用程序之间如何相互传递报文，处理特定的应用程序细节
我们常说的FTP、HTTP、SMTP、NFS、SNMP、Telnet都是应用层的协议，就拿HTTP来说：
规定了报文的类型 是请求报文还是应答报文 每段报文具体什么语法 有多少段，怎么才算结束(\r\n) 进程应该以什么样的顺序发送或者接收报文 ………. 大部分应用层协议都有RFC文档定义(Request for Comments，缩写：RFC,由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及UNIX和互联网社群的软件文件，以编号排定。目前RFC文件是由互联网协会（ISOC）赞助发行)
传输层 Transport Layer 主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。
TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。
由于传输层TCP提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。
UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。
端口 这里必须提下端口的概念，主要为了区分一台主机上不同的应用程序，比如80端口一般就是http应用的端口，21一般是ftp应用的端口，知道了端口就知道数据包到时候要送给哪个应用程序 网络层/网际层/网络互联层 Internet Layer 网络互连层提供了主机到主机的通信，将传输层产生的的数据包封装成分组数据包发送到目标主机，并提供路由选择的能力。
处理分组在网络中的活动，例如分组的选路。
在TCP/IP协议族中，网络层协议包括IP协议（网际协议），
ICMP协议（Internet互联网控制报文协议），
IGMP协议（Internet组管理协议）。
IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。
ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。
IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。
链路层/网络接口层/网络访问层 Network Access Layer 也就是上图右边的网络接口层和硬件层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。
以太网、Wifi、蓝牙工作在这一层，网络访问层提供了主机连接到物理网络需要的硬件和相关的协议
为什么要分层 分层的本质是通过分离关注点而让复杂问题简单化，通过分层可以做到：
各层独立：限制了依赖关系的范围，各层之间使用标准化的接口，各层不需要知道上下层是如何工作的，增加或者修改一个应用层协议不会影响传输层协议 灵活性更好：比如路由器不需要应用层和传输层，分层以后路由器就可以只用加载更少的几个协议层 易于测试和维护：提高了可测试性，可以独立的测试特定层，某一层有了更好的实现可以整体替换掉 能促进标准化：每一层职责清楚，方便进行标准化 抓个包瞄一瞄 这里抓一个http报文看看 直接后台 curl http://www....</p>
  </div>
  <footer class="entry-footer"><span title='2020-05-13 22:45:46 +0800 +0800'>May 13, 2020</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;疯子爱淡定</footer>
  <a class="entry-link" aria-label="post link to TCP/IP" href="http://heketong.github.io/posts/tcp_ip/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">分布式
    </h2>
  </header>
  <div class="entry-content">
    <p>一些概念回顾 缓存穿透 概念： 缓存没有数据，而且数据库也没有数据。
​	当这种情况大量出现或被恶意攻击时，接口的访问全部透过Redis访问数据库，而数据库中也没有这些数据，我们称这种现象为&#34;缓存穿透&#34;。缓存穿透会穿透Redis的保护，提升底层数据库的负载压力，同时这类穿透查询没有数据返回也造成了网络和计算资源的浪费。
一般解决方案 如果Redis内不存在该数据，则通过布隆过滤器判断数据是否在底层数据库内； 如果布隆过滤器告诉我们该key在底层库内不存在，则直接返回null给客户端即可，避免了查询底层数据库的动作； 如果布隆过滤器告诉我们该key极有可能在底层数据库内存在，那么将查询下推到底层数据库即可 布隆过滤器有误判率，虽然不能完全避免数据穿透的现象，但已经可以将绝大部份的的穿透查询给屏蔽在Redis层了，极大的降低了底层数据库的压力，减少了资源浪费。 缓冲击穿 概念 一般是指缓存没有但是数据库有的数据。 比如热点数据失效，导致大量合法热点请求打向数据库，此时数据库压力山大 一般解决方案： 延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口； 利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至Redis内，避免其他大量请求同时穿过Redis访问底层数据库。 缓存雪崩 概念 缓存雪崩时缓存击穿的加强版，大量的key几乎同时过期，然后大量并发查询穿过redis击打到底层数据库上，此时数据库层的负载压力会骤增，我们称这种现象为&#34;缓存雪崩&#34;。
一般解决方案 缓存预热 ​	缓存预热如字面意思，当系统上线时，缓存内还没有数据，如果直接提供给用户使用，每个请求都会穿过缓存去访问底层数据库，
如果并发大的话，很有可能在上线当天就会宕机，因此我们需要在上线前先将数据库内的热点数据缓存至Redis内再提供出去使用，
这种操作就成为&#34;缓存预热&#34;。缓存预热的实现方式有很多，比较通用的方式是写个批任务，在启动项目时或定时去触发将底层数据库内的热点数据加载到缓存内。
缓存更新 ​	缓存服务（Redis）和数据服务（底层数据库）是相互独立且异构的系统，在更新缓存或更新数据的时候无法做到原子性的同时更新两边的数据，因此在并发读写或第二步操作异常时会遇到各种数据不一致的问题。如何解决并发场景下更新操作的双写一致是缓存系统的一个重要知识点。
第二步操作异常：缓存和数据的操作顺序中，第二个动作报错。如数据库被更新， 此时失效缓存的时候出错，缓存内数据仍是旧版本； 缓存更新的设计模式有四种：
Cache aside：查询：先查缓存，缓存没有就查数据库，然后加载至缓存内；更新：先更新数据库，然后让缓存失效；或者先失效缓存然后更新数据库；
Read through：在查询操作中更新缓存，即当缓存失效时，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载；
Write through：在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由缓存自己更新数据库；
Write behind caching：俗称write back，在更新数据的时候，只更新缓存，不更新数据库，缓存会异步地定时批量更新数据库；
Cache aside：
为了避免在并发场景下，多个请求同时更新同一个缓存导致脏数据，因此不能直接更新缓存而是另缓存失效。
先更新数据库后失效缓存：并发场景下，推荐使用延迟失效（写请求完成后给缓存设置1s过期时间），在读请求缓存数据时若redis内已有该数据（其他写请求还未结束）则不更新。当redis内没有该数据的时候（其他写请求已另该缓存失效），读请求才会更新redis内的数据。这里的读请求缓存数据可以加上失效时间，以防第二步操作异常导致的不一致情况。
先失效缓存后更新数据库：并发场景下，推荐使用延迟失效（写请求开始前给缓存设置1s过期时间），在写请求失效缓存时设置一个1s延迟时间，然后再去更新数据库的数据，此时其他读请求仍然可以读到缓存内的数据，当数据库端更新完成后，缓存内的数据已失效，之后的读请求会将数据库端最新的数据加载至缓存内保证缓存和数据库端数据一致性；在这种方案下，第二步操作异常不会引起数据不一致，例如设置了缓存1s后失效，然后在更新数据库时报错，即使缓存失效，之后的读请求仍然会把更新前的数据重新加载到缓存内。
推荐使用先失效缓存，后更新数据库，配合延迟失效来更新缓存的模式； 四种缓存更新模式的优缺点：
Cache Aside：实现起来较简单，但需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）； Read/Write Through：只需要维护一个数据存储（缓存），但是实现起来要复杂一些； Write Behind Caching：与Read/Write Through 类似，区别是Write Behind Caching的数据持久化操作是异步的，但是Read/Write Through 更新模式的数据持久化操作是同步的。优点是直接操作内存速度快，多次操作可以合并持久化到数据库。缺点是数据可能会丢失，例如系统断电等。 缓存本身就是通过牺牲强一致性来提高性能，因此使用缓存提升性能，就会有数据更新的延迟性。这就需要我们在评估需求和设计阶段根据实际场景去做权衡了。 缓存降级 ​	缓存降级是指当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，即使是有损部分其他服务，仍然需要保证主服务可用。可以将其他次要服务的数据进行缓存降级，从而提升主服务的稳定性。...</p>
  </div>
  <footer class="entry-footer"><span title='2020-05-13 22:45:46 +0800 +0800'>May 13, 2020</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;疯子爱淡定</footer>
  <a class="entry-link" aria-label="post link to 分布式" href="http://heketong.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">常用数据结构
    </h2>
  </header>
  <div class="entry-content">
    <p>时间复杂度 常数时间操作O(1) 操作时间是固定的次数，跟数据量本身没有关系，就是其时间复杂度是O(1),比如总是比较1次或者3次，比如总是累加3次，总是赋值3次等等，无论样本数据量是多少，总是如此，我们就说起操作时间是常数时间，也就是O(1) 实际评估过程中一般是循环多多少次，比较了多少次等等计算出一个表达式，然后对于表达式只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分 如果记为f(N)，那么时间复杂度为O(f(N)). N为样本量 一个简单的例子： 比如计算出的表达式为f(N)=2$N^2$&#43;3N&#43;3 这里面的高阶项就是$N^2$，对应高阶项的系数就是2 低阶项就是3N和3 最后f(N)=$N^2$ 算法流程的好坏，先看时间复杂度的指标，然后再分 析不同数据样本下的实际运行时间，也就是常数项时间 例子 一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数 组长度为N，B数组长度为M。 算法流程1:对于数组B中的每一个数，都在A中通过遍历的方式找一下; 算法流程2:对于数组B中的每一个数，都在A中通过二分的方式找一下; 算法流程3:先把数组B排序，然后用类似外排的方式打印所有在A中出现 的数; 代码实现及算法时间复杂度分析 三种算法代码实现 二分有递归和非递归 排序用的是归并递归实现 ```c&#43;&#43; // 一个**有序**数组A，另一个**无序**数组B，请打印B中的所有不在A中的数，A数 组长度为N，B数组长度为M。 // 算法流程1:对于数组B中的每一个数，都在A中通过遍历的方式找一下; // 算法流程2:对于数组B中的每一个数，都在A中通过二分的方式找一下; // 算法流程3:先把数组B排序，然后用类似外排的方式打印所有在A中出现 的数; #include using namespace std; //打印数组 void printArray(int a[],int la){ cout&lt;&lt;&#34;[&#34;; for(int i=0;i</p>
  </div>
  <footer class="entry-footer"><span title='2020-05-13 22:45:46 +0800 +0800'>May 13, 2020</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;疯子爱淡定</footer>
  <a class="entry-link" aria-label="post link to 常用数据结构" href="http://heketong.github.io/posts/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">排序_数据结构与算法
    </h2>
  </header>
  <div class="entry-content">
    <p>冒泡排序 介绍 ​ 冒泡排序是一种比较简单的排序，之所以叫冒泡，是因为在两两比较的过程中较大的数就像冒泡一样被换到后面。详细解释：依次比较相邻的两个数，前面的数大于后面的数，则交换，将较大的数挪动到后面 第1轮: 比较1 – N 经过依次相邻两两比较交换 最大的数则放到了最后 第2轮: 比较1 –N-1 经过依次相邻两两比较交换 第2大的数则放到了N-1的位置 第N-1轮:比较1 –	2	前2个数两两比较交换 整个过程完成 代码 BubbleSort ```go func BubbleSort(a []int) { if len(a) &lt; 2 { //一个数或者为空 不用排序 return } //外层循环控控制每轮循环两两比较的最大下标 第1次为N-1 最后一次为1(也就是最前面的2个元素) for endPos := len(a) - 1; endPos &gt; 0; endPos-- { //内层循环完成两两比较交换 for i := 0; i &lt; endPos; i&#43;&#43; { if a[i] &gt; a[i&#43;1] { a[i], a[i&#43;1] = a[i&#43;1], a[i] } } } } ``` 时间复杂度 ​ O($N^2$)...</p>
  </div>
  <footer class="entry-footer"><span title='2020-05-13 22:45:46 +0800 +0800'>May 13, 2020</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;疯子爱淡定</footer>
  <a class="entry-link" aria-label="post link to 排序_数据结构与算法" href="http://heketong.github.io/posts/%E6%8E%92%E5%BA%8F_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://heketong.github.io/posts/page/2/">Next&nbsp;2/2&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://heketong.github.io/">疯子爱淡定</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
