{"categories":[{"title":"marathons","uri":"http://heketong.github.io/categories/marathons/"},{"title":"sport","uri":"http://heketong.github.io/categories/sport/"},{"title":"æŠ€æœ¯æ€»ç»“","uri":"http://heketong.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"posts":[{"content":" 100-Marathons 1 å¹¿å·èŠ±éƒ½åŠé©¬èµ›äº‹ 2019.2.24 â€‹ ã€å¹¿å·èŠ±éƒ½æ‘‡æ»šé©¬ç»„å§”ä¼šã€‘ç¥è´ºè´º å…‹é€š å®Œæˆ2019å¹¿å·èŠ±éƒ½æ‘‡æ»šé©¬æ‹‰æ¾åŠç¨‹é©¬æ‹‰æ¾é¡¹ç›®ï¼Œå‚èµ›å·ï¼šC11949ï¼Œæªå£°æˆç»©ï¼š02:17:13ï¼Œå‡€æˆç»©ï¼š02:13:56ã€‚æ­¤æˆç»©ä»…ä¾›å‚è€ƒï¼Œæœ€ç»ˆæˆç»©ä»¥ç»„å§”ä¼šå‘å¸ƒæˆç»©è¯ä¹¦ä¸Šä¸ºå‡†\n2 æ¸…è¿œåŠé©¬èµ›äº‹ 2019 3.17 â€‹ ã€ä¸­ä½“ä½“è‚²ã€‘ç¥è´ºè´ºå…‹é€šå®Œæˆ2019æ—¶ä»£ä¸­å›½æ¸…è¿œé©¬æ‹‰æ¾èµ› ï¼Œé¡¹ç›®ï¼šåŠç¨‹é©¬æ‹‰æ¾ï¼Œå‚èµ›å·ï¼šC0085 ï¼Œæªå£°æˆç»©ï¼š02:13:22 ï¼Œå‡€æˆç»©ï¼š02:05:10ã€‚æ­¤æˆç»©ä»…ä¾›å‚è€ƒï¼Œè§£é‡Šæƒå½’ç»„å§”ä¼šã€‚\n3 éŸ¶å…³å…¨é©¬èµ›äº‹ 2019.11.24 â€‹ ç¬¬ä¸€æ¬¡å…¨é©¬ï¼Œç«Ÿç„¶æ²¡æ”¶åˆ°çŸ­ä¿¡ï¼ŒğŸ˜“\n4 é˜³æ±Ÿæµ·é™µå²›å…¨é©¬èµ›äº‹ 2019.12.29 â€‹ ã€éœ²è¥ä¹‹å®¶ã€‘æ­å–œæ‚¨å®Œæˆäº†åå…«å­ä½œÂ·2019é˜³æ±Ÿæµ·é™µå²›ç¯å²›å›½é™…é©¬æ‹‰æ¾èµ›â€œå…¨ç¨‹é©¬æ‹‰æ¾â€ï¼Œå‚èµ›å·A0791ï¼Œæªå£°æˆç»©05:03:26ï¼Œå‡€æˆç»©05:03:07ã€‚æœ€ç»ˆè§£é‡Šæƒå½’ç»„å§”ä¼šæ‰€æœ‰ã€‚\nç–«æƒ…å½±å“å–æ¶ˆæ¸…è¿œå…¨é©¬èµ›äº‹ 2020.3.22 â€‹ ã€æ¸…è¿œé©¬æ‹‰æ¾ã€‘å°Šæ•¬çš„è´ºå…‹é€šï¼Œæ­å–œæ‚¨ä¸­ç­¾2020æ—¶ä»£ä¸­å›½æ¸…è¿œé©¬æ‹‰æ¾ï¼Œä¸­ç­¾ç»“æœåŒæ­¥æ›´æ–°åœ¨å¾®ä¿¡å…¬ä¼—å·ç¬¬ä¸€èµ›é“ï¼Œè¯·åŠæ—¶å…³æ³¨ã€‚æ„Ÿè°¢æ‚¨å¯¹æ¸…é©¬çš„å…³æ³¨å’Œæ”¯æŒï¼Œè°¢è°¢ï¼2020.1.13 15:30ï¼Œ2020å¹´å¤ªå¤šäº‹æƒ…å‘ç”Ÿï¼Œç–«æƒ…å½±å“ï¼Œæ¸…è¿œèµ›äº‹å–æ¶ˆï¼Œæ˜¨å¤©çœ‹åˆ°æ¶ˆæ¯ï¼Œè¯´ç™Œç—‡æ‚£è€…è´ºæ˜å‘ç°è‡ªå·±ç—…æƒ…åï¼Œæƒ³è·‘æ»¡100åœºé©¬æ‹‰æ¾ï¼Œçœ‹åéå¸¸æ„ŸåŠ¨ï¼Œæ˜¯å•Šï¼Œæ¯ä¸ªä¸æ›¾èµ·èˆçš„æ—¥å­ï¼Œéƒ½æ˜¯å¯¹ç”Ÿå‘½çš„è¾œè´Ÿï¼Œç™Œç—‡æ‚£è€…å°šåšæŒè·‘äº†61åœºé©¬æ‹‰æ¾ï¼Œè‡ªå·±åˆæœ‰ä»€ä¹ˆä¸èƒ½çš„å‘¢ï¼Œå½“ç„¶è¿™ä»¶äº‹æƒ…ä¹Ÿè®©æˆ‘è§‰å¾—æ›´è¦çæƒœè‡ªå·±çš„ç”Ÿå‘½ï¼Œä¸è¦ç­‰åˆ°äº‹æƒ…çœŸåˆ°äº†æ— å¯æŒ½å›çš„æ—¶å€™å†å†³å®šæ‰¾å¯»è‡ªå·±çš„å¥åº·ï¼Œè€Œåº”è¯¥åœ¨ç°åœ¨ï¼Œæ­¤æ—¶æ­¤åˆ»å¼€å§‹ï¼Œè¿åŠ¨èµ·æ¥ï¼Œäº«å—è‡ªå·±çš„äººç”Ÿã€‚\nâ€‹ æˆ’çƒŸè¿™ä¸ªäº‹æƒ…ååå¤å¤è¯´äº†å¤ªå¤šéï¼Œåˆ°ç°åœ¨è¿˜æ˜¯æ²¡èƒ½å¦‚æ„¿ä»¥å¿ï¼Œé‚£å°±ä»æ­¤æ—¶æ­¤åˆ»å¼€å§‹ç»§ç»­åŠ æ²¹å§\n","id":0,"section":"posts","summary":"100-Marathons 1 å¹¿å·èŠ±éƒ½åŠé©¬èµ›äº‹ 2019.2.24 â€‹ ã€å¹¿å·èŠ±éƒ½æ‘‡æ»šé©¬ç»„å§”ä¼šã€‘ç¥è´ºè´º å…‹é€š å®Œæˆ2019å¹¿å·èŠ±éƒ½æ‘‡æ»šé©¬æ‹‰æ¾åŠç¨‹é©¬æ‹‰æ¾é¡¹ç›®ï¼Œå‚èµ›å·ï¼šC11949ï¼Œæªå£°æˆç»©ï¼š02","tags":["marathons"],"title":"100åœºé©¬æ‹‰æ¾","uri":"http://heketong.github.io/2020/06/marathons/","year":"2020"},{"content":" æ­å»ºhugoé™æ€åšå®¢è®°å½• 1 å®‰è£…Hugo æˆ‘è¿™é‡Œæ˜¯imacæ‰€ä»¥å°±ç›´æ¥ç”¨brew å…¶å®ƒæ“ä½œç³»ç»Ÿä¹Ÿå¾ˆç®€å• ç™¾åº¦ä¸€ä¸‹ä¸€æŠŠ\nbrew install hugo  2 åˆå§‹åŒ–ç«™ç‚¹ç›®å½• å…ˆcdåˆ°ä½ æƒ³æ”¾ç½®çš„ç£ç›˜ç›®å½• ç„¶åæ‰§è¡Œä¸€ä¸‹å‘½ä»¤å³å¯ ä¼šåœ¨å½“å‰ç›®å½•åˆ›å»ºç«™ç‚¹åç§°åŒåç›®å½•\n$ hugo new site blog Congratulations! Your new Hugo site is created in /Users/ketonghe/blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026quot;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026quot; command. 2. Perhaps you want to add some content. You can add single files with \u0026quot;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026quot;. 3. Start the built-in live server via \u0026quot;hugo server\u0026quot;. Visit https://gohugo.io/ for quickstart guide and full documentation.  3 å®‰è£…ä¸»é¢˜å¹¶ä¿®æ”¹ ç°åœ¨hugoä¸»é¢˜å•†åº—æŒºå¤šï¼Œæˆ‘é€‰æ‹©äº†ç›¸å¯¹å¹²å‡€çš„hugo-theme-pure å¦‚æœæ²¡æœ‰gitç¯å¢ƒ å¯è‡ªè¡Œç™¾åº¦å®‰è£…\n$ git clone https://github.com/xiaoheiAh/hugo-theme-pure themes/pure Cloning into 'themes/pure'... remote: Enumerating objects: 13, done. remote: Counting objects: 100% (13/13), done. remote: Compressing objects: 100% (11/11), done. remote: Total 2527 (delta 2), reused 6 (delta 2), pack-reused 2514 Receiving objects: 100% (2527/2527), 4.14 MiB | 519.00 KiB/s, done. Resolving deltas: 100% (1376/1376), done.  config.yml é…ç½®æ–‡ä»¶ä¸»è¦ä¿®æ”¹é¡¹\nbaseURL ä¸»é¡µ menu å¯ä»¥å°†ä¸‹é¢çš„titleæ”¹ä¸ºå¯¹åº”çš„ä¸­æ–‡ donate æ”¹ä¸ºè‡ªå·±çš„å¾®ä¿¡å’Œæ”¯ä»˜å® profile ä¿®æ”¹è‡ªå·±å¤´åƒå’Œä»‹ç»  4 å†™markdownæ–‡ç«  $ hugo new posts/helloworld.md /Users/ketonghe/blog/content/posts/helloworld.md created  ç”¨markdownç¼–è¾‘å™¨ç¼–è¾‘æ–‡ç« \n5 å‘å¸ƒé¢„è§ˆ $ hugo server -D | ZH +------------------+----+ Pages | 13 Paginator pages | 0 Non-page files | 0 Static files | 9 Processed images | 0 Aliases | 6 Sitemaps | 1 Cleaned | 0 Total in 91 ms Watching for changes in /Users/ketonghe/blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Users/ketonghe/blog/config.yml Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop  æ¥ä¸‹æ¥å°±å¯ä»¥åœ¨æœ¬åœ°æµè§ˆå™¨ è¾“å…¥http://localhost:1313/ è®¿é—®äº†\nè¿™ä¸ªä¸»é¢˜æ”¯æŒç«™å†…æœç´¢ è¿˜ä¸é”™\n6 æ·»åŠ è¯„è®ºæ”¯æŒ å‚è€ƒ https://www.smslit.top/2018/07/08/hugo-valine/ ä¸€æ­¥æ­¥æ¥å§\n7 ç”Ÿæˆé™æ€é¡µé¢ ","id":1,"section":"posts","summary":"æ­å»ºhugoé™æ€åšå®¢è®°å½• 1 å®‰è£…Hugo æˆ‘è¿™é‡Œæ˜¯imacæ‰€ä»¥å°±ç›´æ¥ç”¨brew å…¶å®ƒæ“ä½œç³»ç»Ÿä¹Ÿå¾ˆç®€å• ç™¾åº¦ä¸€ä¸‹ä¸€æŠŠ brew install hugo 2 åˆå§‹åŒ–ç«™ç‚¹ç›®å½• å…ˆcdåˆ°ä½ æƒ³","tags":["æ­å»ºåšå®¢"],"title":"create_hugo_blog","uri":"http://heketong.github.io/2020/05/create_hugo_blog/","year":"2020"},{"content":" æ•°ç»„ â€‹ æ•°ç»„æ˜¯ä¸€ç§å…¸å‹çš„çº¿å½¢æ•°æ®ç»“æ„ï¼Œç‰¹ç‚¹ï¼šå­˜æ”¾è¿ç»­çš„ç›¸åŒæ•°æ®ç±»å‹ï¼Œéšæœºè®¿é—®é€Ÿåº¦æ¯”è¾ƒå¿«ã€‚éšæœºæ·»åŠ å’Œåˆ é™¤ï¼Œéœ€è¦æ‰¹é‡ç§»åŠ¨å…ƒç´ ã€‚ä¸»æµç¼–ç¨‹è¯­è¨€åŸºæœ¬ä¸Šè‡ªèº«å°±æä¾›äº†æ•°ç»„è¿™ç§æ•°æ®ç»“æ„ï¼Œæ‰€ä»¥è¿™é‡Œä¸å†ç»ƒä¹ äº†ï¼Œæ•°ç»„è®¿é—®æ³¨æ„è¾¹ç•Œï¼ŒåŠ¨æ€æ•°ç»„å¦‚æœæ˜¯Céœ€è¦è‡ªå·±å®ç°ï¼ŒC++/goæ ‡å‡†åº“ä¹Ÿéƒ½æä¾›äº†åŠ¨æ€æ•°ç»„çš„å®ç°ï¼Œå¯ä»¥æ¯”è¾ƒæ–¹ä¾¿çš„è®¿é—®ã€‚\né“¾è¡¨ ä»‹ç» â€‹ é“¾è¡¨ä¹Ÿæ˜¯ä¸€ç§å¸¸ç”¨çš„çº¿å½¢æ•°æ®ç»“æ„ã€‚ç‰¹ç‚¹ï¼šç©ºé—´ä¸æ˜¯è¿ç»­çš„ï¼Œæ¯ä¸ªèŠ‚ç‚¹é™¤æœ¬èº«æ•°æ®å¤–ï¼Œä¸€èˆ¬éƒ½å­˜å‚¨è‡³å°‘ä¸€ä¸ªæŒ‡é’ˆæ•°æ®ï¼ŒæŒ‡å‘å®ƒçš„å‰é©±æˆ–è€…åç»§èŠ‚ç‚¹ï¼Œå› ä¸ºç©ºé—´ä¸æ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥éšæœºè®¿é—®æ•ˆç‡ä¸é«˜ï¼Œä½†æ˜¯åˆ é™¤ï¼Œæ·»åŠ æ•ˆç‡å¾ˆé«˜ï¼Œä¸éœ€è¦æ‰¹é‡ç§»åŠ¨å…ƒç´ ï¼Œè¿™é‡Œåªç®€å•ç»ƒä¹ ä¸‹åŒå‘å¾ªç¯é“¾è¡¨ï¼Œå•é“¾è¡¨æ›´åŠ ç®€å•ã€‚é‡‡ç”¨æ¥å£çš„æ–¹å¼å®ç°ï¼Œç»ƒä¹ ä¸‹goçš„é¢å‘æ¥å£ç¼–ç¨‹\nä»£ç   DoublyLinkedList_ä¸»è¦æ¥å£åŠç»“æ„ä½“å®šä¹‰ æ¥å£ç”¨ç»“æ„ä½“æŒ‡é’ˆå®ç°\n//LinkNoder é“¾è¡¨æ¥å£å®šä¹‰ æ”¯æŒç›¸å…³æ“ä½œå‡½æ•°å®šä¹‰ type LinkNoder interface { IsEmpty() bool //è¿”å›é“¾è¡¨é‡Šæ”¾ä¸ºç©ºé“¾è¡¨ GetSize() int //è¿”å›é“¾è¡¨é•¿åº¦ Get(index int) *LinkNode //è¿”å›ä¸‹æ ‡å¯¹åº”çš„å…ƒç´ æŒ‡é’ˆ ä¸‹æ ‡ä»0å¼€å§‹ GetFirst() *LinkNode //è¿”å›ç¬¬ä¸€ä¸ªå…ƒç´ æŒ‡é’ˆ ä¹Ÿå°±æ˜¯Head GetLast() *LinkNode //è¿”å›æœ€åä¸€ä¸ªå…ƒç´ æŒ‡é’ˆ ä¹Ÿå°±æ˜¯Tail //åœ¨å¯¹åº”ä¸‹æ ‡ä½ç½®æ’å…¥å…ƒç´  æˆåŠŸè¿”å›true å¤±è´¥è¿”å›false InsertByIndex(index int, PayLoad interface{}) bool //é»˜è®¤åœ¨æœ€åä¸€ä¸ªèŠ‚ç‚¹åé¢æ·»åŠ  PushBack(PayLoad interface{}) bool //æ’å…¥åˆ°è¡¨å¤´ä½ç½® PushFront(PayLoad interface{}) bool //é‡Šæ”¾åŒ…å«æŸä¸ªå…ƒç´  åŒ…å«(true,ä¸‹æ ‡) ä¸åŒ…å« (false,-1) IsContains(PayLoad interface{}) (bool, int, *LinkNode) //æŒ‰ç…§ä¸‹æ ‡åˆ é™¤å…ƒç´  è¿”å›å…ƒç´ å€¼ DelByIndex(index int) interface{} DelHead() interface{} //åˆ é™¤å¤´èŠ‚ç‚¹ DelTail() interface{} //åˆ é™¤å°¾èŠ‚ç‚¹ //æŒ‰ç…§å…ƒç´ å€¼åˆ é™¤ æˆåŠŸè¿”å›true å¤±è´¥è¿”å›false DelByValue(PayLoad interface{}) bool } //LinkNode é“¾è¡¨èŠ‚ç‚¹å®šä¹‰ type LinkNode struct { PayLoad interface{} //èŠ‚ç‚¹å…ƒç´  Prev *LinkNode //å‰ä¸€ä¸ªèŠ‚ç‚¹å…ƒç´ æŒ‡é’ˆ Next *LinkNode //åä¸€ä¸ªèŠ‚ç‚¹å…ƒç´ æŒ‡é’ˆ } //DoublyLinkList åŒå‘å¾ªç¯é“¾è¡¨å®šä¹‰ type DoublyLinkList struct { Head *LinkNode //åŒå‘å¾ªç¯é“¾è¡¨å¤´èŠ‚ç‚¹æŒ‡é’ˆ(è¿™é‡ŒæŒ‡å‘ç¬¬ä¸€ä¸ªçœŸæ­£çš„èŠ‚ç‚¹ å¦‚æœä¸ºnil ä»£è¡¨åŒå‘å¾ªç¯é“¾è¡¨ä¸ºç©º) Tail *LinkNode //åŒå‘å¾ªç¯é“¾è¡¨å°¾éƒ¨èŠ‚ç‚¹æŒ‡é’ˆ Size int //åŒå‘å¾ªç¯é“¾è¡¨é•¿åº¦ }  \n DoublyLinkedListè¯¦ç»†æ¥å£æ–¹æ³•å®ç°\n//CreateDblist åˆ›å»ºä¸€ä¸ªç©ºçš„dblist func CreateDblist() *DoublyLinkList { return \u0026amp;DoublyLinkList{nil, nil, 0} } //DestroyDblist é”€æ¯åŒå‘å¾ªç¯é“¾è¡¨ func DestroyDblist(dblist *DoublyLinkList) { if dblist.Size == 0 { //å¦‚æœé“¾è¡¨ä¸ºç©ºç›´æ¥è¿”å› return } pHead, p := dblist.Head, dblist.Head.Next //pHeadæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ pæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ pHead.Prev, pHead.Next = nil, nil //ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‰é©±åç»§éƒ½ç½®ç©º for p != dblist.Head { //éå†å°†æ‰€æœ‰èŠ‚ç‚¹å‰é©±åç»§éƒ½ç½®ç©º pNext := p.Next //å…ˆè®°å½•å½“å‰èŠ‚ç‚¹çš„åç»§ p.Next, p.Prev = nil, nil //å½“å‰èŠ‚ç‚¹çš„å‰é©±å’Œåç»§æŒ‡é’ˆå¤åˆ¶ä¸ºnil ç­‰å¾…gcå›æ”¶ p = pNext //pæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ } } func (dblist *DoublyLinkList) IsEmpty() bool { return dblist.Size == 0 } func (dblist *DoublyLinkList) GetSize() int { return dblist.Size } func (dblist *DoublyLinkList) GetFirst() *LinkNode { return dblist.Head } func (dblist *DoublyLinkList) GetLast() *LinkNode { return dblist.Tail } func (dblist *DoublyLinkList) Get(index int) *LinkNode { if index \u0026lt; 0 || index \u0026gt;= dblist.Size { fmt.Println(\u0026quot;index invalid\u0026quot;) return nil } p, i := dblist.Head, 0 for ; i \u0026lt; index; i++ { p = p.Next } return p } func (dblist *DoublyLinkList) InsertByIndex(index int, PayLoad interface{}) bool { if index \u0026lt; 0 || index \u0026gt;= dblist.Size { fmt.Println(\u0026quot;index invalid\u0026quot;) return false } //æ„é€ æ’å…¥å…ƒç´ èŠ‚ç‚¹ cur := LinkNode{PayLoad, nil, nil} //å½“å‰é“¾è¡¨ä¸ºç©º æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´  if dblist.Size == 0 \u0026amp;\u0026amp; index == 0 { dblist.Head = \u0026amp;cur dblist.Tail = \u0026amp;cur cur.Prev = \u0026amp;cur cur.Next = \u0026amp;cur dblist.Size++ return true } if index == 0 { //æ’å…¥åˆ°è¡¨å¤´ return dblist.PushFront(PayLoad) } if index == dblist.Size-1 { //æ’å…¥åˆ°è¡¨å°¾ return dblist.PushBack(PayLoad) } //å½“å‰é“¾è¡¨ä¸ä¸ºç©º å…ˆå¾—åˆ°indexä¸‹æ ‡å…ƒç´ æŒ‡é’ˆ ç„¶åæ’å…¥ if p := dblist.Get(index); p != nil { cur.Prev, cur.Next = p.Prev, p p.Prev.Next = \u0026amp;cur p.Prev = \u0026amp;cur dblist.Size++ return true } fmt.Println(\u0026quot;Get(index) err\u0026quot;) return false } func (dblist *DoublyLinkList) PushBack(PayLoad interface{}) bool { //æ„é€ æ’å…¥å…ƒç´ èŠ‚ç‚¹ cur := LinkNode{PayLoad, nil, nil} //å½“å‰é“¾è¡¨ä¸ºç©º æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´  if dblist.Size == 0 { dblist.Head = \u0026amp;cur dblist.Tail = \u0026amp;cur cur.Prev = \u0026amp;cur cur.Next = \u0026amp;cur dblist.Size++ return true } cur.Prev, cur.Next = dblist.Tail, dblist.Head dblist.Tail.Next = \u0026amp;cur dblist.Head.Prev = \u0026amp;cur dblist.Tail = \u0026amp;cur dblist.Size++ return true } func (dblist *DoublyLinkList) PushFront(PayLoad interface{}) bool { //æ„é€ æ’å…¥å…ƒç´ èŠ‚ç‚¹ cur := LinkNode{PayLoad, nil, nil} //å½“å‰é“¾è¡¨ä¸ºç©º æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´  if dblist.Size == 0 { dblist.Head = \u0026amp;cur dblist.Tail = \u0026amp;cur cur.Prev = \u0026amp;cur cur.Next = \u0026amp;cur dblist.Size++ fmt.Println(\u0026quot;dblist.Size=\u0026quot;, dblist.Size) return true } cur.Prev, cur.Next = dblist.Tail, dblist.Head dblist.Head.Prev = \u0026amp;cur dblist.Tail.Next = \u0026amp;cur dblist.Head = \u0026amp;cur dblist.Size++ return true } func (dblist *DoublyLinkList) IsContains(PayLoad interface{}) (bool, int, *LinkNode) { if dblist.Size == 0 { //é“¾è¡¨ä¸ºç©º ç›´æ¥è¿”å›ä¸å­˜åœ¨ return false, -1, nil } for p, i := dblist.Head, 0; i \u0026lt; dblist.Size; p, i = p.Next, i+1 { if p.PayLoad == PayLoad { return true, i, p } } return false, -1, nil } func (dblist *DoublyLinkList) DelHead() interface{} { if dblist.Size == 0 { //é“¾è¡¨ä¸ºç©º ç›´æ¥è¿”å›ä¸å­˜åœ¨ return nil } if dblist.Size == 1 { //å¦‚æœåªæœ‰ä¸€ä¸ªå…ƒç´  åˆ é™¤å®Œé“¾è¡¨ä¸ºç©º PayLoad := dblist.Head.PayLoad dblist.Head, dblist.Tail = nil, nil dblist.Size-- return PayLoad } p := dblist.Head p.Next.Prev = dblist.Tail dblist.Tail.Next = p.Next dblist.Head = p.Next p.Prev, p.Next = nil, nil dblist.Size-- return p.PayLoad } func (dblist *DoublyLinkList) DelTail() interface{} { if dblist.Size == 0 { //é“¾è¡¨ä¸ºç©º ç›´æ¥è¿”å›ä¸å­˜åœ¨ return nil } if dblist.Size == 1 { //å¦‚æœåªæœ‰ä¸€ä¸ªå…ƒç´  åˆ é™¤å®Œé“¾è¡¨ä¸ºç©º PayLoad := dblist.Tail.PayLoad dblist.Head, dblist.Tail = nil, nil dblist.Size-- return PayLoad } p := dblist.Tail dblist.Head.Prev = dblist.Tail.Prev dblist.Tail.Prev.Next = dblist.Head dblist.Tail = dblist.Tail.Prev p.Prev, p.Next = nil, nil dblist.Size-- return p.PayLoad } func (dblist *DoublyLinkList) DelByIndex(index int) interface{} { if index == 0 { return dblist.DelHead() } if index == (dblist.Size - 1) { return dblist.DelTail() } if p := dblist.Get(index); p != nil { p.Prev.Next = p.Next p.Next.Prev = p.Prev p.Prev, p.Next = nil, nil dblist.Size-- return p.PayLoad } return nil } func (dblist *DoublyLinkList) DelByValue(PayLoad interface{}) bool { _, index, p := dblist.IsContains(PayLoad) if index == 0 { _ = dblist.DelHead() return true } if index == (dblist.Size - 1) { _ = dblist.DelTail() return true } if p != nil { p.Prev.Next = p.Next p.Next.Prev = p.Prev p.Prev, p.Next = nil, nil return true } return false } func (dblist *DoublyLinkList) Print() { fmt.Print(\u0026quot;struct DoublyLinkList[\u0026quot;) for i, p := 0, dblist.Head; i \u0026lt; dblist.Size; i++ { fmt.Print(p.PayLoad) fmt.Print(\u0026quot;,\u0026quot;) p = p.Next } fmt.Print(\u0026quot;]\\n\u0026quot;) }  \nä¼˜åŒ– â€‹ å¾…è¡¥å……\nâ€‹ æŒ‰ç…§ä¸‹æ ‡æŸ¥æ‰¾å…ƒç´ å¯ä»¥ç”¨äºŒåˆ†æŸ¥æ‰¾\nç½‘æœå›¾è§£ â€‹ åŒå‘å¾ªç¯é“¾è¡¨æ¯”è¾ƒç®€å•ï¼Œå¾ˆå¥½ç†è§£ ä¸å†æ‰¾å›¾äº†\næ ˆ ä»‹ç» â€‹ æ ˆæ˜¯ä¸€ç§åè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç”¨å¾ˆå¤šæ–¹å¼å®ç°ï¼Œå› ä¸ºæˆ‘ä¹‹å‰çš„åŒå‘å¾ªç¯é“¾è¡¨å·²ç»å®ç°äº†ï¼Œæ‰€ä»¥ç›´æ¥ç”¨å…¶å®ç°äº†\nä»£ç   Stackä»£ç (åŒå‘å¾ªç¯é“¾è¡¨å®ç°)\n//HCStack å®ç°çš„ç®€æ˜“æ ˆ é‡‡ç”¨åŒå‘é“¾è¡¨å®ç° type HCStack struct { Stack *doublylinkedlist.DoublyLinkList } //CreateEmptyStack åˆ›å»ºä¸€ä¸ªç©ºçš„æ ˆ func CreateEmptyStack() *HCStack { dblist := doublylinkedlist.CreateDblist() return \u0026amp;HCStack{dblist} } //GetSize è·å–æ ˆçš„çœŸå®é•¿åº¦ func (hcstack *HCStack) GetSize() int { return hcstack.Stack.GetSize() } //IsEmpty è¿”å›æ ˆæ˜¯å¦ä¸ºç©º func (hcstack *HCStack) IsEmpty() bool { return hcstack.Stack.IsEmpty() } //Push å‹æ ˆæ“ä½œ func (hcstack *HCStack) Push(payLoad interface{}) bool { return hcstack.Stack.PushFront(payLoad) } //Pop å‡ºæ ˆæ“ä½œ func (hcstack *HCStack) Pop() interface{} { if hcstack.Stack.Size == 0 { fmt.Println(\u0026quot;æ ˆä¸ºç©º\u0026quot;) return nil } return hcstack.Stack.DelHead() } //Peek è·å–æ ˆé¡¶å…ƒç´  ä¸åˆ é™¤ func (hcstack *HCStack) Peek() interface{} { if hcstack.Stack.Size == 0 { fmt.Println(\u0026quot;æ ˆä¸ºç©º\u0026quot;) return nil } return hcstack.Stack.GetFirst().PayLoad } //Clear æ¸…ç©ºæ ˆ func (hcstack *HCStack) Clear() { doublylinkedlist.DestroyDblist(hcstack.Stack) }  \né˜Ÿåˆ— ä»‹ç» â€‹ é˜Ÿåˆ—æ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç”¨å¾ˆå¤šæ–¹å¼å®ç°ï¼Œå› ä¸ºæˆ‘ä¹‹å‰çš„åŒå‘å¾ªç¯é“¾è¡¨å·²ç»å®ç°äº†ï¼Œæ‰€ä»¥ç›´æ¥ç”¨å…¶å®ç°äº†\nä»£ç   Queueä»£ç (åŒå‘å¾ªç¯é“¾è¡¨å®ç°)\n//HCQueue å®ç°çš„ç®€æ˜“é˜Ÿåˆ— é‡‡ç”¨åŒå‘é“¾è¡¨å®ç° type HCQueue struct { Queue *doublylinkedlist.DoublyLinkList } //CreateEmptyQueue åˆ›å»ºä¸€ä¸ªç©ºçš„æ ˆ func CreateEmptyQueue() *HCQueue { dblist := doublylinkedlist.CreateDblist() return \u0026amp;HCQueue{dblist} } //GetSize è·å–é˜Ÿåˆ—çš„çœŸå®é•¿åº¦ func (hcqueue *HCQueue) GetSize() int { return hcqueue.Queue.Size } //IsEmpty è¿”å›é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º func (hcqueue *HCQueue) IsEmpty() bool { return hcqueue.Queue.Size == 0 } //Push å…¥é˜Ÿåˆ—æ“ä½œ func (hcqueue *HCQueue) Push(payLoad interface{}) bool { return hcqueue.Queue.PushBack(payLoad) } //Pop å‡ºé˜Ÿåˆ—æ“ä½œ func (hcqueue *HCQueue) Pop() interface{} { if hcqueue.Queue.Size == 0 { fmt.Println(\u0026quot;Pop é˜Ÿåˆ—ä¸ºç©º\u0026quot;) return nil } return hcqueue.Queue.DelHead() } //GetHead è·å–é˜Ÿå¤´å…ƒç´  ä¸åˆ é™¤ func (hcqueue *HCQueue) GetHead() interface{} { if hcqueue.Queue.Size == 0 { fmt.Println(\u0026quot;GetHead é˜Ÿåˆ—ä¸ºç©º\u0026quot;) return nil } return hcqueue.Queue.GetFirst().PayLoad } //GetTail è·å–é˜Ÿå¤´å…ƒç´  ä¸åˆ é™¤ func (hcqueue *HCQueue) GetTail() interface{} { if hcqueue.Queue.Size == 0 { fmt.Println(\u0026quot;GetTail é˜Ÿåˆ—ä¸ºç©º\u0026quot;) return nil } return hcqueue.Queue.GetLast().PayLoad } //Clear æ¸…ç©ºæ ˆ func (hcqueue *HCQueue) Clear() { doublylinkedlist.DestroyDblist(hcqueue.Queue) }  \näºŒå‰æ ‘ ä»‹ç» â€‹ äºŒå‰æ ‘æ˜¯æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰2ä¸ªå­æ ‘çš„æ ‘ç»“æ„ï¼Œæœ‰5ç§åŸºæœ¬å½¢æ€ã€‚\næ€§è´¨1ï¼šäºŒå‰æ ‘ç¬¬iå±‚ä¸Šçš„ç»“ç‚¹æ•°ç›®æœ€å¤šä¸º 2{i-1} (iâ‰¥1)ã€‚ æ€§è´¨2ï¼šæ·±åº¦ä¸ºkçš„äºŒå‰æ ‘è‡³å¤šæœ‰2{k}-1ä¸ªç»“ç‚¹(kâ‰¥1)ã€‚ æ€§è´¨3ï¼šåŒ…å«nä¸ªç»“ç‚¹çš„äºŒå‰æ ‘çš„é«˜åº¦è‡³å°‘ä¸ºlog2 (n+1)ã€‚ æ€§è´¨4ï¼šåœ¨ä»»æ„ä¸€æ£µäºŒå‰æ ‘ä¸­ï¼Œè‹¥ç»ˆç«¯ç»“ç‚¹çš„ä¸ªæ•°ä¸ºn0ï¼Œåº¦ä¸º2çš„ç»“ç‚¹æ•°ä¸ºn2ï¼Œåˆ™n0=n2+1ã€‚\næ€§è´¨1ï¼šäºŒå‰æ ‘ç¬¬iå±‚ä¸Šçš„ç»“ç‚¹æ•°ç›®æœ€å¤šä¸º 2{i-1} (iâ‰¥1) â€‹ è¯æ˜ï¼šä¸‹é¢ç”¨\u0026rdquo;æ•°å­¦å½’çº³æ³•\u0026rdquo;è¿›è¡Œè¯æ˜ã€‚ (01) å½“i=1æ—¶ï¼Œç¬¬iå±‚çš„èŠ‚ç‚¹æ•°ç›®ä¸º2{i-1}=2{0}=1ã€‚å› ä¸ºç¬¬1å±‚ä¸Šåªæœ‰ä¸€ä¸ªæ ¹ç»“ç‚¹ï¼Œæ‰€ä»¥å‘½é¢˜æˆç«‹ã€‚ (02) å‡è®¾å½“i\u0026gt;1ï¼Œç¬¬iå±‚çš„èŠ‚ç‚¹æ•°ç›®ä¸º2{i-1}ã€‚è¿™ä¸ªæ˜¯æ ¹æ®(01)æ¨æ–­å‡ºæ¥çš„ï¼ â€‹ ä¸‹é¢æ ¹æ®è¿™ä¸ªå‡è®¾ï¼Œæ¨æ–­å‡º\u0026rdquo;ç¬¬(i+1)å±‚çš„èŠ‚ç‚¹æ•°ç›®ä¸º2{i}\u0026ldquo;å³å¯ã€‚ â€‹ ç”±äºäºŒå‰æ ‘çš„æ¯ä¸ªç»“ç‚¹è‡³å¤šæœ‰ä¸¤ä¸ªå­©å­ï¼Œæ•…\u0026rdquo;ç¬¬(i+1)å±‚ä¸Šçš„ç»“ç‚¹æ•°ç›®\u0026rdquo; æœ€å¤šæ˜¯ \u0026ldquo;ç¬¬iå±‚çš„ç»“ç‚¹æ•°ç›®çš„2å€\u0026rdquo;ã€‚å³ï¼Œç¬¬(i+1)å±‚ä¸Šçš„ç»“ç‚¹æ•°ç›®æœ€å¤§å€¼=2Ã—2{i-1}=2{i}ã€‚ â€‹ æ•…å‡è®¾æˆç«‹ï¼ŒåŸå‘½é¢˜å¾—è¯ï¼\næ€§è´¨2ï¼šæ·±åº¦ä¸ºkçš„äºŒå‰æ ‘è‡³å¤šæœ‰2{k}-1ä¸ªç»“ç‚¹(kâ‰¥1) â€‹ è¯æ˜ï¼šåœ¨å…·æœ‰ç›¸åŒæ·±åº¦çš„äºŒå‰æ ‘ä¸­ï¼Œå½“æ¯ä¸€å±‚éƒ½å«æœ‰æœ€å¤§ç»“ç‚¹æ•°æ—¶ï¼Œå…¶æ ‘ä¸­ç»“ç‚¹æ•°æœ€å¤šã€‚åˆ©ç”¨\u0026rdquo;æ€§è´¨1\u0026rdquo;å¯çŸ¥ï¼Œæ·±åº¦ä¸ºkçš„äºŒå‰æ ‘çš„ç»“ç‚¹æ•°è‡³å¤šä¸ºï¼š 20+21+â€¦+2k-1=2k-1 æ•…åŸå‘½é¢˜å¾—è¯ï¼\næ€§è´¨3ï¼šåŒ…å«nä¸ªç»“ç‚¹çš„äºŒå‰æ ‘çš„é«˜åº¦è‡³å°‘ä¸ºlog2 (n+1) â€‹ è¯æ˜ï¼šæ ¹æ®\u0026rdquo;æ€§è´¨2\u0026rdquo;å¯çŸ¥ï¼Œé«˜åº¦ä¸ºhçš„äºŒå‰æ ‘æœ€å¤šæœ‰2{h}â€“1ä¸ªç»“ç‚¹ã€‚åä¹‹ï¼Œå¯¹äºåŒ…å«nä¸ªèŠ‚ç‚¹çš„äºŒå‰æ ‘çš„é«˜åº¦è‡³å°‘ä¸ºlog2(n+1)ã€‚\næ€§è´¨4ï¼šåœ¨ä»»æ„ä¸€æ£µäºŒå‰æ ‘ä¸­ï¼Œè‹¥ç»ˆç«¯ç»“ç‚¹çš„ä¸ªæ•°ä¸ºn0ï¼Œåº¦ä¸º2çš„ç»“ç‚¹æ•°ä¸ºn2ï¼Œåˆ™n0=n2+1 â€‹ è¯æ˜ï¼šå› ä¸ºäºŒå‰æ ‘ä¸­æ‰€æœ‰ç»“ç‚¹çš„åº¦æ•°å‡ä¸å¤§äº2ï¼Œæ‰€ä»¥ç»“ç‚¹æ€»æ•°(è®°ä¸ºn)=\u0026ldquo;0åº¦ç»“ç‚¹æ•°(n0)\u0026rdquo; + \u0026ldquo;1åº¦ç»“ç‚¹æ•°(n1)\u0026rdquo; + \u0026ldquo;2åº¦ç»“ç‚¹æ•°(n2)\u0026ldquo;ã€‚ç”±æ­¤ï¼Œå¾—åˆ°ç­‰å¼ä¸€ã€‚ (ç­‰å¼ä¸€) n=n0+n1+n2 å¦ä¸€æ–¹é¢ï¼Œ0åº¦ç»“ç‚¹æ²¡æœ‰å­©å­ï¼Œ1åº¦ç»“ç‚¹æœ‰ä¸€ä¸ªå­©å­ï¼Œ2åº¦ç»“ç‚¹æœ‰ä¸¤ä¸ªå­©å­ï¼Œæ•…äºŒå‰æ ‘ä¸­å­©å­ç»“ç‚¹æ€»æ•°æ˜¯ï¼šn1+2n2ã€‚æ­¤å¤–ï¼Œåªæœ‰æ ¹ä¸æ˜¯ä»»ä½•ç»“ç‚¹çš„å­©å­ã€‚\nâ€‹ æ•…äºŒå‰æ ‘ä¸­çš„ç»“ç‚¹æ€»æ•°åˆå¯è¡¨ç¤ºä¸ºç­‰å¼äºŒã€‚ (ç­‰å¼äºŒ) n=n1+2n2+1 ç”±(ç­‰å¼ä¸€)å’Œ(ç­‰å¼äºŒ)è®¡ç®—å¾—åˆ°ï¼šn0=n2+1ã€‚åŸå‘½é¢˜å¾—è¯ï¼\næ»¡äºŒå‰æ ‘ â€‹ é«˜åº¦ä¸ºhï¼Œå¹¶ä¸”ç”±2{h} â€“1ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ï¼Œè¢«ç§°ä¸ºæ»¡äºŒå‰æ ‘\nå®Œå…¨äºŒå‰æ ‘ å®šä¹‰ï¼šä¸€æ£µäºŒå‰æ ‘ä¸­ï¼Œåªæœ‰æœ€ä¸‹é¢ä¸¤å±‚ç»“ç‚¹çš„åº¦å¯ä»¥å°äº2ï¼Œå¹¶ä¸”æœ€ä¸‹ä¸€å±‚çš„å¶ç»“ç‚¹é›†ä¸­åœ¨é å·¦çš„è‹¥å¹²ä½ç½®ä¸Šã€‚è¿™æ ·çš„äºŒå‰æ ‘ç§°ä¸ºå®Œå…¨äºŒå‰æ ‘ã€‚ ç‰¹ç‚¹ï¼šå¶å­ç»“ç‚¹åªèƒ½å‡ºç°åœ¨æœ€ä¸‹å±‚å’Œæ¬¡ä¸‹å±‚ï¼Œä¸”æœ€ä¸‹å±‚çš„å¶å­ç»“ç‚¹é›†ä¸­åœ¨æ ‘çš„å·¦éƒ¨ã€‚æ˜¾ç„¶ï¼Œä¸€æ£µæ»¡äºŒå‰æ ‘å¿…å®šæ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œè€Œå®Œå…¨äºŒå‰æ ‘æœªå¿…æ˜¯æ»¡äºŒå‰æ ‘\näºŒå‰æŸ¥æ‰¾æ ‘ â€‹ åˆå«äºŒå‰æ’åºæ ‘ ,è‹±æ–‡ä¸€èˆ¬æ˜¯binary_search_treeã€‚è¿™é‡Œä¼šé‡ç‚¹å¤ä¹ ä¸‹äºŒå‰æŸ¥æ‰¾æ ‘\n è‹¥ä»»æ„èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼› ä»»æ„èŠ‚ç‚¹çš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å¤§äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼› ä»»æ„èŠ‚ç‚¹çš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æŸ¥æ‰¾æ ‘ã€‚ æ²¡æœ‰é”®å€¼ç›¸ç­‰çš„èŠ‚ç‚¹ï¼ˆno duplicate nodesï¼‰  Binary_Search_Tree äºŒå‰æŸ¥æ‰¾æ ‘ é‡è¦æ¦‚å¿µä»‹ç»  ä¸€ä¸ªèŠ‚ç‚¹ä¸€èˆ¬æœ‰æ•°æ®åŸŸã€å·¦å­©å­æŒ‡é’ˆï¼Œå³å­©å­æŒ‡é’ˆï¼Œçˆ¶èŠ‚ç‚¹æŒ‡é’ˆ\n å‰åºéå†\n  å…ˆéå†æ ¹èŠ‚ç‚¹ å†éå†å·¦å­æ ‘ å†éå†å³å­æ ‘\n ä¸­åºéå†  å…ˆéå†å·¦å­æ ‘ å†éå†æ ¹èŠ‚ç‚¹ å†éå†å³å­æ ‘\n ååºéå†  å…ˆéå†å·¦å­æ ‘ å†éå†å³å­æ ‘ å†éå†æ ¹èŠ‚ç‚¹\n å‰é©±èŠ‚ç‚¹  å°äºè¯¥èŠ‚ç‚¹å€¼ä¸­æœ€å¤§çš„ä¸€ä¸ªèŠ‚ç‚¹\n åç»§èŠ‚ç‚¹  å¤§äºè¯¥èŠ‚ç‚¹å€¼ä¸­æœ€å°çš„ä¸€ä¸ªèŠ‚ç‚¹\n æ’å…¥å¤§æ¦‚é€»è¾‘\né¦–å…ˆè¦ä¸ºå¾…æ’å…¥èŠ‚ç‚¹(toIns)æ‰¾åˆ°åˆé€‚çš„èŠ‚ç‚¹ä½ç½®ï¼Œå‡†ç¡®æ¥è¯´å°±æ˜¯è¦æ‰¾åˆ°toInsçš„çˆ¶èŠ‚ç‚¹(parent),ç„¶åæ¯”è¾ƒkeyï¼Œåˆ¤æ–­æ˜¯å·¦å­©å­è¿˜æ˜¯å³è¾¹å­©å­ if ( æ ‘ä¸ºç©º){ç›´æ¥æ’å…¥ï¼Œä¹Ÿå°±æ˜¯æ­¤èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹ }else{ //æ ‘ä¸ä¸ºç©º cur=root //å½“å‰èŠ‚ç‚¹æŒ‡å‘æ ¹èŠ‚ç‚¹ while(cur != null){ parent=cur // toInsçš„parentä¹ŸæŒ‡å‘å½“å‰èŠ‚ç‚¹ if (toIns.key\u0026lt;cur.key){ //å°äºå½“å‰èŠ‚ç‚¹çš„å€¼,å½“å‰èŠ‚ç‚¹å˜ä¸ºå…¶å·¦å­©å­ cur=cur.left } if (toIns.key\u0026gt;cur.key){ //å°äºå½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œå½“å‰èŠ‚ç‚¹å˜ä¸ºå…¶å³å­©å­ cur=cur.right } if ( key == cur.key ){ return //ä¸å…è®¸æ’å…¥ç›¸åŒèŠ‚ç‚¹ } } if toIns.key\u0026lt;parent.key{ parent-\u0026gt;left=toIns }else{ parent-\u0026gt;right=toIns } }  æŸ¥æ‰¾å‰é©±èŠ‚ç‚¹å¤§æ¦‚é€»è¾‘\npredecessor=null if ( cur.left != null ){//å¦‚æœå·¦å­æ ‘ä¸ä¸ºç©º åˆ™æ‰¾å·¦å­æ ‘ä¸Šé¢çš„æœ€å¤§å€¼ for predecessor=cur.left;predecessor.right!=null;predecessor=predecessor.right{} }else{ if( curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å³è¾¹å­©å­){ predecessor=cur.parent //å‰é©±å°±æ˜¯å…¶çˆ¶èŠ‚ç‚¹ }elseif (curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ ){ //æ‰¾åˆ°çˆ·çˆ· å¹¶ä¸”å…¶çˆ¶èŠ‚ç‚¹æ˜¯å…¶çˆ·çˆ·çš„å³å­©å­ cur.parent.parent!=null \u0026amp;\u0026amp; cur.parent.parent.right==cur.parent predecessor=cur.parent.parent } } return predecessor  æŸ¥æ‰¾åç»§èŠ‚ç‚¹å¤§å€¼é€»è¾‘\nsuccessor=null if( cur.right != null){//å¦‚æœå³è¾¹å­æ ‘ä¸ä¸ºç©º åˆ™æ‰¾å³è¾¹å­æ ‘ä¸Šé¢çš„æœ€å°å€¼ for successor=cur.right;successor.left!=null;successor=successor.left{} }else{ if( curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­){ successor=cur.parent //åç»§å°±æ˜¯å…¶çˆ¶èŠ‚ç‚¹ }elseif (curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å³å­©å­ ){ //æ‰¾åˆ°çˆ·çˆ· å¹¶ä¸”å…¶çˆ¶èŠ‚ç‚¹æ˜¯å…¶çˆ·çˆ·çš„å·¦å­©å­ cur.parent.parent!=null \u0026amp;\u0026amp; cur.parent.parent.left==cur.parent successor=cur.parent.parent } } return successor  åˆ é™¤èŠ‚ç‚¹é€»è¾‘\næ ¸å¿ƒé€»è¾‘ åˆ é™¤åä¸èƒ½æ”¹å˜äºŒå‰æ ‘çš„ç‰¹ç‚¹ if (curä¸ºå¶å­èŠ‚ç‚¹){ cur.parent.(left|right)=null cur.parent=null }elseif ( curæœ‰ä¸€ä¸ªå­©å­) //å°†curçš„çˆ¶äº²æŒ‡å‘å…¶å­©å­å³å¯ cur.parent.(left|right)=cur.(left|right) cur.(left|right).parent=cur.parent cur.(left|right)=cur.parent=null }elseif (curæœ‰2ä¸ªå­©å­){ //æ‰¾åˆ°å…¶åç»§èŠ‚ç‚¹ successor cur.key=successor.key //åˆ é™¤åç»§èŠ‚ç‚¹ successor.parent.(left|right)=null successor.left=successor.right=successor.parent=null }   ä»£ç   BinarySearchTreeä»£ç å®ç°\n//Less æ¯”è¾ƒä¸¤ä¸ªå…ƒç´ å¤§å° å¦‚æœa\u0026lt;b è¿”å›true è´Ÿè´£è¿”å›false type Less func(a interface{}, b interface{}) bool //BSTNODE èŠ‚ç‚¹å®šä¹‰ type BSTNODE struct { Key interface{} Left *BSTNODE //å·¦å­©å­ Right *BSTNODE //å³å­©å­ Parent *BSTNODE //çˆ¶èŠ‚ç‚¹ } //ChildVisitCount è®°å½•æŸä¸€ä¸ªèŠ‚ç‚¹å¯¹åº”çš„å­©å­èŠ‚ç‚¹è®¿é—®æ¬¡æ•° ç”¨æ¥åˆ¤æ–­å­©å­èŠ‚ç‚¹æ˜¯å¦éƒ½è®¿é—®è¿‡äº† type ChildVisitCount struct { node *BSTNODE count int } //BSTTREE äºŒå‰æœç´¢æ ‘å®šä¹‰ type BSTTREE struct { Root *BSTNODE //æ ¹èŠ‚ç‚¹ Size int //å½“å‰èŠ‚ç‚¹æ•° less Less //æ¯”è¾ƒæ˜¯å¦å°äºå‡½æ•° è°ƒç”¨è€…å¯è‡ªè¡Œå®ç° } //BSTTreeInterface äºŒå‰æœç´¢æ ‘æ¥å£å®šä¹‰ type BSTTreeInterface interface { //IsEmpty åˆ¤æ–­ä¸€ä¸ªäºŒå‰æœç´¢æ ‘æ˜¯å¦ä¸ºç©º IsEmpty() bool //Insert æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ è¿”å›æ˜¯å¦æ’å…¥æˆåŠŸ Insert(Key interface{}) bool //SearchKey æŸ¥æ‰¾ä¸€ä¸ªKeyæ˜¯å¦å­˜åœ¨ åœ¨åˆ™è¿”å›å…¶èŠ‚ç‚¹åœ°å€ ä¸åœ¨åˆ™è¿”å›nil SearchKey(Key interface{}) *BSTNODE //DeleteByNode åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ æ ¹æ®ä¼ å…¥çš„èŠ‚ç‚¹åœ°å€åˆ é™¤ è¿”å›æ˜¯å¦åˆ é™¤æˆåŠŸ DeleteByNode(cur *BSTNODE) bool //GetMax å¾—åˆ°æ ‘çš„æœ€å¤§å€¼ GetMax() interface{} //GetMin å¾—åˆ°æ ‘çš„æœ€å°å€¼ GetMin() interface{} //GetPredecessor æ‰¾åˆ°å½“å‰èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ GetPredecessor(cur *BSTNODE) *BSTNODE //GetSuccessor æ‰¾åˆ°å½“å‰èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹ GetSuccessor(cur *BSTNODE) *BSTNODE //å‰åºéå†äºŒå‰æ ‘ æ‰“å°åˆ°å±å¹• PreOrder() //ä¸­åºéå†äºŒå‰æ ‘ æ‰“å°åˆ°å±å¹• InOrder() //ååºéå†äºŒå‰æ ‘ æ‰“å°åˆ°å±å¹• PostOrder() //å‰åºéå†äºŒå‰æ ‘ è¿”å›ä¸€ä¸ªslice PreOrderToSlice() []*BSTNODE //ä¸­åºéå†äºŒå‰æ ‘ è¿”å›ä¸€ä¸ªslice InOrderToSlice() []*BSTNODE //ååºéå†äºŒå‰æ ‘ è¿”å›ä¸€ä¸ªslice PostOrderToSlice() []*BSTNODE } //CreateEmptyTree åˆ›å»ºä¸€ä¸ªç©ºçš„äºŒå‰æœç´¢æ ‘ func CreateEmptyTree(less Less) *BSTTREE { return \u0026amp;BSTTREE{nil, 0, less} } //DestroyTree é”€æ¯ä¸€ä¸ªäºŒå‰æ ‘ å‰åºéå†é”€æ¯BST func DestroyTree(tree *BSTTREE) { myStack := stack.CreateEmptyStack() if tree.Size \u0026gt; 0 { myStack.Push(tree.Root) //æ ¹èŠ‚ç‚¹å…ˆå‹æ ˆ } for myStack.IsEmpty() == false { node := myStack.Pop().(*BSTNODE) //å…ˆéå†æ ¹èŠ‚ç‚¹ if node.Right != nil { myStack.Push(node.Right) //å…ˆå‹å³å­æ ‘ } if node.Left != nil { myStack.Push(node.Left) //å†å‹å·¦å­æ ‘ } node.Left, node.Right, node.Parent = nil, nil, nil } myStack.Clear() } //CreateBSTree æŠŠæ¥å£ç±»å‹çš„åˆ‡ç‰‡è½¬æ¢ä¸ºäºŒå‰æŸ¥æ‰¾æ ‘ è¿”å›æ ‘èŠ‚ç‚¹ func CreateBSTree(a []interface{}, less Less) *BSTTREE { tree := \u0026amp;BSTTREE{nil, 0, less} for i := 0; i \u0026lt; len(a); i++ { tree.Insert(a[i]) } return tree } //IsEmpty åˆ¤æ–­ä¸€ä¸ªäºŒå‰æœç´¢æ ‘æ˜¯å¦ä¸ºç©º func (tree *BSTTREE) IsEmpty() bool { return tree.Size == 0 } //Insert æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ è¿”å›æ˜¯å¦æ’å…¥æˆåŠŸ func (tree *BSTTREE) Insert(Key interface{}) bool { toIns := BSTNODE{Key, nil, nil, nil} if tree.Root == nil { //å½“å‰æ ‘ä¸ºç©º tree.Root = \u0026amp;toIns tree.Size++ return true } //å½“å‰æ ‘ä¸ä¸ºç©º cur, Parent := tree.Root, tree.Root //ParentæŒ‡çš„æ˜¯å¾…æ’å…¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ for cur != nil { Parent = cur // toInsçš„Parentä¹ŸæŒ‡å‘å½“å‰èŠ‚ç‚¹ if tree.less(toIns.Key, cur.Key) { //å°äºå½“å‰èŠ‚ç‚¹çš„å€¼,å½“å‰èŠ‚ç‚¹å˜ä¸ºå…¶å·¦å­©å­ cur = cur.Left } else if toIns.Key == cur.Key { return false //ä¸å…è®¸æ’å…¥ç›¸åŒèŠ‚ç‚¹ } else { //å¤§äºå½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œå½“å‰èŠ‚ç‚¹å˜ä¸ºå…¶å³å­©å­ cur = cur.Right } } tree.Size++ toIns.Parent = Parent if tree.less(toIns.Key, Parent.Key) { Parent.Left = \u0026amp;toIns } else { Parent.Right = \u0026amp;toIns } return true } //SearchKey æŸ¥æ‰¾ä¸€ä¸ªKeyæ˜¯å¦å­˜åœ¨ åœ¨åˆ™è¿”å›å…¶èŠ‚ç‚¹åœ°å€ ä¸åœ¨åˆ™è¿”å›nil func (tree *BSTTREE) SearchKey(Key interface{}) *BSTNODE { cur := tree.Root for cur != nil \u0026amp;\u0026amp; cur.Key != Key { if tree.less(Key, cur.Key) { cur = cur.Left } else { cur = cur.Right } } return cur } //DeleteByKey åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ æ ¹æ®ä¼ å…¥çš„èŠ‚ç‚¹Keyå€¼åˆ é™¤ è¿”å›æ˜¯å¦åˆ é™¤æˆåŠŸ func (tree *BSTTREE) DeleteByKey(Key interface{}) bool { node := tree.SearchKey(Key) if node != nil { return tree.DeleteByNode(node) } return false //å¦‚æœnodeä¸ºç©º ä»£è¡¨Keyä¸åœ¨æ ‘ç§ ç›´æ¥è¿”å›false } //DeleteByNode åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ æ ¹æ®ä¼ å…¥çš„èŠ‚ç‚¹åœ°å€åˆ é™¤ è¿”å›æ˜¯å¦åˆ é™¤æˆåŠŸ func (tree *BSTTREE) DeleteByNode(delNode *BSTNODE) bool { if delNode != nil { if delNode.Left == nil { //å¦‚æœå…¶å·¦å­æ ‘ä¸ºç©º åˆ™ç”¨å…¶å³å­©å­æ›¿æ¢è¢«åˆ é™¤èŠ‚ç‚¹å³å¯ å½“ç„¶å¦‚æœå³å­©å­æ˜¯ç©º ä¹Ÿå°±æ˜¯çº¯å¶å­èŠ‚ç‚¹ ç›´æ¥åˆ é™¤å³å¯ fmt.Println(\u0026quot;åˆ é™¤èŠ‚ç‚¹å·¦å­æ ‘ä¸ºç©º\u0026quot;) tree.replaceNode(delNode, delNode.Right) } else if delNode.Right == nil { //å¦‚æœå…¶å³å­æ ‘ä¸ºç©º åˆ™ç”¨å…¶å·¦å­©å­æ›¿æ¢è¢«åˆ é™¤èŠ‚ç‚¹å³å¯ fmt.Println(\u0026quot;åˆ é™¤èŠ‚ç‚¹å³å­æ ‘ä¸ºç©º\u0026quot;) tree.replaceNode(delNode, delNode.Left) } else { fmt.Println(\u0026quot;åˆ é™¤èŠ‚ç‚¹å·¦å³å­æ ‘éƒ½éç©º\u0026quot;) //å·¦å³å­æ ‘éƒ½éç©º è¿™ä¸ªæ—¶å€™å°±æ‰¾åˆ°å…¶åç»§èŠ‚ç‚¹ ç„¶åæ›¿æ¢ succssor := tree.GetSuccessor(delNode) if succssor.Parent != delNode { //åç»§èŠ‚ç‚¹ä¸æ˜¯å…¶å³å­©å­(å…¶å³å­©å­è¿˜æœ‰å·¦å­æ ‘) fmt.Println(\u0026quot;åç»§èŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹ä¸æ˜¯åˆ é™¤èŠ‚ç‚¹\u0026quot;) //æ‹¿åç»§èŠ‚ç‚¹å³å­©å­æ›¿æ¢åç»§èŠ‚ç‚¹ ä¹Ÿå°±æ˜¯åç»§èŠ‚ç‚¹çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ å˜ä¸ºåç»§èŠ‚ç‚¹çš„å³å­©å­ tree.replaceNode(succssor, succssor.Right) succssor.Right = delNode.Right //æ›´æ–°åç»§èŠ‚ç‚¹çš„å³å­©å­ æŒ‡å‘è¢«åˆ é™¤èŠ‚ç‚¹çš„å³å­©å­ delNode.Right.Parent = succssor //åŒæ—¶æ›´æ–°è¢«åˆ é™¤èŠ‚ç‚¹å³å­©å­çš„çš„Parentå±æ€§ } tree.replaceNode(delNode, succssor) //æ‹¿åç»§èŠ‚ç‚¹æ›¿æ¢è¢«åˆ é™¤èŠ‚ç‚¹ succssor.Left = delNode.Left //åç»§èŠ‚ç‚¹çš„å·¦å­©å­ æŒ‡å‘è¢«åˆ é™¤èŠ‚ç‚¹çš„å·¦å­©å­ delNode.Left.Parent = succssor //åŒæ—¶æ›´æ–°è¢«åˆ é™¤èŠ‚ç‚¹å·¦å­©å­çš„Parentå±æ€§ } tree.Size-- delNode.Parent, delNode.Left, delNode.Right = nil, nil, nil //ç­‰å¾…gcå›æ”¶ return true } return false } //replaceNode ç”¨newNodeæ›¿æ¢nodeToRepalceèŠ‚ç‚¹ func (tree *BSTTREE) replaceNode(nodeToReplace *BSTNODE, newNode *BSTNODE) *BSTNODE { if nodeToReplace.Parent == nil { //å¦‚æœè¢«æ›¿æ¢çš„æ˜¯æ ¹èŠ‚ç‚¹ åˆ™æ›´æ–°æ ¹èŠ‚ç‚¹æŒ‡å‘æ–°çš„èŠ‚ç‚¹ tree.Root = newNode } else if nodeToReplace == nodeToReplace.Parent.Left { //å¦‚æœè¢«æ›¿æ¢èŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ åˆ™å°†å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­æŒ‡å‘æ–°çš„èŠ‚ç‚¹ nodeToReplace.Parent.Left = newNode } else { //å¦‚æœè¢«æ›¿æ¢èŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å³å­©å­ åˆ™å°†å…¶çˆ¶èŠ‚ç‚¹çš„å³å­©å­æŒ‡å‘æ–°çš„èŠ‚ç‚¹ nodeToReplace.Parent.Right = newNode } if newNode != nil { //å¦‚æœæ–°çš„èŠ‚ç‚¹éç©º åˆ™æ›´æ”¹å…¶çˆ¶èŠ‚ç‚¹ä¸ºè¢«æ›¿æ¢èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ newNode.Parent = nodeToReplace.Parent } return newNode } //GetMax å¾—åˆ°æ ‘çš„æœ€å¤§å€¼ func (tree *BSTTREE) GetMax() interface{} { maxNode := tree.Root for ; maxNode.Right != nil; maxNode = maxNode.Right { } if maxNode != nil { return maxNode.Key } return nil } //GetMin å¾—åˆ°æ ‘çš„æœ€å°å€¼ func (tree *BSTTREE) GetMin() interface{} { minNode := tree.Root for ; minNode.Left != nil; minNode = minNode.Left { } if minNode != nil { return minNode.Key } return nil } //GetPredecessor æ‰¾åˆ°å½“å‰èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹ func (tree *BSTTREE) GetPredecessor(cur *BSTNODE) *BSTNODE { var predecessor *BSTNODE = nil if cur.Left != nil { //å¦‚æœå·¦å­æ ‘ä¸ä¸ºç©º åˆ™æ‰¾å·¦å­æ ‘ä¸Šé¢çš„æœ€å¤§å€¼ for predecessor = cur.Left; predecessor.Right != nil; predecessor = predecessor.Right { } } else { if cur.Parent != nil \u0026amp;\u0026amp; cur == cur.Parent.Right { //curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å³è¾¹å­©å­ å‰é©±å°±æ˜¯å…¶çˆ¶èŠ‚ç‚¹ predecessor = cur.Parent } else if cur.Parent != nil \u0026amp;\u0026amp; cur == cur.Parent.Left { // curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ æ‰¾åˆ°çˆ·çˆ· å¹¶ä¸”å…¶çˆ¶èŠ‚ç‚¹æ˜¯å…¶çˆ·çˆ·çš„å³å­©å­ if cur.Parent.Parent != nil \u0026amp;\u0026amp; cur.Parent.Parent.Right == cur.Parent { predecessor = cur.Parent.Parent } } } return predecessor } //GetSuccessor æ‰¾åˆ°å½“å‰èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹ func (tree *BSTTREE) GetSuccessor(cur *BSTNODE) *BSTNODE { var successor *BSTNODE = nil if cur.Right != nil { //å¦‚æœå³è¾¹å­æ ‘ä¸ä¸ºç©º åˆ™æ‰¾å³è¾¹å­æ ‘ä¸Šé¢çš„æœ€å°å€¼ for successor = cur.Right; successor.Left != nil; successor = successor.Left { } } else { if cur.Parent != nil \u0026amp;\u0026amp; cur.Parent.Left == cur { // curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ successor = cur.Parent } else if cur.Parent != nil \u0026amp;\u0026amp; cur.Parent.Right == cur { //curæ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å³å­©å­ æ‰¾åˆ°çˆ·çˆ· å¹¶ä¸”å…¶çˆ¶èŠ‚ç‚¹æ˜¯å…¶çˆ·çˆ·çš„å·¦å­©å­ if cur.Parent.Parent != nil \u0026amp;\u0026amp; cur.Parent.Parent.Left == cur.Parent { successor = cur.Parent.Parent } } } return successor } //PreOrder å‰åºéå†äºŒå‰æ ‘ æ‰“å°åˆ°å±å¹• func (tree *BSTTREE) PreOrder() { a := tree.PreOrderToSlice() fmt.Print(\u0026quot;BSTTreePreOrder[\u0026quot;) for i := 0; i \u0026lt; len(a); i++ { fmt.Print(a[i].Key) if i == len(a)-1 { fmt.Print(\u0026quot;]\\n\u0026quot;) } else { fmt.Print(\u0026quot;,\u0026quot;) } } } //InOrder ä¸­åºéå†äºŒå‰æ ‘ æ‰“å°åˆ°å±å¹• func (tree *BSTTREE) InOrder() { a := tree.InOrderToSlice() fmt.Print(\u0026quot;BSTTreeInOrder[\u0026quot;) for i := 0; i \u0026lt; len(a); i++ { fmt.Print(a[i].Key) if i == len(a)-1 { fmt.Print(\u0026quot;]\\n\u0026quot;) } else { fmt.Print(\u0026quot;,\u0026quot;) } } } //PostOrder ååºéå†äºŒå‰æ ‘ æ‰“å°åˆ°å±å¹• func (tree *BSTTREE) PostOrder() { a := tree.PostOrderToSlice() fmt.Print(\u0026quot;BSTTreePostOrder[\u0026quot;) for i := 0; i \u0026lt; len(a); i++ { fmt.Print(a[i].Key) if i == len(a)-1 { fmt.Print(\u0026quot;]\\n\u0026quot;) } else { fmt.Print(\u0026quot;,\u0026quot;) } } } //PreOrderToSlice å‰åºéå†äºŒå‰æ ‘ æ ¹ã€å·¦å­æ ‘ã€å³å­æ ‘ è¿”å›ä¸€ä¸ªslice func (tree *BSTTREE) PreOrderToSlice() []*BSTNODE { if tree.Size == 0 { return nil } a := make([]*BSTNODE, tree.Size) myStack := stack.CreateEmptyStack() myStack.Push(tree.Root) //æ ¹èŠ‚ç‚¹å…ˆå‹æ ˆ for i := 0; myStack.IsEmpty() == false; { a[i] = myStack.Pop().(*BSTNODE) //å…ˆéå†æ ¹èŠ‚ç‚¹ if a[i].Right != nil { myStack.Push(a[i].Right) //å…ˆå‹å³å­æ ‘ } if a[i].Left != nil { myStack.Push(a[i].Left) //å†å‹å·¦å­æ ‘ } i++ } myStack.Clear() return a } //InOrderToSlice ä¸­åºéå†äºŒå‰æ ‘ å·¦å­æ ‘ã€æ ¹ã€å³å­æ ‘ è¿”å›ä¸€ä¸ªslice func (tree *BSTTREE) InOrderToSlice() []*BSTNODE { if tree.Size == 0 { return nil } a := make([]*BSTNODE, tree.Size, tree.Size) myStack := stack.CreateEmptyStack() //å…ˆå°†æ ¹èŠ‚ç‚¹åŠå…¶å·¦å­©å­ä¸€æ¡çº¿å…¨éƒ¨å…¥æ ˆ æ ˆé¡¶æœ€åå°±æ˜¯æœ€å·¦çš„èŠ‚ç‚¹ for p := tree.Root; p != nil; p = p.Left { myStack.Push(p) } for i := 0; myStack.IsEmpty() == false; { a[i] = myStack.Pop().(*BSTNODE) //æœ€å·¦è¾¹çš„èŠ‚ç‚¹ç›´æ¥å‡ºæ ˆ è€Œä¸”å…¶æ²¡æœ‰å·¦å­©å­ if i \u0026gt; 0 \u0026amp;\u0026amp; tree.less(a[i], a[i-1]) { panic(\u0026quot;äºŒå‰æŸ¥æ‰¾æ ‘ä¸æ­£ç¡®\u0026quot;) } for p := a[i].Right; p != nil; p = p.Left { //å°†å…¶å³å­©å­åŠå³å­©å­çš„å·¦å­©å­ä¸€æ¡çº¿ å…¨éƒ¨å…¥æ ˆ myStack.Push(p) } i++ } myStack.Clear() return a } //isChildAllVisited åˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹æ˜¯å¦éƒ½å·²ç»è®¿é—®è¿‡äº† func isChildAllVisited(p *BSTNODE, visit map[*BSTNODE]int) bool { if p == nil { panic(\u0026quot;in isChildAllVisited input *BSTNODE is nil\u0026quot;) } childCount := 0 if p.Left != nil { childCount++ } if p.Right != nil { childCount++ } if childCount == 0 { //å¦‚æœæ²¡æœ‰å­©å­ ç›´æ¥è¿”å›true return true } if childVisitCount, ok := visit[p]; ok { if childCount == childVisitCount { //æ‰€æœ‰å­©å­èŠ‚ç‚¹éƒ½å·²ç»è®¿é—®è¿‡äº† delete(visit, p) return true } return false } else { return false //å­©å­è¿˜æ²¡æœ‰è¢«è®¿é—®è¿‡ } } //PostOrderToSlice ååºéå†äºŒå‰æ ‘ å·¦å­æ ‘ã€å³å­æ ‘ã€æ ¹ è¿”å›ä¸€ä¸ªslice func (tree *BSTTREE) PostOrderToSlice() []*BSTNODE { if tree.Size == 0 { return nil } visit := make(map[*BSTNODE]int) //è®°å½•æŸä¸ªèŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹è®¿é—®æ¬¡æ•° a := make([]*BSTNODE, tree.Size) myStack := stack.CreateEmptyStack() myStack.Push(tree.Root) for i := 0; myStack.IsEmpty() == false; { p := myStack.Peek().(*BSTNODE) //å½“å‰èŠ‚ç‚¹å¯ä»¥ç†è§£ä¸ºæ ¹ if isChildAllVisited(p, visit) { //å¦‚æœå½“å‰æ ˆé¡¶èŠ‚ç‚¹å¯¹åº”çš„å­©å­éƒ½å·²ç»è®¿é—®è¿‡äº† é‚£å°±å‡ºæ ˆ a[i] = myStack.Pop().(*BSTNODE) //fmt.Println(\u0026quot;èŠ‚ç‚¹:\u0026quot;, a[i].Key, \u0026quot; å·¦å³å­©å­éƒ½å·²ç»è®¿é—®è¿‡äº† å·²ç»å‡ºæ ˆ å½“å‰æ•°ç»„ä¸‹æ ‡ä¸º:\u0026quot;, i) visit[a[i].Parent]++ i++ continue } if p.Right != nil { //å°†å³å­©å­å‹æ ˆ //fmt.Println(\u0026quot;å½“å‰æ ˆé¡¶æ˜¯:\u0026quot;, p.Key, \u0026quot; å·¦å³å­©å­å°šæœªè®¿é—®å®Œæˆ ä¸å‡ºæ ˆï¼Œå‹å…¥å³å­©å­:\u0026quot;, p.Right.Key) myStack.Push(p.Right) } if p.Left != nil { //å°†å·¦å­©å­å‹æ ˆ //fmt.Println(\u0026quot;å½“å‰æ ˆé¡¶æ˜¯:\u0026quot;, p.Key, \u0026quot; å·¦å³å­©å­å°šæœªè®¿é—®å®Œæˆ ä¸å‡ºæ ˆï¼Œå‹å…¥å·¦å­©å­:\u0026quot;, p.Left.Key) myStack.Push(p.Left) } } myStack.Clear() return a }  \nâ€‹ å…¶ä¸­ä¸­åºéå†æ·»åŠ äº†åˆ¤æ–­æ˜¯å¦é€’å¢ï¼Œå¦‚æœä¸æ˜¯é€’å¢ åˆ™ä¼šæŠ¥é”™\n åˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªBSTäºŒå‰æœç´¢æ ‘\n//ISBSTRET åˆ¤æ–­æ˜¯å¦æ˜¯BSTçš„è¿”å›å€¼ type ISBSTRET struct { isBST bool //æ˜¯å¦æ˜¯BST minValNode *BSTNODE //å½“å‰æ ‘çš„æœ€å°å€¼èŠ‚ç‚¹ maxValNode *BSTNODE //å½“å‰æ ‘çš„æœ€å¤§å€¼èŠ‚ç‚¹ } //ISBST åˆ¤æ–­å½“å‰æ ‘æ˜¯å¦ä¸ºBSTæ ‘ å¤–éƒ¨ä½¿ç”¨ func ISBST(node *BSTNODE, less Less) bool { ret := isAnBinarySearchTree(node, less) return ret.isBST } //isAnBinarySearchTree åˆ¤æ–­å½“å‰æ ‘æ˜¯å¦ä¸ºBSTæ ‘ å†…éƒ¨ä½¿ç”¨ func isAnBinarySearchTree(node *BSTNODE, less Less) ISBSTRET { if node == nil { return ISBSTRET{true, nil, nil} } retLeft, retRight := isAnBinarySearchTree(node.Left, less), isAnBinarySearchTree(node.Right, less) if retLeft.isBST \u0026amp;\u0026amp; retRight.isBST \u0026amp;\u0026amp; (retLeft.maxValNode == nil || less(retLeft.maxValNode.Key, node.Key)) \u0026amp;\u0026amp; (retRight.minValNode == nil || less(node.Key, retRight.minValNode.Key)) { ret := ISBSTRET{true, nil, nil} if retLeft.minValNode == nil { ret.minValNode = node } else { ret.minValNode = retLeft.minValNode //å½“å‰æ ‘çš„æœ€å°å€¼èŠ‚ç‚¹èµ‹å€¼ä¸ºå·¦å­æ ‘çš„æœ€å°å€¼ } if retRight.maxValNode == nil { ret.maxValNode = node } else { ret.maxValNode = retRight.maxValNode //å½“å‰æ ‘çš„æœ€å¤§å€¼èŠ‚ç‚¹èµ‹å€¼ä¸ºå³å­æ ‘çš„æœ€å¤§å€¼ } return ret } else { fmt.Println(\u0026quot;key=\u0026quot;, node.Key, \u0026quot; ä¸æ˜¯BST\u0026quot;) if retLeft.isBST == false { fmt.Println(\u0026quot;åŸå› :å…¶å·¦å­æ ‘ä¸æ˜¯BST\u0026quot;) } if retRight.isBST == false { fmt.Println(\u0026quot;åŸå› :å…¶å³å­æ ‘ä¸æ˜¯BST\u0026quot;) } if retLeft.maxValNode != nil \u0026amp;\u0026amp; less(retLeft.maxValNode.Key, node.Key) == false { fmt.Println(\u0026quot;åŸå› :å…¶å·¦å­æ ‘å­˜åœ¨æ¯”å…¶å¤§çš„èŠ‚ç‚¹:\u0026quot;, retLeft.maxValNode.Key) } if retRight.minValNode != nil \u0026amp;\u0026amp; less(node.Key, retRight.minValNode.Key) == false { fmt.Println(\u0026quot;åŸå› :å…¶å³å­æ ‘å­˜åœ¨æ¯”å…¶å°çš„èŠ‚ç‚¹:\u0026quot;, retRight.minValNode.Key) } return ISBSTRET{false, nil, nil} } }  \nAVLTree ä¸¥æ ¼å¹³è¡¡äºŒå‰æ ‘ ä»‹ç» â€‹ AVLæ ‘æ˜¯æ ¹æ®å®ƒçš„å‘æ˜è€…G.M. Adelson-Velskyå’ŒE.M. Landiså‘½åçš„ã€‚\nå®ƒæ˜¯æœ€å…ˆå‘æ˜çš„è‡ªå¹³è¡¡äºŒå‰æŸ¥æ‰¾æ ‘ï¼Œä¹Ÿè¢«ç§°ä¸ºé«˜åº¦å¹³è¡¡æ ‘ã€‚ç›¸æ¯”äº\u0026rdquo;äºŒå‰æŸ¥æ‰¾æ ‘\u0026rdquo;ï¼Œå®ƒçš„ç‰¹ç‚¹æ˜¯ï¼šAVLæ ‘ä¸­ä»»ä½•èŠ‚ç‚¹çš„ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦æœ€å¤§å·®åˆ«ä¸º1ã€‚\nä¸ºä»€ä¹ˆè¦æœ‰AVLæ ‘ï¼Œå› ä¸ºæ™®é€šçš„äºŒå‰æŸ¥æ‰¾æ ‘æœ‰å¯èƒ½å‡ºç°é•¿æ–œæ ‘çš„æƒ…å†µï¼Œæœ€å¿«çš„æƒ…å†µç›´æ¥æ˜¯ä¸€æ£µçº¿å½¢çš„æ ‘ï¼Œæ¯”å¦‚ä¾æ¬¡æ’å…¥54321ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™æŸ¥æ‰¾çš„æ€§èƒ½å¤§å¹…ä¸‹é™ï¼Œä¸èƒ½è¾¾åˆ°logN,è€Œä¸‹é™ä¸ºNï¼Œæ‰€ä»¥æ‰æœ‰äº†AVLï¼ŒAVLæŸ¥æ‰¾çš„æ€§èƒ½è¾¾åˆ°logNï¼Œå¤šä»˜å‡ºçš„ä»£ä»·æ˜¯æ’å…¥æˆ–è€…åˆ é™¤çš„æ—¶å€™è¦ç»´æŒå¹³è¡¡ï¼Œæ‰€ä»¥éœ€è¦æ—‹è½¬ã€‚\nå„ç§æ—‹è½¬ç¤ºæ„å›¾ LLæ—‹è½¬å®ç°é€»è¾‘ gä¸ºå¾…æ’å…¥èŠ‚ç‚¹(çº¢è‰²éƒ¨åˆ†)çš„çˆ·çˆ·èŠ‚ç‚¹ è¿™ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡æ€§å—åˆ°ç ´å på¾…æ’å…¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ŒåŒæ—¶æ˜¯çˆ·çˆ·èŠ‚ç‚¹çš„å·¦å­©å­\n//LLRotation LLæ—‹è½¬ æ—‹è½¬ä¸€æ¬¡å³å¯ func (tree *AvlTree) LLRotation(g *AvlTreeNode) { p := g.Left gOldParent := g.Parent pOldRight := p.Right g.Left = pOldRight p.Right = g //æ›´æ–°ç›¸å…³èŠ‚ç‚¹çš„Parentå±æ€§ å¦‚æœä¸æƒ³è¦Parentå±æ€§ åˆ™ä¸‹é¢Parentç›¸å…³ä»£ç å¯ä»¥åˆ é™¤ if pOldRight != nil { pOldRight.Parent = g } if g == tree.Root { //gä¸ºæ ¹èŠ‚ç‚¹ tree.Root = p } else { //géæ ¹èŠ‚ç‚¹ if g == gOldParent.Left { gOldParent.Left = p } else { gOldParent.Right = p } } p.Parent = gOldParent g.Parent = p //æ›´æ–°gå’Œpçš„é«˜åº¦ updateHeight(g) updateHeight(p) return p }  RRæ—‹è½¬å®ç°é€»è¾‘ gä¸ºå¾…æ’å…¥èŠ‚ç‚¹(çº¢è‰²éƒ¨åˆ†)çš„çˆ·çˆ·èŠ‚ç‚¹ è¿™ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡æ€§å—åˆ°ç ´å på¾…æ’å…¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ŒåŒæ—¶æ˜¯çˆ·çˆ·èŠ‚ç‚¹çš„å³è¾¹\n//RRRotation RRæ—‹è½¬ æ—‹è½¬ä¸€æ¬¡å³å¯ func (tree *AvlTree) RRRotation(g *AvlTreeNode) { p := g.Right //è°ƒæ•´èŠ‚ç‚¹å·¦å³å­©å­æŒ‡å‘ å®Œæˆæ—‹è½¬ gOldParent := g.Parent pOldLeft := p.Left g.Right = pOldLeft p.Left = g //æ›´æ–°ç›¸å…³èŠ‚ç‚¹çš„Parentå±æ€§ å¦‚æœä¸æƒ³è¦Parentå±æ€§ åˆ™ä¸‹é¢Parentç›¸å…³ä»£ç å¯ä»¥åˆ é™¤ if pOldLeft != nil { pOldLeft.Parent = g } if g == tree.Root { //gä¸ºæ ¹èŠ‚ç‚¹ tree.Root = p } else { //géæ ¹èŠ‚ç‚¹ if g == gOldParent.Left { gOldParent.Left = p } else { gOldParent.Right = p } } p.Parent = gOldParent g.Parent = p //æ›´æ–°gå’Œpçš„é«˜åº¦ updateHeight(g) updateHeight(p) return p }  LRæ—‹è½¬å®ç°é€»è¾‘ gä¸ºå¾…æ’å…¥èŠ‚ç‚¹(çº¢è‰²éƒ¨åˆ†)çš„çˆ·çˆ·èŠ‚ç‚¹ è¿™ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡æ€§å—åˆ°ç ´å på¾…æ’å…¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ŒåŒæ—¶æ˜¯çˆ·çˆ·èŠ‚ç‚¹çš„å·¦å­©å­\nè¿™ç§æƒ…å†µè¦ç»è¿‡2æ¬¡æ—‹è½¬ å…ˆå¯¹pèŠ‚ç‚¹RRæ—‹è½¬ å†å¯¹gèŠ‚ç‚¹LLæ—‹è½¬\n//LRRotation 2æ¬¡æ—‹è½¬ å…ˆå¯¹pèŠ‚ç‚¹RRæ—‹è½¬ å†å¯¹gèŠ‚ç‚¹LLæ—‹è½¬ func (tree *AvlTree) LRRotation(g *AvlTreeNode) { g.Left=tree.RRRotation(g.Left) return tree.LLRotation(g) }  RLæ—‹è½¬å®ç°é€»è¾‘ gä¸ºå¾…æ’å…¥èŠ‚ç‚¹(çº¢è‰²éƒ¨åˆ†)çš„çˆ·çˆ·èŠ‚ç‚¹ è¿™ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡æ€§å—åˆ°ç ´å på¾…æ’å…¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ŒåŒæ—¶æ˜¯çˆ·çˆ·èŠ‚ç‚¹çš„å³å­©å­\nè¿™ç§æƒ…å†µè¦ç»è¿‡2æ¬¡æ—‹è½¬ å…ˆå¯¹pèŠ‚ç‚¹LLæ—‹è½¬ å†å¯¹gèŠ‚ç‚¹RRæ—‹è½¬\n//RLRotation 2æ¬¡æ—‹è½¬ å…ˆå¯¹pèŠ‚ç‚¹LLæ—‹è½¬ å†å¯¹gèŠ‚ç‚¹RRæ—‹è½¬ func (tree *AvlTree) RLRotation(g *AvlTreeNode) { g.Right=tree.LLRotation(g.Right) return tree.RRRotation(g) }  æ’å…¥ä»£ç  â€‹ è¿™é‡Œå…ˆåƒBSTä¸€æ ·å…ˆæ’å…¥ï¼Œç„¶åé’ˆå¯¹æ’å…¥çš„èŠ‚ç‚¹å°±è¡Œå¹³è¡¡æ€§æ£€æŸ¥å’Œè°ƒæ•´ å…³é”®å°±æ˜¯rebalanceå‡½æ•°\n AvlTreeæ’å…¥ä»£ç \n//Insert æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ è¿”å›æ’å…¥èŠ‚ç‚¹çš„åœ°å€ func (tree *AvlTree) Insert(Key interface{}) *AvlTreeNode { newNode := tree.insertAsBST(Key) //å…ˆåƒBSTæ ‘ä¸€æ ·æ’å…¥ ç„¶åç½‘ä¸Šé€ä¸ªåˆ¤æ–­æ˜¯å¦æ‰“ç ´å¹³è¡¡å› å­ åšé€‚å½“è°ƒæ•´ if newNode != nil { tree.rebalance(newNode) //è°ƒæ•´å¹³è¡¡æ€§ } return newNode } //rebalance é’ˆå¯¹ä¸€ä¸ªèŠ‚ç‚¹ä»¥åŠæ‰€æœ‰çˆ¶è¾ˆèŠ‚ç‚¹è¿›è¡Œå¹³è¡¡æ€§åˆ¤æ–­ä¸è°ƒæ•´ func (tree *AvlTree) rebalance(node *AvlTreeNode) { for node != nil { hLeft, hRight := Height(node.Left), Height(node.Right) if hLeft-hRight == 2 { //å·¦å­æ ‘æ¯”å³å­æ ‘é«˜ å¯èƒ½æ˜¯LLæˆ–è€…LR if node.Left.Left != nil { // fmt.Println(\u0026quot;èŠ‚ç‚¹\u0026quot;, node.Key, \u0026quot;LLæ—‹è½¬\u0026quot;) tree.LLRotation(node) //LL break } else { // fmt.Println(\u0026quot;èŠ‚ç‚¹\u0026quot;, node.Key, \u0026quot;LRæ—‹è½¬\u0026quot;) tree.LRRotation(node) //LR break } } else if hLeft-hRight == -2 { if node.Right.Right != nil { // fmt.Println(\u0026quot;èŠ‚ç‚¹\u0026quot;, node.Key, \u0026quot;RRæ—‹è½¬\u0026quot;) tree.RRRotation(node) //RR break } else { // fmt.Println(\u0026quot;èŠ‚ç‚¹\u0026quot;, node.Key, \u0026quot;RLæ—‹è½¬\u0026quot;) tree.RLRotation(node) //RL break } } else { // fmt.Println(node.Key, \u0026quot;æ²¡æœ‰æ‰“ç ´å¹³è¡¡\u0026quot;) updateHeight(node) //æ²¡æœ‰æ‰“ç ´å¹³è¡¡ä¹Ÿè¦æ›´æ–°å…¶é«˜åº¦ } node = node.Parent //é€å±‚å¾€ä¸Šå¯¹æ¯ä¸ªçˆ¶è¾ˆèŠ‚ç‚¹éƒ½åšåˆ¤æ–­è°ƒæ•´å¤„ç† } } func updateHeight(node *AvlTreeNode) { if node == nil { return } hleft, hright := Height(node.Left), Height(node.Right) node.Height = Max(hleft, hright) + 1 }  \nåˆ é™¤ä»£ç  è¿™é‡Œä¹Ÿæ˜¯å…ˆåƒBSTä¸€æ ·åˆ é™¤ï¼Œåªä¸è¿‡è¦è¿”å›åˆ é™¤åéœ€è¦é‡æ–°è°ƒæ•´çš„èŠ‚ç‚¹èµ·å§‹ä½ç½®(å…¶çˆ¶è¾ˆèŠ‚ç‚¹ å…¨éƒ¨é«˜åº¦éƒ½è¦å˜æ›´ï¼ŒåŒæ—¶åšå¹³è¡¡æ€§æ£€æŸ¥å’Œæ—‹è½¬)\nç”¨åˆ°çš„rebalanceå‡½æ•°ä¸ªæ’å…¥ç”¨åˆ°çš„å‡½æ•°ä¸€æ ·\n AvlTreeåˆ é™¤ä»£ç \n//DeleteByKey åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ æ ¹æ®ä¼ å…¥çš„èŠ‚ç‚¹å€¼åˆ é™¤ è¿”å›æ˜¯å¦åˆ é™¤æˆåŠŸ func (tree *AvlTree) DeleteByKey(Key interface{}) bool { var delNode *AvlTreeNode = tree.SearchKey(Key) if delNode != nil { node := tree.deleteByNodeAsBST(delNode) //è¿™é‡Œnodeä¸ºéœ€è¦é‡æ–°è°ƒæ•´é«˜åº¦çš„èµ·å§‹èŠ‚ç‚¹ å…¶çˆ¶è¾ˆéƒ½è¦è°ƒæ•´ tree.recomputeHeight(node) tree.rebalance(node) return true } return false } //deleteByNodeAsBST åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ æ ¹æ®ä¼ å…¥çš„èŠ‚ç‚¹åœ°å€åˆ é™¤ è¿”å›åˆ é™¤åéœ€è¦è°ƒæ•´é«˜åº¦çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ å…¶çˆ¶è¾ˆèŠ‚ç‚¹éƒ½è¦æ›´æ–°é«˜åº¦ func (tree *AvlTree) deleteByNodeAsBST(delNode *AvlTreeNode) *AvlTreeNode { if delNode != nil { var retNode *AvlTreeNode = nil if delNode.Left == nil { //å¦‚æœå…¶å·¦å­æ ‘ä¸ºç©º åˆ™ç”¨å…¶å³å­©å­æ›¿æ¢è¢«åˆ é™¤èŠ‚ç‚¹å³å¯ å½“ç„¶å¦‚æœå³å­©å­æ˜¯ç©º ä¹Ÿå°±æ˜¯çº¯å¶å­èŠ‚ç‚¹ ç›´æ¥åˆ é™¤å³å¯ // fmt.Println(\u0026quot;åˆ é™¤èŠ‚ç‚¹å·¦å­æ ‘ä¸ºç©º\u0026quot;) tree.replaceNode(delNode, delNode.Right) //è¿™ç§æƒ…å†µ è¢«åˆ é™¤èŠ‚ç‚¹çˆ¶è¾ˆèŠ‚ç‚¹éƒ½è¦è°ƒæ•´é«˜åº¦ retNode = delNode.Parent } else if delNode.Right == nil { //å¦‚æœå…¶å³å­æ ‘ä¸ºç©º åˆ™ç”¨å…¶å·¦å­©å­æ›¿æ¢è¢«åˆ é™¤èŠ‚ç‚¹å³å¯ // fmt.Println(\u0026quot;åˆ é™¤èŠ‚ç‚¹å³å­æ ‘ä¸ºç©º\u0026quot;) tree.replaceNode(delNode, delNode.Left) //è¿™ç§æƒ…å†µ è¢«åˆ é™¤èŠ‚ç‚¹çˆ¶è¾ˆèŠ‚ç‚¹éƒ½è¦è°ƒæ•´é«˜åº¦ retNode = delNode.Parent } else { // fmt.Println(\u0026quot;åˆ é™¤èŠ‚ç‚¹å·¦å³å­æ ‘éƒ½éç©º\u0026quot;) //å·¦å³å­æ ‘éƒ½éç©º è¿™ä¸ªæ—¶å€™å°±æ‰¾åˆ°å…¶åç»§èŠ‚ç‚¹ ç„¶åæ›¿æ¢ succssor := tree.GetSuccessor(delNode) retNode = succssor.Parent //å› ä¸ºåç»§èŠ‚ç‚¹å‘ç”Ÿå˜åŒ– if succssor.Parent != delNode { //åç»§èŠ‚ç‚¹ä¸æ˜¯å…¶å³å­©å­(å…¶å³å­©å­è¿˜æœ‰å·¦å­æ ‘) // fmt.Println(\u0026quot;åç»§èŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹ä¸æ˜¯åˆ é™¤èŠ‚ç‚¹\u0026quot;) //æ‹¿åç»§èŠ‚ç‚¹å³å­©å­æ›¿æ¢åç»§èŠ‚ç‚¹ ä¹Ÿå°±æ˜¯åç»§èŠ‚ç‚¹çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ å˜ä¸ºåç»§èŠ‚ç‚¹çš„å³å­©å­ tree.replaceNode(succssor, succssor.Right) succssor.Right = delNode.Right //æ›´æ–°åç»§èŠ‚ç‚¹çš„å³å­©å­ æŒ‡å‘è¢«åˆ é™¤èŠ‚ç‚¹çš„å³å­©å­ delNode.Right.Parent = succssor //åŒæ—¶æ›´æ–°è¢«åˆ é™¤èŠ‚ç‚¹å³å­©å­çš„çš„Parentå±æ€§ } tree.replaceNode(delNode, succssor) //æ‹¿åç»§èŠ‚ç‚¹æ›¿æ¢è¢«åˆ é™¤èŠ‚ç‚¹ succssor.Left = delNode.Left //åç»§èŠ‚ç‚¹çš„å·¦å­©å­ æŒ‡å‘è¢«åˆ é™¤èŠ‚ç‚¹çš„å·¦å­©å­ delNode.Left.Parent = succssor //åŒæ—¶æ›´æ–°è¢«åˆ é™¤èŠ‚ç‚¹å·¦å­©å­çš„Parentå±æ€§ } tree.Size-- delNode.Parent, delNode.Left, delNode.Right = nil, nil, nil //ç­‰å¾…gcå›æ”¶ return retNode } return nil } //recomputeHeight èŠ‚ç‚¹å’Œå…¶çˆ¶è¾ˆèŠ‚ç‚¹å…¨éƒ¨é‡æ–°è®¡ç®—é«˜åº¦ func (tree *AvlTree) recomputeHeight(node *AvlTreeNode) { for node != nil { node.Height = Max(Height(node.Left), Height(node.Right)) + 1 node = node.Parent } }  \n åˆ¤æ–­ä¸€ä¸ªæ ‘æ˜¯å¦ä¸ºAVL\n//ISAVL åˆ¤æ–­å½“å‰æ ‘æ˜¯å¦ä¸ºAVLæ ‘ å¤–éƒ¨ä½¿ç”¨ func ISAVL(node *AvlTreeNode, less Less) bool { ret := isAnAvlTree(node, less) return ret.isAVL } //isAnAvlTree åˆ¤æ–­å½“å‰æ ‘æ˜¯å¦ä¸ºBSTæ ‘ å†…éƒ¨ä½¿ç”¨ func isAnAvlTree(node *AvlTreeNode, less Less) ISAVLRET { if node == nil { return ISAVLRET{true, nil, nil, 0} } retLeft, retRight := isAnAvlTree(node.Left, less), isAnAvlTree(node.Right, less) if retLeft.isAVL \u0026amp;\u0026amp; retRight.isAVL \u0026amp;\u0026amp; (retLeft.maxValNode == nil || less(retLeft.maxValNode.Key, node.Key)) \u0026amp;\u0026amp; (retRight.minValNode == nil || less(node.Key, retRight.minValNode.Key)) \u0026amp;\u0026amp; ABS(retLeft.height-retRight.height) \u0026lt;= 1 { ret := ISAVLRET{true, nil, nil, Max(retLeft.height, retRight.height) + 1} if retLeft.minValNode == nil { ret.minValNode = node } else { ret.minValNode = retLeft.minValNode //å½“å‰æ ‘çš„æœ€å°å€¼èŠ‚ç‚¹èµ‹å€¼ä¸ºå·¦å­æ ‘çš„æœ€å°å€¼ } if retRight.maxValNode == nil { ret.maxValNode = node } else { ret.maxValNode = retRight.maxValNode //å½“å‰æ ‘çš„æœ€å¤§å€¼èŠ‚ç‚¹èµ‹å€¼ä¸ºå³å­æ ‘çš„æœ€å¤§å€¼ } return ret } else { fmt.Println(\u0026quot;key=\u0026quot;, node.Key, \u0026quot; ä¸æ˜¯AVL\u0026quot;) if retLeft.isAVL == false { fmt.Println(\u0026quot;åŸå› :å…¶å·¦å­æ ‘ä¸æ˜¯AVL\u0026quot;) } if retRight.isAVL == false { fmt.Println(\u0026quot;åŸå› :å…¶å³å­æ ‘ä¸æ˜¯AVL\u0026quot;) } if retLeft.maxValNode != nil \u0026amp;\u0026amp; less(retLeft.maxValNode.Key, node.Key) == false { fmt.Println(\u0026quot;åŸå› :ä¸æ˜¯BST å…¶å·¦å­æ ‘å­˜åœ¨æ¯”å…¶å¤§çš„èŠ‚ç‚¹:\u0026quot;, retLeft.maxValNode.Key) } if retRight.minValNode != nil \u0026amp;\u0026amp; less(node.Key, retRight.minValNode.Key) == false { fmt.Println(\u0026quot;åŸå› :ä¸æ˜¯BST å…¶å³å­æ ‘å­˜åœ¨æ¯”å…¶å°çš„èŠ‚ç‚¹:\u0026quot;, retRight.minValNode.Key) } if ABS(retLeft.height-retRight.height) \u0026gt; 1 { fmt.Println(\u0026quot;åŸå› å·¦å³å­æ ‘é«˜åº¦å·®å¤§äº1,å·¦å­æ ‘é«˜åº¦:\u0026quot;, retLeft.height, \u0026quot; å³å­æ ‘é«˜åº¦:\u0026quot;, retRight.height) } return ISAVLRET{false, nil, nil, Max(retLeft.height, retRight.height) + 1} } }  \nRedBalckTreeçº¢é»‘æ ‘ ä»‹ç» çº¢é»‘æ ‘ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œä¹Ÿæ˜¯ä¸ºäº†é«˜é€ŸæŸ¥æ‰¾æ‰å‘æ˜çš„ï¼Œä¹Ÿæ˜¯ä¸ºäº†é¿å…å‡ºç°äºŒå‰æœç´¢æ ‘çš„çº¿å½¢æƒ…å†µï¼Œæ‰€ä»¥æƒ³ç‚¹åŠæ³•è®©æ ‘å°½é‡å¹³è¡¡ï¼Œä½†åˆä¸åƒAVLæ ‘é‚£æ ·ä¸¥æ ¼å¹³è¡¡ï¼Œå› ä¸ºå¦‚æœè¦ä¸¥æ ¼å¹³è¡¡ï¼Œåˆ™æ„å‘³ç€å¾ˆæœ‰å¯èƒ½éšæ—¶éšåœ°éƒ½è¦è°ƒæ•´æ ‘ï¼Œè¦ä¸æ–­çš„æ—‹è½¬ï¼Œè¿™æ ·ä¹Ÿä¼šæµªè´¹æ€§èƒ½ï¼Œçº¢é»‘æ ‘æ˜¯ä¸€ç§ç›¸å¯¹å¹³è¡¡çš„äºŒå‰æŸ¥æ‰¾æ ‘ï¼Œæœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š\n æ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯çº¢è‰²æˆ–è€…é»‘è‰² æ ¹èŠ‚ç‚¹ä¸ºé»‘è‰² æ‰€æœ‰çš„ NULL å¶å­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰² å¦‚æœè¯¥èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä¸€å®šéƒ½æ˜¯é»‘è‰² æ‰€æœ‰çš„ NULL èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šçš„é»‘è‰²èŠ‚ç‚¹æ•°é‡ä¸€å®šæ˜¯ç›¸åŒçš„  çº¢é»‘æ ‘ä¿è¯äº†æœ€é•¿è·¯å¾„é•¿åº¦ä¸ä¼šæ˜¯æœ€çŸ­è·¯å¾„é•¿åº¦çš„2å€ æ˜¯ä¸€ç§ç›¸å¯¹å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘\næ’å…¥ â€‹ æ’å…¥ç›¸å¯¹äºåˆ é™¤è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ ï¼Œè¿˜æ˜¯é¦–å…ˆåƒBSTä¸€æ ·æ’å…¥ï¼Œç„¶åä»æ’å…¥èŠ‚ç‚¹(ä¸‹é¢ä»£ç è®°ä¸ºx)å¼€å§‹åšå˜è‰²å’Œæ—‹è½¬å¤„ç†ï¼Œå¤§å€¼çš„é€»è¾‘å¦‚ä¸‹ï¼š\n1 x.Color=Red //æ–°æ’å…¥æ˜¯çº¢è‰²ä¼šè¾ƒå¤§æ¦‚ç‡ä¸ç ´åçº¢é»‘æ ‘çš„ç‰¹æ€§ 2 while( x.Parent.Color==Red){//å¦‚æœå…¶çˆ¶äº²èŠ‚ç‚¹æ˜¯é»‘è‰²èŠ‚ç‚¹ ä¸ä¼šç ´åçº¢é»‘æ ‘çš„æ€§è´¨ ä¹‹ç„¶ä»€ä¹ˆéƒ½ä¸ç”¨åš ç›´æ¥æ’å…¥å³å¯ p,g,u:=x.Parent,x.Parent.Parent,getUncle(x) if getColor(u)==Red{// UncleRed_case p.Color,u.Color,g.Color=Balck,Black,Red//çˆ¶èŠ‚ç‚¹ å”å”èŠ‚ç‚¹å˜é»‘è‰² çˆ·çˆ·èŠ‚ç‚¹å˜çº¢è‰² x=g//xå˜ä¸ºå…¶çˆ·çˆ·èŠ‚ç‚¹ ç»§ç»­åˆ¤æ–­ }else{//å”å”èŠ‚ç‚¹ä¸ºç©ºä¹Ÿæ˜¯é»‘è‰² if p==g.Left \u0026amp;\u0026amp; x==p.Left{//UncleBlack_LeftLeft_case p.Color,g.Color=Black,Red LLRotation(g) }else if p==g.Left \u0026amp;\u0026amp; x==p.Right{//UncleBlack_LeftRight_case RRRotation(p)//æ—‹è½¬å x,päº²å­å…³ç³»è°ƒæ¢ å°†pçœ‹ä½œæ–°æ’å…¥èŠ‚ç‚¹ xæ˜¯å…¶çˆ¶äº² åˆèœ•å˜æˆä¸º Uncle Black LeftLeft case ä»£ç æœ‰äº›è®¸é‡å¤ä½†é€»è¾‘æ›´æ¸…æ™° x,p=p,x p.Color,g.Color=Black,Red LLRotation(g) }else if p==g.Right \u0026amp;\u0026amp; x=p.Right{ //UncleBlack_RightRight_case p.Color,g.Color=Black,Red RRRotation(g) }else if p==g.Right \u0026amp;\u0026amp; x==p.Left{UncleBlack_RightLeft_case LLRotation(p)//æ—‹è½¬å x,päº²å­å…³ç³»è°ƒæ¢ å°†pçœ‹ä½œæ–°æ’å…¥èŠ‚ç‚¹ xæ˜¯å…¶çˆ¶äº² åˆèœ•å˜æˆä¸º Uncle Black RightRight case ä»£ç æœ‰äº›è®¸é‡å¤ä½†é€»è¾‘æ›´æ¸…æ™° x,p=p,x p.Color,g.Color=Black,Red LLRotation(g) } } } 3 Root.Color=Black//å°†æ ‘çš„æ ¹èŠ‚ç‚¹æŸ“ä¸ºé»‘è‰²  æ’å…¥ä»£ç   çº¢é»‘æ ‘æ’å…¥ä»£ç \n//Insert æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ è¿”å›æ’å…¥èŠ‚ç‚¹çš„åœ°å€ func (tree *RBTree) Insert(Key interface{}) *RBTreeNode { newNode := tree.insertAsBST(Key) //å…ˆåƒBSTæ ‘ä¸€æ ·æ’å…¥ if newNode != nil { tree.insertFixUp(newNode) //æ’å…¥èŠ‚ç‚¹åè°ƒæ•´ } return newNode } //insertFixUp æ’å…¥èŠ‚ç‚¹åè¿›è¡Œé¢œè‰²è°ƒæ•´åŠæ—‹è½¬ç›¸å…³å¤„ç† func (tree *RBTree) insertFixUp(node *RBTreeNode) { // fmt.Println(\u0026quot;insertFixUp å½“å‰æ’å…¥èŠ‚ç‚¹ä¸º:\u0026quot;, node.Key, \u0026quot;Color:\u0026quot;, node.Color) for node != tree.Root \u0026amp;\u0026amp; node.Parent.Color == Red { //å¦‚æœå…¶çˆ¶äº²èŠ‚ç‚¹æ˜¯é»‘è‰²èŠ‚ç‚¹ ä¸ä¼šç ´åçº¢é»‘æ ‘çš„æ€§è´¨ ä¹‹ç„¶ä»€ä¹ˆéƒ½ä¸ç”¨åš ç›´æ¥æ’å…¥å³å¯ p, g, u := node.Parent, node.Parent.Parent, getUncle(node) if getColor(u) == Red { // UncleRed_case p.Color, u.Color, g.Color = Black, Black, Red //çˆ¶èŠ‚ç‚¹ å”å”èŠ‚ç‚¹å˜é»‘è‰² çˆ·çˆ·èŠ‚ç‚¹å˜çº¢è‰² node = g //xå˜ä¸ºå…¶çˆ·çˆ·èŠ‚ç‚¹ ç»§ç»­åˆ¤æ–­ } else { //å”å”èŠ‚ç‚¹ä¸ºç©ºä¹Ÿæ˜¯é»‘è‰² if p == g.Left \u0026amp;\u0026amp; node == p.Left { //UncleBlack_LeftLeft_case p.Color, g.Color = Black, Red tree.LLRotation(g) } else if p == g.Left \u0026amp;\u0026amp; node == p.Right { //UncleBlack_LeftRight_case tree.RRRotation(p) //æ—‹è½¬å x,päº²å­å…³ç³»è°ƒæ¢ å°†pçœ‹ä½œæ–°æ’å…¥èŠ‚ç‚¹ xæ˜¯å…¶çˆ¶äº² åˆèœ•å˜æˆä¸º Uncle Black LeftLeft case ä»£ç æœ‰äº›è®¸é‡å¤ä½†é€»è¾‘æ›´æ¸…æ™° node, p = p, node p.Color, g.Color = Black, Red tree.LLRotation(g) } else if p == g.Right \u0026amp;\u0026amp; node == p.Right { //UncleBlack_RightRight_case p.Color, g.Color = Black, Red tree.RRRotation(g) } else if p == g.Right \u0026amp;\u0026amp; node == p.Left { //UncleBlack_RightLeft_case tree.LLRotation(p) //æ—‹è½¬å x,päº²å­å…³ç³»è°ƒæ¢ å°†pçœ‹ä½œæ–°æ’å…¥èŠ‚ç‚¹ xæ˜¯å…¶çˆ¶äº² åˆèœ•å˜æˆä¸º Uncle Black RightRight case ä»£ç æœ‰äº›è®¸é‡å¤ä½†é€»è¾‘æ›´æ¸…æ™° node, p = p, node p.Color, g.Color = Black, Red tree.RRRotation(g) } } } if tree.Root == node { //å¦‚æœæ’å…¥æˆ–è€…è°ƒæ•´åå½“å‰èŠ‚ç‚¹æ˜¯æ ¹èŠ‚ç‚¹ åˆ™å°†å…¶ç½®ä¸ºé»‘è‰² node.Color = Black } }  \nåˆ é™¤ â€‹ åˆ é™¤æ ¹æ’å…¥æ¯”è¾ƒç›¸å¯¹å¤æ‚ï¼Œä½†æ— éä¹Ÿæ˜¯ç©·ä¸¾çš„è¿‡ç¨‹\nåˆ é™¤çš„èŠ‚ç‚¹åªèƒ½å­˜åœ¨ä¸‰ç§æƒ…å†µï¼š caseA:è¢«åˆ é™¤èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹(å¦‚å›¾ä¸­çš„1,3,5,7,9){ A1:å¦‚æœå¶å­èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼Œç›´æ¥åˆ é™¤å³å¯ï¼Œæ— éœ€ä¿®å¤ ä¸ä¼šç ´åçº¢é»‘æ ‘ç‰¹æ€§ A2:å¦‚æœå¶å­èŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œåˆ é™¤åä¼šç ´åç‰¹æ€§5 éœ€è¦ä¿®å¤ } caseB:è¢«åˆ é™¤èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­©å­(å¦‚å›¾ä¸­çš„10){ pä¸ºè¢«åˆ é™¤èŠ‚ç‚¹ parent,cä¸ºå…¶å­©å­èŠ‚ç‚¹ child B1:pä¸ºé»‘è‰²,cä¸ºçº¢è‰² {//å¦‚å›¾ä¸­çš„10å’Œ9 åˆ é™¤10èŠ‚ç‚¹ äº¤æ¢på’Œcçš„å€¼ï¼Œç„¶åå°†åˆ é™¤èŠ‚ç‚¹æ”¹ä¸ºc,å› ä¸ºæ˜¯çº¢è‰²ï¼Œå˜æˆäº†A1ï¼Œç›´æ¥åˆ é™¤å³å¯ï¼Œä¸è®ºå­©å­æ˜¯å·¦å­©å­è¿˜æ˜¯å³å­©å­éƒ½æ˜¯ä¸€æ ·çš„ } B2:pä¸ºé»‘è‰²,cä¸ºé»‘è‰²{ äº¤æ¢på’Œcçš„å€¼ï¼Œç„¶åå°†åˆ é™¤èŠ‚ç‚¹æ”¹ä¸ºc,ä¹Ÿå°±å˜æˆäº†A2çš„æƒ…å†µ } } caseC:è¢«åˆ é™¤èŠ‚ç‚¹æœ‰2ä¸ªå­©å­{//å¦‚å›¾ä¸­çš„2,4,6,8 æ‰¾åˆ°è¢«åˆ é™¤èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹ï¼Œç„¶åäº¤æ¢è¢«åˆ é™¤èŠ‚ç‚¹å’Œå…¶åç»§èŠ‚ç‚¹çš„å€¼ ç„¶åå°†åˆ é™¤èŠ‚ç‚¹æ”¹ä¸ºå…¶åç»§èŠ‚ç‚¹(è¦ä¹ˆæ˜¯å¶å­èŠ‚ç‚¹ å¯¹åº”caseA,è¦ä¹ˆæ˜¯åªæœ‰å³å­©å­ å¯¹åº”caseB) } ç»¼åˆä¸Šé¢çš„æƒ…å†µ caseCå¯ä»¥è½¬åŒ–ä¸ºcaseB,caseBåˆå¯ä»¥è½¬ä¸ºä¸ºcaseA A1æƒ…å†µå¯ä»¥ç›´æ¥åˆ é™¤ï¼Œæ‰€ä»¥åªæœ‰A2éœ€è¦é‡ç‚¹å…³æ³¨ï¼Œå½“ç„¶ä¹Ÿæ˜¯æœ€å¤æ‚çš„ã€‚å¾ˆå¤šç©·ä¸¾æƒ…å†µï¼Œä¸Šç½‘æ‰¾äº†ä¸€å¼ å›¾åº”è¯¥æ˜¯æ¯”è¾ƒå…¨é¢çš„ï¼Œä¹Ÿæ¯”è¾ƒå¥½ç†è§£ï¼Œå¤šçœ‹å‡ éå°±è®°ä½äº†ã€‚  åˆ é™¤ä»£ç   çº¢é»‘æ ‘åˆ é™¤æ ¸å¿ƒä»£ç \n//DeleteByKey åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ æ ¹æ®ä¼ å…¥çš„èŠ‚ç‚¹å€¼åˆ é™¤ è¿”å›æ˜¯å¦åˆ é™¤æˆåŠŸ func (tree *RBTree) DeleteByKey(Key interface{}) bool { var delNode *RBTreeNode = tree.SearchKey(Key) //å…ˆæ‰¾åˆ°è¢«åˆ é™¤çš„èŠ‚ç‚¹ if delNode != nil { if delNode.Left == nil \u0026amp;\u0026amp; delNode.Right == nil { //caseA:è¢«åˆ é™¤èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ return tree.delLeafNode(delNode) } else if delNode.Right == nil || delNode.Left == nil { //caseB:è¢«åˆ é™¤èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­©å­ return tree.delNodeHasOneChild(delNode) } else { //caseC:è¢«åˆ é™¤èŠ‚ç‚¹æœ‰2ä¸ªå­©å­ return tree.delNodeTwoOneChild(delNode) } } return false } //delLeafNode åˆ é™¤å¶å­èŠ‚ç‚¹ å¯¹åº”åˆ é™¤çš„caseA:è¢«åˆ é™¤èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ func (tree *RBTree) delLeafNode(delNode *RBTreeNode) bool { if delNode.Color == Red { //A1:å¦‚æœå¶å­èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼Œç›´æ¥åˆ é™¤å³å¯ï¼Œæ— éœ€ä¿®å¤ ä¸ä¼šç ´åçº¢é»‘æ ‘ç‰¹æ€§ p := delNode.Parent //è‚¯å®šæœ‰çˆ¶èŠ‚ç‚¹ å› ä¸ºåªæœ‰æ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹ ä½†æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰² if delNode == p.Left { p.Left = nil } else { p.Right = nil } tree.Size-- } else { //A2:å¦‚æœå¶å­èŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œåˆ é™¤åä¼šç ´åç‰¹æ€§5 éœ€è¦ä¿®å¤ tree.delBlackLeafFixUp(delNode) } return true } //delNodeHasOneChild åˆ é™¤åªæœ‰ä¸€ä¸ªå­©å­èŠ‚ç‚¹çš„æƒ…å†µ å¯¹åº”caseB:è¢«åˆ é™¤èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­©å­ func (tree *RBTree) delNodeHasOneChild(delNode *RBTreeNode) bool { c := delNode.Left //cæŒ‡å‘å…¶å­©å­èŠ‚ç‚¹ if c == nil { c = delNode.Right } if delNode.Color == Black \u0026amp;\u0026amp; c.Color == Red { //B1:pä¸ºé»‘è‰²,cä¸ºçº¢è‰² äº¤æ¢på’Œcçš„å€¼ï¼Œç„¶åå°†åˆ é™¤èŠ‚ç‚¹æ”¹ä¸ºc,å› ä¸ºæ˜¯çº¢è‰²ï¼Œå˜æˆäº†A1ï¼Œç›´æ¥åˆ é™¤å³å¯ delNode.Key, c.Key = c.Key, delNode.Key delNode.Left, delNode.Right = nil, nil //åˆ é™¤å…¶å­©å­èŠ‚ç‚¹ c.Left, c.Right, c.Parent = nil, nil, nil } else if c.Color == Black { //B2:pä¸ºé»‘è‰²æˆ–è€…çº¢è‰²,cä¸ºé»‘è‰² äº¤æ¢på’Œcçš„å€¼ï¼Œç„¶åå°†åˆ é™¤èŠ‚ç‚¹æ”¹ä¸ºc,ä¹Ÿå°±å˜æˆäº†A2çš„æƒ…å†µ delNode.Key, c.Key = c.Key, delNode.Key tree.delBlackLeafFixUp(c) } tree.Size-- return true } //delNodeTwoOneChild åˆ é™¤èŠ‚ç‚¹æœ‰2ä¸ªå­©å­çš„æƒ…å†µ å¯¹åº”caseC:è¢«åˆ é™¤èŠ‚ç‚¹æœ‰2ä¸ªå­©å­ func (tree *RBTree) delNodeTwoOneChild(delNode *RBTreeNode) bool { //æ‰¾åˆ°è¢«åˆ é™¤èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹ï¼Œç„¶åäº¤æ¢è¢«åˆ é™¤èŠ‚ç‚¹å’Œå…¶åç»§èŠ‚ç‚¹çš„å€¼ ç„¶åå°†åˆ é™¤èŠ‚ç‚¹æ”¹ä¸ºå…¶åç»§èŠ‚ç‚¹(è¦ä¹ˆæ˜¯å¶å­èŠ‚ç‚¹ å¯¹åº”caseA,è¦ä¹ˆæ˜¯åªæœ‰å³å­©å­ å¯¹åº”caseB) successor := tree.GetSuccessor(delNode) delNode.Key, successor.Key = successor.Key, delNode.Key if successor.Right != nil { //åç»§èŠ‚ç‚¹å³å­©å­ä¸ä¸ºç©º å·¦å­©å­è‚¯å®šä¸ºç©º èœ•å˜ä¸ºcaseB return tree.delNodeHasOneChild(successor) } //åç»§èŠ‚ç‚¹ä¸ºå¶å­èŠ‚ç‚¹ èœ•å˜ä¸ºcaseA return tree.delLeafNode(successor) } //åˆ é™¤é»‘è‰²å¶å­èŠ‚ç‚¹å¹¶è°ƒæ•´ è¿”å›åˆ é™¤èŠ‚ç‚¹çš„ä½ç½® func (tree *RBTree) delBlackLeafFixUp(delNode *RBTreeNode) { oldDeleteNode := delNode //è®°å½•ä¼ å…¥çš„èŠ‚ç‚¹ å› ä¸ºcase4ä¼šæ”¹å˜å…¶å€¼ ç­‰è°ƒæ•´å®Œæ¯• å†å°†å…¶çˆ¶èŠ‚ç‚¹æŒ‡å‘å®ƒçš„æŒ‡é’ˆæ”¹ä¸ºnil äº¤ç»™gcå›æ”¶ tree.Size-- if delNode == tree.Root { //å¦‚æœè¢«åˆ é™¤èŠ‚ç‚¹æ˜¯rootèŠ‚ç‚¹ è€Œä¸”æ˜¯å¶å­èŠ‚ç‚¹ è¯´æ˜æ•´ä¸ªæ ‘åªå‰©ä¸‹1ä¸ªrootèŠ‚ç‚¹äº† ç›´æ¥åˆ é™¤å³å¯ tree.Root = nil } else { for delNode != tree.Root \u0026amp;\u0026amp; delNode.Color == Black { p, b := delNode.Parent, getBrother(delNode) if delNode == p.Left { //å½“å‰èŠ‚ç‚¹æ˜¯å·¦èŠ‚ç‚¹ if b.Color == Red { //case5 : å¦‚æœè¯¥å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼Œé‚£ä¹ˆæ ¹æ®çº¢é»‘æ ‘çš„ç‰¹æ€§å¯ä»¥å¾—å‡ºå®ƒçš„ä¸€å®šæœ‰ä¸¤ä¸ªé»‘è‰²çš„å­èŠ‚ç‚¹ b.Color, p.Color = Black, Red tree.RRRotation(p) } else { if b.Right != nil \u0026amp;\u0026amp; b.Right.Color == Red { //case1å’Œcase3 //å¯¹åº”case1 : å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„ï¼Œä¸”æœ‰ä¸€ä¸ªå³èŠ‚ç‚¹ï¼ˆå¯ä»¥æ–­å®š å³èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ //ä¹Ÿå¯¹åº”case3 : å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„ï¼Œä¸”æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼ˆå¯ä»¥æ–­å®š å·¦å³èŠ‚ç‚¹éƒ½æ˜¯çº¢è‰²çš„ï¼‰è¿™ä¸¤ç§æƒ…å†µä¸€æ · b.Color, p.Color = p.Color, b.Color //äº¤æ¢å…„å¼ŸèŠ‚ç‚¹å’Œçˆ¶èŠ‚ç‚¹çš„é¢œè‰² b.Right.Color = Black tree.RRRotation(p) break } else if b.Left != nil \u0026amp;\u0026amp; b.Left.Color == Red { //case2 //å¯¹åº”case2: å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„ï¼Œä¸”æœ‰ä¸€ä¸ªå·¦èŠ‚ç‚¹ï¼ˆå¯ä»¥æ–­å®š å·¦èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼‰ b.Left.Color, b.Color = Black, Red tree.LLRotation(b) //ç»è¿‡LLæ—‹è½¬ä¹Ÿå°±æ˜¯å³æ—‹ å°±èœ•å˜ä¸ºäº†case1 } else { //case4:å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„ï¼Œä¸”æ²¡æœ‰çº¢è‰²å­èŠ‚ç‚¹ b.Color = Red if p.Color == Red { //å°†çˆ¶èŠ‚ç‚¹ç›´æ¥æŸ“é»‘å°±ç»“æŸäº† ä¹Ÿå°±æ˜¯ç›¸å½“äºçˆ¶å­é¢œè‰²äº¤æ¢ é»‘è‰²èŠ‚ç‚¹ä¸ªæ•°ä¸å˜ p.Color = Black break } else { delNode = p //å°†åˆ é™¤èŠ‚ç‚¹æ”¹ä¸ºå…¶çˆ¶äº²èŠ‚ç‚¹ é€’å½’,ç›´åˆ°é‡åˆ°æ ¹èŠ‚ç‚¹ æˆ–è€…å…¶çˆ¶äº²èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ } } } } else { //å½“å‰èŠ‚ç‚¹æ˜¯å³å­©å­ if b.Color == Red { //case5: å¦‚æœè¯¥å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼Œé‚£ä¹ˆæ ¹æ®çº¢é»‘æ ‘çš„ç‰¹æ€§å¯ä»¥å¾—å‡ºå®ƒçš„ä¸€å®šæœ‰ä¸¤ä¸ªé»‘è‰²çš„å­èŠ‚ç‚¹ b.Color, p.Color = Black, Red tree.LLRotation(p) } else { if b.Left != nil \u0026amp;\u0026amp; b.Left.Color == Red { //case1å’Œcase3 //å¯¹åº”case1 : å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„ï¼Œä¸”æœ‰ä¸€ä¸ªå³èŠ‚ç‚¹ï¼ˆå¯ä»¥æ–­å®š å³èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ //ä¹Ÿå¯¹åº”case3 : å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„ï¼Œä¸”æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼ˆå¯ä»¥æ–­å®š å·¦å³èŠ‚ç‚¹éƒ½æ˜¯çº¢è‰²çš„ï¼‰è¿™ä¸¤ç§æƒ…å†µä¸€æ · b.Color = p.Color p.Color, b.Left.Color = Black, Black tree.LLRotation(p) break } else if b.Right != nil \u0026amp;\u0026amp; b.Right.Color == Red { //case2 //å¯¹åº”case2: å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„ï¼Œä¸”æœ‰ä¸€ä¸ªå·¦èŠ‚ç‚¹ï¼ˆå¯ä»¥æ–­å®š å·¦èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼‰ b.Right.Color, b.Color = Black, Red tree.RRRotation(b) //ç»è¿‡RRæ—‹è½¬ä¹Ÿå°±æ˜¯å³æ—‹ å°±èœ•å˜ä¸ºäº†case1 } else { //case4:å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„ï¼Œä¸”æ²¡æœ‰çº¢è‰²å­èŠ‚ç‚¹ b.Color = Red if p.Color == Red { //å°†çˆ¶èŠ‚ç‚¹ç›´æ¥æŸ“é»‘å°±ç»“æŸäº† ä¹Ÿå°±æ˜¯ç›¸å½“äºçˆ¶å­é¢œè‰²äº¤æ¢ é»‘è‰²èŠ‚ç‚¹ä¸ªæ•°ä¸å˜ p.Color = Black break } else { delNode = p //å°†åˆ é™¤èŠ‚ç‚¹æ”¹ä¸ºå…¶çˆ¶äº²èŠ‚ç‚¹ é€’å½’,ç›´åˆ°é‡åˆ°æ ¹èŠ‚ç‚¹ æˆ–è€…å…¶çˆ¶äº²èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ } } } } } } //é¢œè‰²è°ƒæ•´å’Œæ—‹è½¬å®Œæ¯• å°†oldDeleteNodeå¯¹åº”çˆ¶èŠ‚ç‚¹æŒ‡å‘å®ƒçš„æŒ‡é’ˆæ”¹ä¸ºnil ç­‰å¾…gcå›æ”¶ if oldDeleteNode == oldDeleteNode.Parent.Left { oldDeleteNode.Parent.Left = nil } else { oldDeleteNode.Parent.Right = nil } }  \nåˆ¤æ–­æ˜¯å¦æ˜¯çº¢é»‘æ ‘  æ£€æŸ¥ä¸€ä¸ªæ ‘æ˜¯å¦æ˜¯çº¢é»‘æ ‘\n//ISRBTRET åˆ¤æ–­æ˜¯å¦æ˜¯RBTçš„è¿”å›å€¼ type ISRBTRET struct { ISRBT bool //æ˜¯å¦æ˜¯RBT minValNode *RBTreeNode //å½“å‰æ ‘çš„æœ€å°å€¼èŠ‚ç‚¹ maxValNode *RBTreeNode //å½“å‰æ ‘çš„æœ€å¤§å€¼èŠ‚ç‚¹ BlackCount int //å·¦å³å­æ ‘è·¯å¾„çš„é»‘è‰²èŠ‚ç‚¹ä¸ªæ•°è¿™é‡Œåº”è¯¥ç›¸åŒ å¦åˆ™å°±ä¸æ˜¯çº¢é»‘æ ‘ } //ISRBT åˆ¤æ–­å½“å‰æ ‘æ˜¯å¦ä¸ºAVLæ ‘ å¤–éƒ¨ä½¿ç”¨ func ISRBT(node *RBTreeNode, less Less) bool { if node == nil { return true } if node.Color == Red { return false } ret := isAnRBTree(node, less) return ret.ISRBT } //isAnRBTree åˆ¤æ–­å½“å‰æ ‘æ˜¯å¦ä¸ºBSTæ ‘ å†…éƒ¨ä½¿ç”¨ func isAnRBTree(node *RBTreeNode, less Less) ISRBTRET { if node == nil { return ISRBTRET{true, nil, nil, 0} } if node.Color == Red \u0026amp;\u0026amp; (getColor(node.Left) == Red || getColor(node.Right) == Red) { fmt.Println(\u0026quot;ä¸æ˜¯RBT åŸå› æ˜¯èŠ‚ç‚¹:\u0026quot;, node.Key, \u0026quot; é¢œè‰²ä¸ºçº¢,å…¶å­èŠ‚ç‚¹è¿˜æœ‰çº¢è‰²\u0026quot;) if getColor(node.Left) == Red { fmt.Println(\u0026quot;å·¦å­©å­ä¸ºçº¢è‰²:\u0026quot;, node.Left.Key) } if getColor(node.Right) == Red { fmt.Println(\u0026quot;å³å­©å­ä¸ºçº¢è‰²:\u0026quot;, node.Right.Key) } return ISRBTRET{false, nil, nil, 0} } retLeft, retRight := isAnRBTree(node.Left, less), isAnRBTree(node.Right, less) if retLeft.ISRBT \u0026amp;\u0026amp; retRight.ISRBT \u0026amp;\u0026amp; (retLeft.maxValNode == nil || less(retLeft.maxValNode.Key, node.Key)) \u0026amp;\u0026amp; (retRight.minValNode == nil || less(node.Key, retRight.minValNode.Key)) \u0026amp;\u0026amp; retLeft.BlackCount == retRight.BlackCount { blackCount := retLeft.BlackCount if node.Color == Black { //å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯é»‘è‰² é»‘è‰²èŠ‚ç‚¹æ•°é‡åŠ ä¸€ blackCount++ } ret := ISRBTRET{true, nil, nil, blackCount} if retLeft.minValNode == nil { ret.minValNode = node } else { ret.minValNode = retLeft.minValNode //å½“å‰æ ‘çš„æœ€å°å€¼èŠ‚ç‚¹èµ‹å€¼ä¸ºå·¦å­æ ‘çš„æœ€å°å€¼ } if retRight.maxValNode == nil { ret.maxValNode = node } else { ret.maxValNode = retRight.maxValNode //å½“å‰æ ‘çš„æœ€å¤§å€¼èŠ‚ç‚¹èµ‹å€¼ä¸ºå³å­æ ‘çš„æœ€å¤§å€¼ } return ret } else { fmt.Println(\u0026quot;key=\u0026quot;, node.Key, \u0026quot; ä¸æ˜¯RBT\u0026quot;) if retLeft.ISRBT == false { fmt.Println(\u0026quot;åŸå› :å…¶å·¦å­æ ‘ä¸æ˜¯RBT\u0026quot;) } if retRight.ISRBT == false { fmt.Println(\u0026quot;åŸå› :å…¶å³å­æ ‘ä¸æ˜¯RBT\u0026quot;) } if retLeft.maxValNode != nil \u0026amp;\u0026amp; less(retLeft.maxValNode.Key, node.Key) == false { fmt.Println(\u0026quot;åŸå› :ä¸æ˜¯BST å…¶å·¦å­æ ‘å­˜åœ¨æ¯”å…¶å¤§çš„èŠ‚ç‚¹:\u0026quot;, retLeft.maxValNode.Key) } if retRight.minValNode != nil \u0026amp;\u0026amp; less(node.Key, retRight.minValNode.Key) == false { fmt.Println(\u0026quot;åŸå› :ä¸æ˜¯BST å…¶å³å­æ ‘å­˜åœ¨æ¯”å…¶å°çš„èŠ‚ç‚¹:\u0026quot;, retRight.minValNode.Key) } if retLeft.BlackCount != retRight.BlackCount { fmt.Println(\u0026quot;åŸå› å·¦å³å­æ ‘é»‘è‰²èŠ‚ç‚¹ä¸ªæ•°ä¸ç›¸ç­‰,å·¦å­æ ‘é»‘èŠ‚ç‚¹ä¸ªæ•°:\u0026quot;, retLeft.BlackCount, \u0026quot; å³å­æ ‘é»‘èŠ‚ç‚¹ä¸ªæ•°:\u0026quot;, retRight.BlackCount) } return ISRBTRET{false, nil, nil, -1} } }  \nä»ä¸Šåˆ°ä¸‹æŒ‰ç…§å±‚æ¬¡ ä»å·¦åˆ°å³æŒ‰ç…§é¡ºåºæ‰“å°çº¢é»‘æ ‘ çº¢è‰²èŠ‚ç‚¹æ‰“å°çº¢è‰²  é€å±‚ï¼Œæ¯å±‚ä»å·¦åˆ°å³å½¢è±¡åŒ–æ‰“å°çº¢é»‘æ ‘\n//PrintVisually é€å±‚æ‰“å° æ–¹å‘ ä»å·¦å¾€å³å½¢è±¡åŒ–æ›´ç›´è§‚çš„æ‰“å°äºŒå‰æ ‘ func (tree *RBTree) PrintVisually() { if tree.Size == 0 { return } nilNode := \u0026amp;RBTreeNode{nil, nil, nil, nil, false} //å®šä¹‰ä¸€ä¸ªç©ºèŠ‚ç‚¹ depth := getMaxDepth(tree.Root) //æœ€æ·±å±‚æ¬¡ // fmt.Println(\u0026quot;depth=\u0026quot;, depth) //ç”³è¯·2ä¸ªé˜Ÿåˆ— ä»1ä¸ªé˜Ÿåˆ—å‡ºé˜Ÿ åŒæ—¶å°†å…¶å·¦å³å­æ ‘ä¾æ¬¡å…¥é˜Ÿåˆ°å¦å¤–ä¸€ä¸ªé˜Ÿåˆ— myQueue1, myQueue2 := queue.CreateEmptyQueue(), queue.CreateEmptyQueue() myQueue1.Push(tree.Root) //æ ¹èŠ‚ç‚¹å…ˆå…¥é˜Ÿåˆ—1 //ç»ˆæ­¢æ¡ä»¶ æœ€å¤§å±‚æ¬¡æ‰“å°å®Œæ¯• for i, cur, next := 1, myQueue1, myQueue2; i \u0026lt;= depth; i, cur, next = i+1, next, cur { count := 1 //æ ‡è®°æ‰“å°å½“å‰å±‚æ¬¡çš„ç¬¬å‡ ä¸ªå…ƒç´  tabCount := (1\u0026lt;\u0026lt;(depth+1-i) - 1) / 2 //æ‰“å°å…ƒç´  è®¡ç®—æ‰“å°å‰é¢\\tä¸ªæ•° for cur.IsEmpty() == false { //é˜Ÿåˆ—1ä¸ä¸ºç©º if count \u0026gt; 1 { tabCount = (1\u0026lt;\u0026lt;(depth+1-i) - 1) } node := cur.Pop().(*RBTreeNode) if node != nilNode { //ä¸æ˜¯ç©ºèŠ‚ç‚¹ //å°†å…¶å·¦å³å­©å­å…¥åˆ°ä¸‹ä¸€å±‚é˜Ÿåˆ— for j := 0; j \u0026lt; tabCount; j++ { fmt.Print(\u0026quot; \u0026quot;) } if node.Color == Red { fmt.Print(redBg, node.Key, reset) } else { fmt.Print(node.Key) } count++ if node.Left != nil { next.Push(node.Left) } else { next.Push(nilNode) //åŠ å…¥ä¸€ä¸ªç©ºèŠ‚ç‚¹ ä¸ºäº†æ‰“å°å¥½çœ‹ } if node.Right != nil { next.Push(node.Right) } else { next.Push(nilNode) //åŠ å…¥ä¸€ä¸ªç©ºèŠ‚ç‚¹ ä¸ºäº†æ‰“å°å¥½çœ‹ } } else { //ç©ºèŠ‚ç‚¹ for j := 0; j \u0026lt; tabCount; j++ { fmt.Print(\u0026quot; \u0026quot;) } fmt.Print(\u0026quot;*\u0026quot;) count++ next.Push(nilNode) //åŠ å…¥ä¸€ä¸ªç©ºèŠ‚ç‚¹ ä¸ºäº†æ‰“å°å¥½çœ‹ next.Push(nilNode) //åŠ å…¥ä¸€ä¸ªç©ºèŠ‚ç‚¹ ä¸ºäº†æ‰“å°å¥½çœ‹ } } fmt.Print(\u0026quot;\\n\u0026quot;) } myQueue1.Clear() myQueue2.Clear() }  \nBæ ‘ å¾…è¡¥å…… B+æ ‘ å¾…è¡¥å…… ","id":2,"section":"posts","summary":"æ•°ç»„ â€‹ æ•°ç»„æ˜¯ä¸€ç§å…¸å‹çš„çº¿å½¢æ•°æ®ç»“æ„ï¼Œç‰¹ç‚¹ï¼šå­˜æ”¾è¿ç»­çš„ç›¸åŒæ•°æ®ç±»å‹ï¼Œéšæœºè®¿é—®é€Ÿåº¦æ¯”è¾ƒå¿«ã€‚éšæœºæ·»åŠ å’Œåˆ é™¤ï¼Œéœ€è¦æ‰¹é‡ç§»åŠ¨å…ƒç´ ã€‚ä¸»æµç¼–ç¨‹è¯­è¨€åŸºæœ¬ä¸Šè‡ª","tags":["æ•°æ®ç»“æ„"],"title":"å¸¸ç”¨æ•°æ®ç»“æ„","uri":"http://heketong.github.io/2020/05/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","year":"2020"},{"content":" å†’æ³¡æ’åº ä»‹ç» â€‹ å†’æ³¡æ’åºæ˜¯ä¸€ç§æ¯”è¾ƒç®€å•çš„æ’åºï¼Œä¹‹æ‰€ä»¥å«å†’æ³¡ï¼Œæ˜¯å› ä¸ºåœ¨ä¸¤ä¸¤æ¯”è¾ƒçš„è¿‡ç¨‹ä¸­è¾ƒå¤§çš„æ•°å°±åƒå†’æ³¡ä¸€æ ·è¢«æ¢åˆ°åé¢ã€‚è¯¦ç»†è§£é‡Šï¼šä¾æ¬¡æ¯”è¾ƒç›¸é‚»çš„ä¸¤ä¸ªæ•°ï¼Œå‰é¢çš„æ•°å¤§äºåé¢çš„æ•°ï¼Œåˆ™äº¤æ¢ï¼Œå°†è¾ƒå¤§çš„æ•°æŒªåŠ¨åˆ°åé¢\n ç¬¬1è½®: æ¯”è¾ƒ1 \u0026ndash; N ç»è¿‡ä¾æ¬¡ç›¸é‚»ä¸¤ä¸¤æ¯”è¾ƒäº¤æ¢ æœ€å¤§çš„æ•°åˆ™æ”¾åˆ°äº†æœ€å ç¬¬2è½®: æ¯”è¾ƒ1 \u0026ndash;N-1 ç»è¿‡ä¾æ¬¡ç›¸é‚»ä¸¤ä¸¤æ¯”è¾ƒäº¤æ¢ ç¬¬2å¤§çš„æ•°åˆ™æ”¾åˆ°äº†N-1çš„ä½ç½® ç¬¬N-1è½®:æ¯”è¾ƒ1 \u0026ndash; 2 å‰2ä¸ªæ•°ä¸¤ä¸¤æ¯”è¾ƒäº¤æ¢ æ•´ä¸ªè¿‡ç¨‹å®Œæˆ  ä»£ç   BubbleSort\nfunc BubbleSort(a []int) { if len(a) \u0026lt; 2 { //ä¸€ä¸ªæ•°æˆ–è€…ä¸ºç©º ä¸ç”¨æ’åº return } //å¤–å±‚å¾ªç¯æ§æ§åˆ¶æ¯è½®å¾ªç¯ä¸¤ä¸¤æ¯”è¾ƒçš„æœ€å¤§ä¸‹æ ‡ ç¬¬1æ¬¡ä¸ºN-1 æœ€åä¸€æ¬¡ä¸º1(ä¹Ÿå°±æ˜¯æœ€å‰é¢çš„2ä¸ªå…ƒç´ ) for endPos := len(a) - 1; endPos \u0026gt; 0; endPos-- { //å†…å±‚å¾ªç¯å®Œæˆä¸¤ä¸¤æ¯”è¾ƒäº¤æ¢ for i := 0; i \u0026lt; endPos; i++ { if a[i] \u0026gt; a[i+1] { a[i], a[i+1] = a[i+1], a[i] } } } }  \næ—¶é—´å¤æ‚åº¦ â€‹ O($N^2$)\nç¨³å®šæ€§ â€‹ ç¨³å®š å› ä¸ºå¦‚æœ2ä¸ªæ•°ç›¸ç­‰ åˆ™ä»–ä»¬çš„ç›¸å¯¹ä½ç½® å¹¶æ²¡æœ‰å‘ç”Ÿæ”¹å˜\nä¼˜åŒ– â€‹ çœ‹å†…å±‚å¾ªç¯ å¦‚æœå¹¶æ²¡æœ‰å‘ç”Ÿæ•°æ®äº¤æ¢ åˆ™è¯æ˜æ‰€æœ‰æ•°æ®å·²ç»æ’åºå®Œæˆï¼Œè¿™ä¸ªæ—¶å€™ç›´æ¥ç»“æŸå³å¯ åŠ ä¸€ä¸ªæ ‡å¿—åˆ¤æ–­å³å¯\n BubbleSortOpt\nfunc BubbleSort(a []int) { if len(a) \u0026lt; 2 { //ä¸€ä¸ªæ•°æˆ–è€…ä¸ºç©º ä¸ç”¨æ’åº return } isChg := false //å¤–å±‚å¾ªç¯æ§æ§åˆ¶æ¯è½®å¾ªç¯ä¸¤ä¸¤æ¯”è¾ƒçš„æœ€å¤§ä¸‹æ ‡ ç¬¬1æ¬¡ä¸ºN-1 æœ€åä¸€æ¬¡ä¸º1(ä¹Ÿå°±æ˜¯æœ€å‰é¢çš„2ä¸ªå…ƒç´ ) for endPos := len(a) - 1; endPos \u0026gt; 0; endPos-- { //å†…å±‚å¾ªç¯å®Œæˆä¸¤ä¸¤æ¯”è¾ƒäº¤æ¢ for i := 0; i \u0026lt; endPos; i++ { if a[i] \u0026gt; a[i+1] { a[i], a[i+1] = a[i+1], a[i] isChg = true } } if !isChg { //å¦‚æœå†…å±‚å¾ªç¯æ²¡æœ‰å‘ç”Ÿæ•°æ®äº¤æ¢ åˆ™è¡¨æ˜æ‰€æœ‰æ•°æ®éƒ½å·²ç»æ’åºå®Œæˆ ç›´æ¥é€€å‡ºå¾ªç¯å³å¯ break } } }  \nç½‘æœå›¾è§£ â€‹ æ‘˜è‡ª: https://www.cnblogs.com/onepixel/p/7674659.html\næ’å…¥æ’åº ä»‹ç» â€‹ æ’å…¥æ’åºé¡¾åæ€ä¹‰å°±æ˜¯å°†ä¸€ä¸ªå¾…æ’åºçš„å…ƒç´ ï¼Œæ’å…¥åˆ°ä¸€ç»„å·²ç»æ’å¥½åºçš„å…ƒç´ ä¸­ï¼Œå¦‚æœå½¢è±¡æ¯”å–»ä¸‹ï¼Œå¯ä»¥æƒ³è±¡ä¸€ä¸‹æ‰“ç‰Œï¼Œæ‹¿èµ·æ¥ç¬¬ä¸€å¼ ç‰Œè‡ªç„¶å°±æ˜¯æ’å¥½åºçš„ï¼Œæ‹¿èµ·ç¬¬äºŒå¼ åˆ™è·Ÿç¬¬ä¸€å¼ è¿›è¡Œæ¯”è¾ƒï¼Œæ’å…¥åˆ°åˆé€‚çš„ä½ç½®ã€‚æ¥ä¸‹æ¥æ‹¿ç¬¬ä¸‰å¼  è·Ÿå‰é¢2å¼ å·²ç»æ’å¥½åºçš„æ¯”è¾ƒï¼Œæ’å…¥åˆé€‚çš„ä½ç½®ï¼Œä¾æ¬¡ç±»æ¨ï¼Œæ‹¿å®Œæ‰€æœ‰çš„ç‰Œï¼Œé¡ºåºè‡ªç„¶ä¹Ÿæ’å¥½äº†ã€‚\nâ€‹ å°†å¾…æ’åºçš„å…ƒç´ åˆ†ä¸ºæœ‰åºåŒºå’Œæ— åºåŒºï¼ŒæŒ‰ç…§é¡ºåºæ¯æ¬¡ä»æ— åºåŒºæ‹¿ä¸€ä¸ªå…ƒç´ ï¼Œæ’å…¥æ’å…¥åˆ°æœ‰åºåŒºï¼Œç›´åˆ°æ‰€æœ‰æ— åºåŒºçš„å…ƒç´ éƒ½æ’å…¥æœ‰åºåŒºï¼Œæ•´ä¸ªæ’åºè¿‡ç¨‹ç»“æŸã€‚ç¬¬ä¸€æ¬¡æœ‰åºåŒºä¸ºç¬¬1ä¸ªå…ƒç´ ï¼Œæ— åºåŒºä¸ºç¬¬2\u0026mdash;Nä¸ªå…ƒç´ ï¼Œæ‹¿å‡ºç¬¬2ä¸ªå…ƒç´ æ’å…¥åˆ°æœ‰åºåŒºã€‚\nä»£ç   InsertSort\nfunc InsertSort(a []int) { if len(a) \u0026lt; 2 { //ä¸€ä¸ªæ•°æˆ–è€…ä¸ºç©º ä¸ç”¨æ’åº return } //jä¸ºæ— åºåŒºçš„ç¬¬ä¸€ä¸ªå…ƒç´  å¯¹åº”ä¸‹æ ‡ä»1å¼€å§‹ï¼Œæ¯æ¬¡åç§»ä¸€ä¸ªä½ç½® for j := 1; j \u0026lt; len(a); j++ { //å†…å±‚å¾ªç¯å®Œæˆæ¯”è¾ƒæ’å…¥ å€’åºä¾æ¬¡è·Ÿæœ‰åºåŒºçš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå°äºæœ‰åºåŒºçš„å…ƒç´  åˆ™äº¤æ¢ for i := j; i \u0026gt; 0; i-- { if a[i] \u0026lt; a[i-1] { a[i], a[i-1] = a[i-1], a[i] } } } }  \næ—¶é—´å¤æ‚åº¦ â€‹ O($N^2$)\nç®—æ³•ç¨³å®šæ€§ â€‹ ç¨³å®š æ²¡æœ‰æ”¹å˜ä¸¤ä¸ªç›¸ç­‰å…ƒç´ çš„ç›¸å¯¹ä½ç½®\nä¼˜åŒ– â€‹ ä¸Šé¢ä»£ç å†…å±‚å¾ªç¯åœ¨æŸ¥æ‰¾å¾…æ’å…¥ä½ç½®æ—¶æ˜¯å€’åºé€ä¸ªæ¯”è¾ƒçš„ï¼Œåœ¨æŸ¥æ‰¾å¾…æ’å…¥ä½ç½®æ—¶å€™æ˜¯å¯ä»¥ä¼˜åŒ–çš„ï¼Œé‡‡ç”¨äºŒåˆ†æŸ¥æ‰¾å¯ä»¥æœ‰æ•ˆå‡å°‘æ¯”è¾ƒæ¬¡æ•°ï¼Œä½†ä¼˜åŒ–åçš„æ’å…¥ç®—æ³•åˆ™å˜ä¸ºä¸ç¨³å®šçš„\n InsertSortOpt\n//BinSerachInsertIndex äºŒåˆ†æŸ¥æ‰¾åœ¨aæ•°ç»„ beginåˆ°endåŒºé—´ keyå…ƒç´ çš„æ’å…¥ä½ç½® func BinSerachInsertIndex(a []int, begin int, end int, key int) int { pos := -1 //éœ€è¦æ’å…¥çš„ä½ç½® for begin \u0026lt;= end { mid := begin + (end-begin)/2 if a[mid] == key { //å¦‚æœç­‰äºkey åˆ™æ‰¾åˆ°ä½ç½® pos = mid + 1 break } else if a[mid] \u0026lt; key { begin = mid + 1 } else { end = mid - 1 } } if pos == -1 { pos = begin } return pos } func InsertSortOpt(a []int) { if len(a) \u0026lt; 2 { //ä¸€ä¸ªæ•°æˆ–è€…ä¸ºç©º ä¸ç”¨æ’åº return } for j := 1; j \u0026lt; len(a); j++ { begin, end, key := 0, j-1, a[j] //æ‰¾åˆ°æ’å…¥çš„ä½ç½® pos := BinSerachInsertIndex(a, begin, end, key) //å°†posåˆ°endåŒºé—´çš„å…ƒç´ é€ä¸ªåç§» for index := j; index \u0026gt; pos; index-- { a[index] = a[index-1] } //æ’å…¥å¾…æ’åºå…ƒç´  a[pos] = key } }  \nç½‘æœå›¾è§£ â€‹ æ‘˜è‡ª:https://www.cnblogs.com/onepixel/p/7674659.html\nå½’å¹¶æ’åº ä»‹ç» â€‹ MergeSort åˆå¹¶ä¸¤ä¸ªæœ‰åºçš„åºåˆ—ä¸º1çš„å¤§çš„æœ‰åºçš„åºåˆ—ï¼Œæœ€å…¸å‹çš„å½’å¹¶æ’åºå¯ä»¥åˆ†2ä¸ªå¤§çš„æ­¥éª¤ï¼š\n1 é‡‡ç”¨é€’å½’æ€æƒ³ å°†ä¸€ä¸ªå¤§çš„åºåˆ—:äºŒåˆ†ä¸ºå¤§è‡´å¹³å‡çš„å­åºåˆ—ï¼Œç„¶åé’ˆå¯¹æ¯ä¸ªå­åºåˆ—éƒ½å†é€’å½’äºŒåˆ†(æœ€åæ¯ä¸ªå­åºåˆ—é•¿åº¦éƒ½ä¸º1)\n2 ä¸¤ä¸¤å­åºåˆ—åˆå¹¶ä¸ºæœ‰åºåºåˆ— ç›´åˆ°æ‰€æœ‰å­åºåˆ—åˆå¹¶å®Œæˆ\nâ€‹ æ•´ä½“å½’å¹¶æ’åºä¹Ÿç”¨åˆ°äº†å¾ˆé‡è¦çš„åˆ†æ²»æ€æƒ³ï¼Œä¹Ÿå°±æ˜¯å°†å¤§çš„é—®é¢˜åˆ†ä¸ºå°çš„é—®é¢˜ é€ä¸ªè§£å†³\nä»£ç   MergeSort\nfunc MergeSort(a []int, left int, right int) { //æ ¡éªŒ if len(a) \u0026lt; 2 || left \u0026lt; 0 || right \u0026gt; len(a) || left \u0026gt;= right { return } mid := left + (right-left)/2 //æ•°ç»„ä¸­é—´ä½ç½® MergeSort(a, left, mid) //å·¦è¾¹å½’å¹¶æ’åº MergeSort(a, mid+1, right) //å³è¾¹é€’å½’æ’åº MergeSlice(a, left, mid, right) //åˆå¹¶2ä¸ªå­åºåˆ—ä¸ºå¤§çš„æœ‰åºåºåˆ— } func MergeSlice(a []int, left int, mid int, right int) { //å…ˆç”Ÿæˆ1ä¸ªè¾…åŠ©ç©ºé—´ é•¿åº¦ å®¹é‡éƒ½æ˜¯right-left+1 help := make([]int, right-left+1, right-left+1) helpIndex := 0 //helpæ•°ç»„èµ·å§‹ä½ç½® å¡«å…¥ä¸€ä¸ªæ•°å€¼ å¾€åç§»åŠ¨ä¸€ä½ //å®šä¹‰2ä¸ªä¸‹æ ‡ å¼€å§‹åˆ†åˆ«æŒ‡å‘2ä¸ªå­åŒºé—´çš„æœ€å¼€å§‹ä½ç½® ç„¶åé€ä¸ªéå† LIndex := left RIndex := mid + 1 for LIndex \u0026lt;= mid \u0026amp;\u0026amp; RIndex \u0026lt;= right { if a[LIndex] \u0026lt;= a[RIndex] { //å·¦è¾¹åŒºé—´æ•°å€¼è¾ƒå° å·¦è¾¹è¿›è¾…åŠ©ç©ºé—´ help[helpIndex] = a[LIndex] LIndex++ } else { help[helpIndex] = a[RIndex] RIndex++ } helpIndex++ //ä¸ç®¡å·¦è¾¹åŒºé—´è¿›è¾…åŠ©è¿˜æ˜¯å³è¾¹åŒºé—´ è¾…åŠ©æ•°ç»„ä¸‹æ ‡ä¸‹ç§»ä¸€ä¸ªä½ç½® å› ä¸ºå¿…å®šè¿›äº†ä¸€ä¸ªæ•° } for LIndex \u0026lt;= mid { //å¦‚æœéå†å®Œæˆ å·¦è¾¹åŒºé—´è¿˜æœ‰æ•°æ²¡æ”¾è¿›è¾…åŠ©æ•°ç»„ é‚£å°±è¯´æ˜å‰©ä¸‹çš„å·¦è¾¹åŒºé—´æ•°è¾ƒå¤§ ä¾æ¬¡cpè¿›è¾…åŠ© help[helpIndex] = a[LIndex] LIndex++ helpIndex++ } for RIndex \u0026lt;= right { //å¦‚æœéå†å®Œæˆ å·¦è¾¹åŒºé—´è¿˜æœ‰æ•°æ²¡æ”¾è¿›è¾…åŠ©æ•°ç»„ é‚£å°±è¯´æ˜å‰©ä¸‹çš„å·¦è¾¹åŒºé—´æ•°è¾ƒå¤§ ä¾æ¬¡cpè¿›è¾…åŠ© help[helpIndex] = a[RIndex] RIndex++ helpIndex++ } //è¾…åŠ©ç©ºé—´å·²ç»æ’å¥½åº è¦†ç›–å¡«å›åŸæ•°ç»„ for i := 0; i \u0026lt; helpIndex; i++ { a[left+i] = help[i] } }  \næ—¶é—´å¤æ‚åº¦ â€‹ O( NLogN)\nç®—æ³•ç¨³å®šæ€§ â€‹ ç¨³å®š\nä¼˜åŒ– è§„æ¨¡è¾ƒå°çš„æ—¶å€™ ä¸ç”¨å½’å¹¶ï¼Œæ”¹ä¸ºæ’æ’ â€‹ é€’å½’å…¶å®éå¸¸æ¶ˆè€—æ€§èƒ½ è§„æ¨¡è¾ƒå°çš„æ—¶å€™å¯ä»¥ä¸å†é€’å½’ è¾ƒå°‘é€’å½’è°ƒç”¨æ¬¡æ•°\n MergeSortOpt\nfunc MergeSortOpt(a []int, left int, right int) { //ä¸€ä¸ªæ•° ä¸ºç©º ä¸‹æ ‡ä¸åˆæ³• æ‹†åˆ†å®Œæˆ if len(a) \u0026lt; 2 || left \u0026lt; 0 || right \u0026gt; len(a) || left \u0026gt;= right { return } if left+20 \u0026gt;= right {//è¿™é‡Œå¢åŠ å‡ è¡Œä»£ç  è§„æ¨¡è¾ƒå° æ”¹ä¸ºæ’æ’ InsertSort(a[left : right+1]) return } mid := left + (right-left)/2 //æ•°ç»„ä¸­é—´ä½ç½® MergeSort(a, left, mid) //å·¦è¾¹å½’å¹¶æ’åº MergeSort(a, mid+1, right) //å³è¾¹é€’å½’æ’åº MergeSlice(a, left, mid, right) //åˆå¹¶2ä¸ªå­åºåˆ—ä¸ºå¤§çš„æœ‰åºåºåˆ— }  \næ£€æŸ¥åˆå¹¶å‰ä¸¤ä¸ªæ•°ç»„æ˜¯å¦å·²ç»æœ‰åº æ²¡æœ‰å¿…è¦å†è°ƒç”¨åˆå¹¶äº†  MergeSortOpt2\nfunc MergeSortOpt2(a []int, left int, right int) { //ä¸€ä¸ªæ•° ä¸ºç©º ä¸‹æ ‡ä¸åˆæ³• æ‹†åˆ†å®Œæˆ if len(a) \u0026lt; 2 || left \u0026lt; 0 || right \u0026gt; len(a) || left \u0026gt;= right { return } if left+20 \u0026gt;= right {//è¿™é‡Œå¢åŠ å‡ è¡Œä»£ç  è§„æ¨¡è¾ƒå° æ”¹ä¸ºæ’æ’ InsertSort(a[left : right+1]) return } mid := left + (right-left)/2 //æ•°ç»„ä¸­é—´ä½ç½® MergeSort(a, left, mid) //å·¦è¾¹å½’å¹¶æ’åº MergeSort(a, mid+1, right) //å³è¾¹é€’å½’æ’åº if a[mid]\u0026lt;=a[mid+1]{//å¦‚æœ2ä¸ªå­åºåˆ—æœ¬èº«å·²ç»æœ‰åº æ— éœ€å†åˆå¹¶ return } MergeSlice(a, left, mid, right) //åˆå¹¶2ä¸ªå­åºåˆ—ä¸ºå¤§çš„æœ‰åºåºåˆ— }  \nç½‘æœå›¾è§£ é€‰æ‹©æ’åº ä»‹ç» â€‹ æ¯è½®éƒ½é€‰æ‹©ä¸€ä¸ªæå€¼(æœ€å¤§æˆ–è€…æœ€å°)æ”¾åˆ°æ•°ç»„çš„æŸä¸€ç«¯ï¼Œå…¶å®ä¹Ÿæ˜¯åˆ†ä¸ºæœ‰åºåŒºå’Œæ— åºåŒºï¼Œåˆšå¼€å§‹å…¨æ˜¯æ— åºåŒºï¼Œ\nç¬¬1è½® éå†Nä¸ªæ•° æŒ‘é€‰æå€¼æ”¾åˆ°æ•°ç»„æœ€å·¦ä¾§ æœ‰åºåŒºæœ‰1ä¸ªæ•°\nç¬¬2è½® éå†å‰©ä¸‹çš„N-1ä¸ªæ•°ï¼ŒæŒ‘é€‰æå€¼æ”¾å…¥æ•°ç»„ç¬¬2ä¸ªä½ç½®ï¼Œä¹Ÿå°±æ˜¯ä¾æ¬¡æ”¾å…¥æœ‰åºåŒº\n\u0026hellip;\nç›´åˆ°å‰©ä¸‹æœ€åä¸€ä¸ªå…ƒç´  è¿™ä¸ªå…ƒç´ è‡ªç„¶æ˜¯æ•´ä¸ªæ•°ç»„çš„æå€¼ æ•´ä¸ªæ•°ç»„æ’åºå®Œæˆ\nä»£ç   SelectSort\nfunc SelectSort(a []int) { if len(a) \u0026lt; 2 { //ä¸€ä¸ªæ•°æˆ–è€…ä¸ºç©º ä¸ç”¨æ’åº return } for j := 0; j \u0026lt; len(a)-1; j++ {//æ§åˆ¶æ¯è½®å¾ªç¯ éå†æ¯”è¾ƒçš„å…ƒç´ ä¸ªæ•° min := j\t//minè®°å½•æœ€å°å…ƒç´ ä¸‹æ ‡ for i := j + 1; i \u0026lt; len(a); i++ { if a[min] \u0026gt; a[i] { min = i } } a[j], a[min] = a[min], a[j] //å°†æœ€å°å…ƒç´ ä¾æ¬¡æ”¾å…¥æœ‰åºåŒº } }  \næ—¶é—´å¤æ‚åº¦ â€‹ O($N^2$)\nç®—æ³•ç¨³å®šæ€§ â€‹ ä¸ç¨³å®š ä¼šæ”¹å˜ä¸¤ä¸ªç›¸ç­‰å…ƒç´ æœ¬èº«çš„ç›¸å¯¹ä½ç½® å¦‚ (7) 2 4 8 3 4 [7] 1 ç¬¬ä¸€è½®ä¸‹æ¥(7)ä¼šè·‘åˆ°æœ€å\nä¼˜åŒ– â€‹ ä¿®æ”¹å†…å±‚å¾ªç¯ï¼Œæ¯ä¸€è½®éå† ä¸ä»…æ‰¾åˆ°æœ€å°ä¸‹æ ‡ ä¹Ÿè¦æ‰¾åˆ°æœ€å¤§ä¸‹æ ‡ æœ€å°æ”¾æ•°ç»„å·¦è¾¹ï¼Œæœ€å¤§æ”¾æ•°ç»„å³è¾¹ï¼Œå‡å°‘å¾ªç¯æ¬¡æ•°ï¼Œå½“ç„¶å¤–å±‚å¾ªç¯æ¡ä»¶ä¹Ÿè¦ä¿®æ”¹ï¼Œæœ€å¼€å§‹æ— åºåŒºä¸ºæ•´ä¸ªæ•°ç»„ æ¯ä¸€è½®ä¸‹æ¥ æ•°ç»„ä¸¤ç«¯2ä¸ªå…ƒç´ å˜ä¸ºæœ‰åºï¼Œæœ‰åºåŒºä»ä¸¤ç«¯å¾€ä¸­é—´æ‰©å¤§ï¼Œç›´åˆ°æ‰€æœ‰å…ƒç´ éƒ½ä¸ºæœ‰åº  SelectSortOpt\nfunc SelectSortOPT(a []int) { if len(a) \u0026lt; 2 { //ä¸€ä¸ªæ•°æˆ–è€…ä¸ºç©º ä¸ç”¨æ’åº return } //åˆšå¼€å§‹left rightåˆ†åˆ«ä¸ºæ•°ç»„æœ€å°å’Œæœ€å¤§ä¸‹æ ‡ æ¯è½®å¾ªç¯leftå’Œrigntåˆ†åˆ«æ”¾ç½®æœ€å°å’Œæœ€å¤§å€¼ //ç»ˆæ­¢æ¡ä»¶ä¸ºleft==right æ¯è½®å¾ªç¯åleftå³ç§» rightå·¦ç§» for left, right := 0, len(a)-1; left \u0026lt; right; left, right = left+1, right-1 { minIndex, maxIndex := left, right for i := left; i \u0026lt;= right; i++ { if a[i] \u0026lt; a[minIndex] { //æ‰¾åˆ°æœ€å°å€¼ä¸‹æ ‡ minIndex = i } if a[i] \u0026gt; a[maxIndex] { //æ‰¾åˆ°æœ€å¤§å€¼ä¸‹æ ‡ maxIndex = i } } a[left], a[minIndex] = a[minIndex], a[left]//æœ€å°çš„æ”¾å½“å‰æ— åºåŒºæœ€å·¦è¾¹ if left == maxIndex { //å¦‚æœ€å¤§ä¸‹æ ‡å°±æ˜¯åˆšå¼€å§‹çš„æœ€å°ä¸‹æ ‡ å› ä¸ºå·²ç»äº¤æ¢åˆ°äº†minIndexä½ç½® æ‰€ä»¥æœ€å¤§ä¸‹æ ‡ä¹Ÿè¦è·Ÿç€ä¿®æ”¹ maxIndex = minIndex } a[maxIndex], a[right] = a[right], a[maxIndex]//æœ€å¤§å€¼æ”¾åˆ°å½“å‰æ— åºåŒºæœ€å³è¾¹ } }  \nç½‘æœå›¾è§£ â€‹ æ‘˜è‡ªï¼š https://www.cnblogs.com/onepixel/p/7674659.html\nå †æ’åº ä»‹ç» äºŒå‰å †ä»‹ç» å †æ’åºæ˜¯å€ŸåŠ©å †è¿™ç§æ•°æ®ç»“æ„è¿›è¡Œæ’åºï¼Œåˆåˆ†ä¸ºæœ€å¤§å †å’Œæœ€å°å †ã€‚å †ä¹Ÿåˆ†å¾ˆå¤šç§ï¼Œè¿™é‡Œç”¨äºŒå‰å †ï¼Œä¸‹é¢ä»ç½‘ä¸Šæ‰¾åˆ°çš„2å¼ å›¾å±•ç¤ºä¸‹æœ€å¤§å †å’Œæœ€å°å †ã€‚\nâ€‹ æœ€å¤§å † æ‰€æœ‰çˆ¶èŠ‚ç‚¹éƒ½\u0026gt;=ä¸¤ä¸ªå­èŠ‚ç‚¹ æœ€å°å † æ‰€æœ‰çˆ¶èŠ‚ç‚¹éƒ½\u0026lt;=ä¸¤ä¸ªå­èŠ‚ç‚¹\nâ€‹ æœ€å¤§å † å¯ç”¨äºå‡åºæ’åº æœ€å°å †å¯ç”¨äºé™åºæ’åº\nâ€‹ äºŒå‰å †å®ç°æ–¹å¼ä¸æ­¢ä¸€ç§ï¼Œè¿™é‡Œé€‰æ‹©æœ€ç®€å•çš„æ•°ç»„å®ç°ï¼Œä¸‹å›¾å±•ç¤ºäºŒå‰å †å¦‚ä½•ç”¨æ•°ç»„å­˜æ”¾ä»¥åŠçˆ¶å­èŠ‚ç‚¹å…³ç³»å¦‚ä½•å¯¹åº”åˆ°æ•°ç»„ä¸‹æ ‡å…³ç³»ã€‚\nå †æ’åºå¤§è‡´è¿‡ç¨‹  é¦–é€‰éå†æ•°ç»„ æ„å»ºäºŒå‰å †(æ•°ç»„å®ç°)\n äº¤æ¢å †å¤´å°¾ä¸¤ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯æ•°ç»„å¤´å°¾å…ƒç´ ï¼Œæœ€å¤§å€¼æ”¾åˆ°äº†æ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ ã€‚å› ä¸ºæ ¹èŠ‚ç‚¹å‘ç”Ÿå˜åŒ–\n  æ‰€ä»¥é‡æ–°å †åŒ–ï¼ŒèŒƒå›´ä¸åŒ…æ‹¬æœ€åä¸€ä¸ªå…ƒç´ ï¼Œæœ€åä¸€ä¸ªå…ƒç´ ç›¸å½“äºå·²ç»è¾“å‡ºæ’åºå®Œæˆï¼Œä¸ºæœ€å¤§å€¼ã€‚\n å¯¹äºé‡æ–°å †åŒ–çš„å‰é¢N-1ä¸ªå…ƒç´  å¾ªç¯æ‰§è¡Œç¬¬2æ­¥ ç›´åˆ°è¾“å‡ºæ‰€æœ‰å †èŠ‚ç‚¹ å®Œæˆæœ€ç»ˆæ’åº  ä»£ç  æœ€å¤§å †  MaxHeapSort\nfunc MaxHeapSort(a []int) { size:=len(a)//æ•°ç»„é•¿åº¦ if size \u0026lt; 2 { return } for i := 0; i \u0026lt; len(a); i++ {//éå†æ•°ç»„ æ„å»ºå † MaxHeapInsert(a, i) } for size \u0026gt; 0 { a[0], a[size-1] = a[size-1], a[0] //å°†å½“å‰å †é¡¶ä¹Ÿå°±æ˜¯æœ€å¤§å€¼æ”¾åˆ°æœ€å æŠŠæœ€åçš„å…ƒç´ æ¢åˆ°å †é¡¶ ç„¶åé‡å¡‘å † size-- MaxHeapify(a, 0, size) } } func MaxHeapInsert(a []int, index int) { //å¦‚æœæ’å…¥èŠ‚ç‚¹å¤§äºçˆ¶èŠ‚ç‚¹ åˆ™éœ€è¦å‘ä¸Šè°ƒæ•´ å…ˆè·Ÿçˆ¶èŠ‚ç‚¹äº¤æ¢ ç„¶åå†æ¯”è¾ƒä¸Šé¢çš„çˆ¶èŠ‚ç‚¹ for parentIndex := (index - 1) / 2; a[index] \u0026gt; a[parentIndex]; index, parentIndex = parentIndex, (index-1)/2 { a[index], a[parentIndex] = a[parentIndex], a[index] } } //å¤§å † é‡æ–°å †åŒ–è¿‡ç¨‹ func MaxHeapify(a []int, index int, size int) { for maxIndex := -1; maxIndex != index; { maxIndex = index leftIndex := 2*index + 1 rightIndex := 2*index + 2 //æ±‚å½“å‰èŠ‚ç‚¹ å·¦å­©å­ å³å­©å­ä¸­æœ€å¤§å€¼å¯¹åº”çš„ä¸‹æ ‡ if leftIndex \u0026lt; size \u0026amp;\u0026amp; a[maxIndex] \u0026lt; a[leftIndex] { maxIndex = leftIndex } if rightIndex \u0026lt; size \u0026amp;\u0026amp; a[maxIndex] \u0026lt; a[rightIndex] { maxIndex = rightIndex } if maxIndex != index { a[index], a[maxIndex] = a[maxIndex], a[index] //è·Ÿå·¦å­©å­ã€å³å­©å­ä¸­æœ€å¤§çš„äº¤æ¢ index = maxIndex maxIndex = -1 } } }  \næœ€å°å †  MinHeapSort\nfunc MinHeapSort(a []int) { if len(a) \u0026lt; 2 { return } for i := 0; i \u0026lt; len(a); i++ { MinHeapInsert(a, i) } size := len(a) for size \u0026gt; 0 { a[0], a[size-1] = a[size-1], a[0] //å°†å½“å‰å †é¡¶ä¹Ÿå°±æ˜¯æœ€å¤§å€¼æ”¾åˆ°æœ€å æŠŠæœ€åçš„å…ƒç´ æ¢åˆ°å †é¡¶ ç„¶åé‡å¡‘å † size-- MinHeapify(a, 0, size) } } //MinHeapInsert åˆ›å»ºå¤§å † æ•°ç»„å®ç° indexä¸ºè¦æ’å…¥çš„å…ƒç´ ä¸‹æ ‡ //èŠ‚ç‚¹ä¸‹æ ‡ä¸ºi å¯¹åº”å·¦å­©å­ä¸º2*i+1 å³è¾¹å­©å­ä¸º2*i+2 //èŠ‚ç‚¹ä¸‹æ ‡ä¸ºi å¯¹åº”çˆ¶èŠ‚ç‚¹ä¸º(i-1)/2 func MinHeapInsert(a []int, index int) { parentIndex := (index - 1) / 2 for a[index] \u0026lt; a[parentIndex] { //å¦‚æœæ’å…¥èŠ‚ç‚¹å°äºçˆ¶èŠ‚ç‚¹ åˆ™éœ€è¦å‘ä¸Šè°ƒæ•´ å…ˆè·Ÿçˆ¶èŠ‚ç‚¹äº¤æ¢ ç„¶åå†æ¯”è¾ƒä¸Šé¢çš„çˆ¶èŠ‚ç‚¹ a[index], a[parentIndex] = a[parentIndex], a[index] index = parentIndex parentIndex = (index - 1) / 2 } } //MinHeapify ä¸‹æ ‡indexå‘ç”Ÿäº†å˜åŒ– é‡å¡‘å † ä¸€è·¯å‘ä¸‹è°ƒæ•´ å¦‚æœä¸¤ä¸ªå­©å­ä¸­æœ‰ä¸€ä¸ªæ¯”è‡ªå·±å° åˆ™äº¤æ¢ ç„¶åç»§ç»­å¾€ä¸‹è°ƒæ•´æ‰¾åˆ°æ¯”è‡ªå·±å°çš„å­©å­ ç„¶åè·Ÿå…¶äº¤æ¢ //èŠ‚ç‚¹ä¸‹æ ‡ä¸ºi å¯¹åº”å·¦å­©å­ä¸º2*i+1 å³è¾¹å­©å­ä¸º2*i+2 //èŠ‚ç‚¹ä¸‹æ ‡ä¸ºi å¯¹åº”çˆ¶èŠ‚ç‚¹ä¸º(i-1)/2 func MinHeapify(a []int, index int, size int) { for minIndex := -1; minIndex != index; { minIndex = index leftIndex := 2*index + 1 rightIndex := 2*index + 2 //æ±‚å½“å‰èŠ‚ç‚¹ å·¦å­©å­ å³å­©å­ä¸­æœ€å°å€¼å¯¹åº”çš„ä¸‹æ ‡ if leftIndex \u0026lt; size \u0026amp;\u0026amp; a[minIndex] \u0026gt; a[leftIndex] { minIndex = leftIndex } if rightIndex \u0026lt; size \u0026amp;\u0026amp; a[minIndex] \u0026gt; a[rightIndex] { minIndex = rightIndex } if minIndex != index { a[index], a[minIndex] = a[minIndex], a[index] //è·Ÿå·¦å­©å­ã€å³å­©å­ä¸­æœ€å°çš„äº¤æ¢ index = minIndex minIndex = -1 } } }  \næ—¶é—´å¤æ‚åº¦ â€‹ O(NlogN)\nç®—æ³•ç¨³å®šæ€§ â€‹ ä¸ç¨³å®š\nä¼˜åŒ– â€‹ å½“å‰å®ç°çš„å°±æ˜¯åŸåœ°å †æ’åºï¼Œæ²¡æœ‰ä½¿ç”¨é¢å¤–çš„è¾…åŠ©ç©ºé—´ï¼Œæš‚æ— å¥½çš„ä¼˜åŒ–æ€è·¯ï¼Œå¾…è¡¥å……\nç½‘æœå›¾è§£ å¸Œå°”æ’åº ä»‹ç» â€‹ å¸Œå°”æ’åºæ˜¯ç›´æ¥æ’å…¥æ’åºçš„ä¼˜åŒ–ç‰ˆæœ¬ï¼Œç”±ä¸€ä¸ªå«shellçš„äººæå‡ºæ¥çš„ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯æŒ‰ç…§æ­¥é•¿åˆ†ç»„ï¼Œç„¶åæ¯ç»„åˆ†ç»„æ’æ’ï¼Œç„¶åç¼©çŸ­æ­¥é•¿åˆ†ç»„ï¼Œç»§ç»­æ¯ç»„æ’æ’ï¼Œæœ€åæ­¥é•¿ä¸º1ï¼Œå˜ä¸ºç›´æ¥æ’æ’ã€‚\nâ€‹ å…³äºæ­¥é•¿åŠç¼©çŸ­æ­¥é•¿å¦‚ä½•é€‰æ‹©ï¼Œæœ‰å¾ˆå¤šç§æ–¹æ¡ˆï¼Œå¯ä»¥ç›´æ¥åˆ†åŠï¼Œç„¶åå†é™¤ä»¥2 æœ€åä¸º1ï¼Œè¿™é‡Œé‡‡ç”¨çš„Knuthåºåˆ—ï¼Œä¹Ÿå°±æ˜¯æŒ‰ç…§ä¸‹é¢çš„è§„å¾‹é€’å¢\ngap=1\u0026mdash;\u0026ndash;\u0026gt;\u0026gt;gap=3*gap+1\nä»£ç   ShellSort\nfunc ShellSort(a []int) { //æ­¥é•¿é‡‡ç”¨knuthåºåˆ— å˜åŒ–è§„å¾‹ä¸º h=1 ---\u0026gt; h = 3*h+1 h := 1 for h \u0026lt;= len(a)/3 { h = 3*h + 1 } //æ§åˆ¶gapé€’å‡ æœ€åå˜ä¸º1 for gap := h; gap \u0026gt; 0; gap = (gap - 1) / 3 { //æ§åˆ¶åˆ†ç»„ for j := gap; j \u0026lt; len(a); j++ { //æ¯ç»„è¿›è¡Œç›´æ¥æ’æ’ for i := j; i \u0026gt; gap-1; i = i - gap { if a[i] \u0026lt; a[i-gap] { a[i], a[i-gap] = a[i-gap], a[i] } } } } }  \næ—¶é—´å¤æ‚åº¦ O($N^3\u0026frasl;2$)\nç®—æ³•ç¨³å®šæ€§ â€‹ ä¸ç¨³å®š\nä¼˜åŒ– â€‹ å¾…è¡¥å……\nç½‘æœå›¾è§£ å¿«é€Ÿæ’åº ä»‹ç» â€‹ å¿«é€Ÿæ’åºä¸»è¦ç”¨åˆ°äº†åˆ†æ²»å’Œé€’å½’æ€æƒ³ï¼Œè·Ÿå½’å¹¶æ’åºå·®ä¸å¤šï¼Œå¿«é€Ÿæ’åºä¸€èˆ¬è¦é€‰æ‹©ä¸€ä¸ªåŸºå‡†å€¼(pivot),ç„¶åå°†å°äºè¿™ä¸ªåŸºå‡†çš„æ”¾å·¦è¾¹ï¼Œå¤§äºè¿™ä¸ªåŸºå‡†çš„æ”¾å³è¾¹ï¼ŒåŸºå‡†å€¼æ”¾é‚£è¾¹æ— æ‰€è°“ï¼Œè¿™æ ·ä¸€è½®ä¸‹æ¥ï¼Œæ•°ç»„åˆ†æˆäº†2ä¸ªåŒºåŸŸï¼Œå·¦è¾¹åŒºåŸŸæ¯”å³è¾¹åŒºåŸŸå°ï¼Œç„¶åå¯¹2ä¸ªåŒºåŸŸç”¨é€’å½’çš„æ–¹æ³•ç»§ç»­å¿«æ’ã€‚\nâ€‹ è¿™é‡Œçš„å¿«é€Ÿç”¨è·å…°å›½æ——é—®é¢˜åˆ†æˆäº†3ä¸ªåŒºåŸŸï¼Œpivot ç„¶åé€’å½’ pivotçš„åŒºåŸŸ ç»§ç»­åˆ†åŒºå¿«æ’åº\nâ€‹ å…³äºåŸºå‡†å€¼çš„é€‰å–å¯ä»¥æœ‰å¾ˆå¤šç§ï¼Œå¯ä»¥éšæœºé€‰å–ï¼Œå¯ä»¥æœ€å‰é¢çš„ï¼Œå¯ä»¥æœ€åé¢çš„ï¼Œè¿™é‡Œé‡‡ç”¨çš„æ˜¯æœ€å¸¸è§(é€‰å–æœ€æœ«ç«¯å…ƒç´ )\nä»£ç   QuickSort\nfunc QuickSort(a []int, left int, right int) { if len(a) \u0026lt; 2 || left \u0026gt;= right { return } base := a[right] //åŸºå‡†é€‰å–æœ€æœ«ç«¯å…ƒç´  equalArea := PartitionIntSlice(a, left, right, base) QuickSort(a, left, equalArea[0]-1) //é€’å½’å¿«æ’å°äºåŒºé—´ QuickSort(a, equalArea[1]+1, right) //é€’å½’å¿«æ’å¤§äºåŒºé—´ } //PartitionIntSlice ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå·¦è¾¹ç•Œleft å³è¾¹ç•Œright æ¯”è¾ƒåŸºå‡†base //è¿”å›ä¸€ä¸ª2ä¸ªæ•°å€¼çš„intæ•°ç»„ è¯¥æ•°ç»„ç¬¬ä¸€ä¸ªå€¼ä¸ºç­‰äºbaseçš„å¼€å§‹ä½ç½® ç¬¬äºŒä¸ªå€¼ä¸ºç­‰äºbaseçš„ç»“æŸä½ç½® //æ‰€ä»¥ä¸‹æ ‡å°äºè¯¥æ•°ç»„ç¬¬ä¸€ä¸ªå€¼çš„åŒºé—´éƒ½å°äºbase ä¸‹æ ‡å¤§äºæ•°ç»„ç¬¬äºŒä¸ªå€¼çš„åŒºé—´éƒ½å¤§äºbase func PartitionIntSlice(a []int, left int, right int, base int) [2]int { l := left - 1 //lä¸ºå°äºåŒºé—´çš„ç»“æŸä¸‹æ ‡ åˆšå¼€å§‹æŒ‡å‘æœ€å°ä¸‹æ ‡å·¦è¾¹ r := right + 1 //lä¸ºå¤§äºåŒºé—´çš„å¼€å§‹ä¸‹æ ‡ åˆšå¼€å§‹æŒ‡å‘æœ€å¤§ä¸‹æ ‡å³è¾¹ cur := left //å½“å‰éå†çš„æ•°è®¾ç½®ä¸ºæ•´ä¸ªåŒºé—´æœ€å·¦è¾¹ for cur \u0026lt; r { if a[cur] \u0026lt; base { //å¦‚æœå½“å‰æ•°å°äºåŸºæ•° å½“å‰æ•°å’Œå°äºåŒºé—´çš„ä¸‹ä¸€ä¸ªæ•°äº¤æ¢ å°äºåŒºé—´æ‰©ä¸€ä¸ª a[cur], a[l+1] = a[l+1], a[cur] l++ cur++ } else if a[cur] \u0026gt; base { //å¦‚æœå½“å‰æ•°å¤§äºåŸºæ•° åˆ™curä¸‹æ ‡++ a[cur], a[r-1] = a[r-1], a[cur] r-- } else { //å½“å‰æ•°è·ŸåŸºæ•°ç›¸ç­‰ ä¸å˜ cur++ } } return [2]int{l + 1, r - 1} }  \næ—¶é—´å¤æ‚åº¦ â€‹ O(NlogN)\nç®—æ³•ç¨³å®šæ€§ â€‹ ä¸ç¨³å®š\nä¼˜åŒ– â€‹ å¯ä»¥é€‰æ‹©åŒè½´å¿«æ’åºï¼Œä¹Ÿå°±æ˜¯é€‰æ‹©2ä¸ªbase(ä¸ç›¸åŒ,ç›¸åŒçš„è¯å°±åˆå˜æˆäº†è·å…°å›½æ——) åˆ†åŒºä¸º maxbase\nä»£ç åç»­è¡¥å……\nç½‘æœå›¾è§£ è®¡æ•°æ’åº ä»‹ç» â€‹ è®¡æ•°æ’åºçš„åº”ç”¨åœºæ™¯æ¯”è¾ƒæ¸…æ™°ï¼Œä¹Ÿæ˜¯æ¡¶æ’åºçš„ä¸€ç§ã€‚æ˜ç¡®çš„çŸ¥é“ä¸€ä¸ªæ•°ç»„æœ‰Nçš„æ•´æ•°ï¼Œé‡æ¯”è¾ƒå¤§ï¼Œä½†æ˜¯æ•°æ®èŒƒå›´æ¯”è¾ƒå° éƒ½æ˜¯[0,MAX), ç„¶ååˆ›å»ºä¸€ä¸ªè®¡æ•°æ•°ç»„ï¼Œé•¿åº¦ä¸ºMAX,è®¡æ•°æ•°ç»„å€¼éƒ½åˆå§‹åŒ–ä¸º0ï¼Œç„¶åéå†åŸæ•°ç»„ï¼Œå°†åŸæ•°ç»„çš„å€¼å’Œè®¡æ•°æ•°ç»„çš„ä¸‹æ ‡å¯¹åº”èµ·æ¥ï¼Œæ¯”å¦‚åŸæ•°ç»„æŸä¸ªå…ƒç´ å€¼ä¸º1ï¼Œåˆ™è®¡æ•°æ•°ç»„ä¸‹æ ‡ä¸º1çš„å…ƒç´ åŠ 1ï¼Œè¡¨ç¤º1çš„å…ƒç´ å‡ºç°è¿‡ä¸€æ¬¡ï¼Œè¿™ä¸ªæ­¥éª¤å¯ä»¥å«åšå…¥æ¡¶ã€‚ç„¶åé¡ºåºéå†è®¡æ•°æ•°ç»„ï¼Œå¦‚æœè¯¥ä¸‹æ ‡çš„å…ƒç´ å‡ºç°è¿‡(ä¹Ÿå°±æ˜¯å€¼\u0026gt;0)ï¼Œæ•°ç»„å…ƒç´ å€¼ä¸ºå¤šå°‘ï¼Œåˆ™è¯¥ä¸‹æ ‡å‡ºæ¡¶å¤šå°‘æ¬¡ï¼Œä¾æ¬¡å¡«å›åŸæ•°ç»„å³å¯ã€‚\nâ€‹\nä»£ç   CountingSort\nfunc CountSort(a []int, max int) { if len(a) \u0026lt; 2 { return } count := make([]int, max, max) //åˆ›å»ºè®¡æ•°çš„æ¡¶ for i := 0; i \u0026lt; len(a); i++ { count[a[i]]++ } indexOfa := 0 for i := 0; i \u0026lt; len(count); i++ { for count[i] \u0026gt; 0 { a[indexOfa] = i indexOfa++ count[i]-- } } }  \næ—¶é—´å¤æ‚åº¦ O(N)\nç®—æ³•ç¨³å®šæ€§ â€‹ ç›´æ¥è®¡æ•°æ’åºæœ¬èº«æ˜¯ä¸ç¨³å®šçš„ï¼Œå¦‚æœé‡‡ç”¨ç´¯åŠ è®¡æ•°æ•°ç»„ï¼Œç„¶åå€’åºéå†åŸæ•°ç»„ç»“åˆç´¯åŠ è®¡æ•°æ•°ç»„ åˆ™å¯ä»¥å®ç°æˆç¨³å®šçš„ï¼Œä¸‹é¢ä¼˜åŒ–ç‰ˆæœ¬ç»™å‡ºäº†ä¸€ä¸ªç¨³å®šç‰ˆæœ¬\nä¼˜åŒ– â€‹ åˆ†æ¡¶æ–¹æ³•å¯ä»¥æœ‰å¾ˆå¤šç§ï¼Œæ¯”å¦‚0å·æ¡¶ å­˜æ”¾0-9æ•°æ® 1å·æ¡¶å­˜æ”¾10-19ç­‰ç­‰éƒ½æ˜¯å¯ä»¥çš„ï¼Œæ¯ä¸ªæ¡¶å¯ä»¥å†æ”¾ä¸€ä¸ªæ•°ç»„ ç„¶åå¯¹äºè¿™ä¸ªæ•°ç»„è¿›è¡Œå¿«æ’æˆ–è€…æ’æ’ä¹‹ç±»çš„\nå¦‚æœæŸä¸ªæ¡¶æ•°é‡å¤ªå¤§ï¼Œå¯ä»¥é’ˆå¯¹è¿™ä¸ªæ¡¶ç»§ç»­åˆ†æ¡¶ç­‰ç­‰ è¿™é‡Œä¸å†èµ˜è¿°ï¼Œåç»­æœ‰å…´è¶£å†è¡¥å……ã€‚\nè¿™é‡Œåˆ—å‡ºä¸€ä¸ªç¨³å®šç‰ˆæœ¬çš„è®¡æ•°æ’åº\n CountSortStable\n//CountSortStable æ¡¶æ’åºçš„ä¸€ç§ åº”ç”¨åœºæ™¯ çŸ¥é“ä¸€ä¸ªæ•°ç»„æœ‰Nä¸ªæ•´æ•° å¹¶ä¸”èŒƒå›´éƒ½æ˜¯[0 ,MAX) //ä¹Ÿå°±æ˜¯é‡å¤§ ä½†æ˜¯æ•°æ®èŒƒå›´æ¯”è¾ƒå° ç¨³å®šç‰ˆæœ¬ é‡‡ç”¨ç´¯åŠ è®¡æ•°æ•°ç»„+å€’åºéå†åŸæ•°ç»„ func CountSortStable(a []int, max int) { if len(a) \u0026lt; 2 { return } count := make([]int, max, max) //åˆ›å»ºæ¡¶ for i := 0; i \u0026lt; len(a); i++ { count[a[i]]++ } //ç´¯åŠ è®¡æ•°æ•°ç»„ ä»ä¸‹æ ‡1å¼€å§‹ å…¶å€¼ç­‰äºcount[i]+count[i-1] for i := 1; i \u0026lt; len(count); i++ { count[i] += count[i-1] //è®°å½•åŸæ•°ç»„å…ƒç´ åœ¨åŸæ•°ç»„å‡ºç°çš„æœ€åä¸€ä¸ªä½ç½® } //ç„¶åå€’åºéå†åŸæ•°ç»„ è¿™é‡Œè¦ç”¨åˆ°ä¸€ä¸ªé™„åŠ æ•°ç»„ help := make([]int, len(a), len(a)) for k := len(a) - 1; k \u0026gt;= 0; k-- { count[a[k]]-- lastIndex := count[a[k]] //è¿™é‡Œä¸ºäº†ä»£ç å¥½ç†è§£ å¤šå†™ä¸€è¡Œ help[lastIndex] = a[k] } for i := 0; i \u0026lt; len(help); i++ { a[i] = help[i] } }  \nç½‘æœå›¾è§£ åŸºæ•°æ’åº ä»‹ç» â€‹ åŸºæ•°æ’åºä¹Ÿæ˜¯æ¡¶æ’åºçš„ä¸€ç§ï¼Œä¸»è¦æ€æƒ³æ˜¯æŒ‰ç…§ä½ä¼˜å…ˆçº§å…ˆæ’åº ç„¶åå†æŒ‰ç…§é«˜ä¼˜å…ˆçº§å†æ’åºï¼Œæœ€åå®Œæˆæ’åºã€‚\næ¯”å¦‚æ•´æ•°æ’åºï¼Œå…ˆæŒ‰ç…§ä¸ªä½æ’åºï¼Œå†æŒ‰ç…§åä½æ’åº å†æŒ‰ç…§ç™¾ä½ã€åƒä½æ’åºï¼Œå¯ä»¥å‚çœ‹å›¾è§£ï¼Œæ¯”è¾ƒä¸€ç›®äº†ç„¶\nä»£ç   RadixSort\n//GetMax è¿”å›æ•°ç»„ä¸­çš„æœ€å¤§å€¼ func GetMax(a []int) int { max := a[0] for i := 1; i \u0026lt; len(a); i++ { if a[i] \u0026gt; max { max = a[i] } } return max } //radixSort ä¼ å…¥æŒ‰ç…§ä»€ä¹ˆåŸºæ•°æ’åº 1 ä¸ªä½ 10åä½ 100ç™¾ä½... func radixSort(a []int, radix int) { help := make([]int, len(a), len(a)) //æ— è®ºæ˜¯ä¸ªä½ã€åä½ã€ç™¾ä½... éƒ½åªæœ‰0-9 10ä¸ªæ•°å­— æ‰€ä»¥å‡†å¤‡10ä¸ªæ¡¶ bucket := make([]int, 10, 10) for i := 0; i \u0026lt; len(a); i++ { radixNum := (a[i] / radix) % 10 //å¾—åˆ°æŸä¸ªåŸºæ•°ä½çš„æ•°å­— æ¯”å¦‚345 ä¼ å…¥radixæ˜¯1 ä¹Ÿå°±æ˜¯ä¸ªä½æ•°ä¹Ÿå°±æ˜¯3 bucket[radixNum]++ } //è¿™ä¸ªforå¾ªç¯å®Œæˆ ä¹Ÿå°±å®Œæˆäº†ä¸ªä½æ•°æ¡¶è®¡æ•° æ¯”å¦‚bucket[1]=3 ä¹Ÿå°±æ˜¯ä¸ªä½æ•°æ˜¯1çš„æ•°å­—æœ‰3ä¸ª for j := 1; j \u0026lt; len(bucket); j++ { bucket[j] += bucket[j-1] } //è¿™ä¸ªforå¾ªç¯å®Œæˆ æ¡¶è®¡æ•°å«ä¹‰å‘ç”Ÿæ”¹å˜ bucket[1]=3è¡¨ç¤ºä¸ªä½æ•°\u0026lt;=1çš„æ•°å­—æœ‰3ä¸ª //å€’åºéå†åŸæ•°ç»„ æŒ‰ç…§åŸºæ•°ä½æ’åºåè¾“å‡ºåˆ°è¾…åŠ©æ•°ç»„ for k := len(a) - 1; k \u0026gt;= 0; k-- { bucket[(a[k]/radix)%10]-- help[bucket[(a[k]/radix)%10]] = a[k] } for i := 0; i \u0026lt; len(a); i++ { a[i] = help[i] } } //RadixSort åŸºæ•°æ’åº å…ˆæŒ‰ç…§ä¸ªä½æ’åº å†æŒ‰ç…§10ä½æ’åº å†æŒ‰ç…§ç™¾ä½æ’åº ... func RadixSort(a []int) { max := GetMax(a) for radix := 1; max/radix \u0026gt; 0; radix *= 10 { radixSort(a, radix) //ä¾æ¬¡æŒ‰ç…§ä¸ªä½ åä½ ç™¾ä½ ...æ’åº } }  \næ—¶é—´å¤æ‚åº¦ â€‹ O(X*2N) è¿™é‡Œçš„X ä¸»è¦æ˜¯æŒ‡åˆ†äº†å¤šå°‘ä¸ªåŸºæ•° æ¯”å¦‚ä¸ªä½ã€åä½ã€ç™¾ä½ é‚£X=3 å¯¹äºæ¯ä¸ªåŸºæ•° å†…éƒ¨éƒ½è‡³å°‘éœ€è¦2Nçš„æ—¶é—´å¤æ‚åº¦\nç®—æ³•ç¨³å®šæ€§ â€‹ ä¸Šé¢å®ç°çš„æ˜¯ç¨³å®šçš„ å°±æ˜¯é‡‡ç”¨ç´¯åŠ è®¡æ•° ç„¶åå€’åºéå†æ•°ç»„çš„æ–¹æ³•\nä¼˜åŒ– â€‹ å¾…è¡¥å……\nç½‘æœå›¾è§£ æ¡¶æ’åº ä»‹ç» è®¡æ•°æ’åºå’ŒåŸºæ•°æ’åºæ˜¯æœ€å¸¸è§çš„2ç§æ¡¶æ’åºæ€æƒ³ï¼Œä¸æ˜¯åŸºäºæ¯”è¾ƒçš„æ’åºæ€æƒ³ï¼Œæ¡¶æ’åºçš„å‰æå‡è®¾å¤§è‡´å¦‚ä¸‹ï¼š   å‡è®¾åŸæ•°æ®æ˜¯å¤§å€¼å‡åŒ€åˆ†å¸ƒçš„ é‡ä¹Ÿæ¯”è¾ƒå¤§ åœ¨åŸæ•°æ®ä¸Šå»ºç«‹1ä¸ªå‡½æ•°æ˜ å°„å…³ç³» å°†åŸæ•°æ®æ˜ å°„åˆ°æœ‰é™ä¸ªæ•°çš„æ¡¶ä¸Š ç„¶åé’ˆå¯¹æ¯ä¸ªæ¡¶å†æƒ³åŠæ³•æ’åº(æ¯”å¦‚æ’æ’ã€å¿«æ’ç­‰) æœ€åæŒ‰ç…§æ¡¶é¡ºåºä¾æ¬¡è¾“å‡ºæ¡¶é‡Œçš„å…ƒç´  å°±å®Œæˆäº†æ•´ä¸ªæ’åº  ä»£ç  â€‹ è¿™é‡Œä¸å†™ä»£ç äº†\næ—¶é—´å¤æ‚åº¦ â€‹ å»æ‰å¸¸æ•°é¡¹å°±æ˜¯O(N)\nç®—æ³•ç¨³å®šæ€§ å¯ä»¥åšåˆ°ç¨³å®š\nä¼˜åŒ– å¾…è¡¥å……\nç½‘æœå›¾è§£ å¾…è¡¥å……\n","id":3,"section":"posts","summary":"å†’æ³¡æ’åº ä»‹ç» â€‹ å†’æ³¡æ’åºæ˜¯ä¸€ç§æ¯”è¾ƒç®€å•çš„æ’åºï¼Œä¹‹æ‰€ä»¥å«å†’æ³¡ï¼Œæ˜¯å› ä¸ºåœ¨ä¸¤ä¸¤æ¯”è¾ƒçš„è¿‡ç¨‹ä¸­è¾ƒå¤§çš„æ•°å°±åƒå†’æ³¡ä¸€æ ·è¢«æ¢åˆ°åé¢ã€‚è¯¦ç»†è§£é‡Šï¼šä¾æ¬¡æ¯”è¾ƒç›¸é‚»çš„ä¸¤","tags":["æ•°æ®ç»“æ„","ç®—æ³•","æ’åº"],"title":"æ’åº_æ•°æ®ç»“æ„ä¸ç®—æ³•","uri":"http://heketong.github.io/2020/05/%E6%8E%92%E5%BA%8F_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","year":"2020"}],"tags":[{"title":"marathons","uri":"http://heketong.github.io/tags/marathons/"},{"title":"æ’åº","uri":"http://heketong.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"title":"æ­å»ºåšå®¢","uri":"http://heketong.github.io/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"title":"æ•°æ®ç»“æ„","uri":"http://heketong.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"ç®—æ³•","uri":"http://heketong.github.io/tags/%E7%AE%97%E6%B3%95/"}]}