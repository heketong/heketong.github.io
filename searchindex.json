{"categories":[{"title":"marathons","uri":"http://heketong.github.io/categories/marathons/"},{"title":"sport","uri":"http://heketong.github.io/categories/sport/"},{"title":"技术总结","uri":"http://heketong.github.io/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"posts":[{"content":" 100-Marathons 1 广州花都半马赛事 2019.2.24 ​ 【广州花都摇滚马组委会】祝贺贺 克通 完成2019广州花都摇滚马拉松半程马拉松项目，参赛号：C11949，枪声成绩：02:17:13，净成绩：02:13:56。此成绩仅供参考，最终成绩以组委会发布成绩证书上为准\n2 清远半马赛事 2019 3.17 ​ 【中体体育】祝贺贺克通完成2019时代中国清远马拉松赛 ，项目：半程马拉松，参赛号：C0085 ，枪声成绩：02:13:22 ，净成绩：02:05:10。此成绩仅供参考，解释权归组委会。\n3 韶关全马赛事 2019.11.24 ​ 第一次全马，竟然没收到短信，😓\n4 阳江海陵岛全马赛事 2019.12.29 ​ 【露营之家】恭喜您完成了十八子作·2019阳江海陵岛环岛国际马拉松赛“全程马拉松”，参赛号A0791，枪声成绩05:03:26，净成绩05:03:07。最终解释权归组委会所有。\n疫情影响取消清远全马赛事 2020.3.22 ​ 【清远马拉松】尊敬的贺克通，恭喜您中签2020时代中国清远马拉松，中签结果同步更新在微信公众号第一赛道，请及时关注。感谢您对清马的关注和支持，谢谢！2020.1.13 15:30，2020年太多事情发生，疫情影响，清远赛事取消，昨天看到消息，说癌症患者贺明发现自己病情后，想跑满100场马拉松，看后非常感动，是啊，每个不曾起舞的日子，都是对生命的辜负，癌症患者尚坚持跑了61场马拉松，自己又有什么不能的呢，当然这件事情也让我觉得更要珍惜自己的生命，不要等到事情真到了无可挽回的时候再决定找寻自己的健康，而应该在现在，此时此刻开始，运动起来，享受自己的人生。\n​ 戒烟这个事情反反复复说了太多遍，到现在还是没能如愿以偿，那就从此时此刻开始继续加油吧\n","id":0,"section":"posts","summary":"100-Marathons 1 广州花都半马赛事 2019.2.24 ​ 【广州花都摇滚马组委会】祝贺贺 克通 完成2019广州花都摇滚马拉松半程马拉松项目，参赛号：C11949，枪声成绩：02","tags":["marathons"],"title":"100场马拉松","uri":"http://heketong.github.io/2020/06/marathons/","year":"2020"},{"content":" 搭建hugo静态博客记录 1 安装Hugo 我这里是imac所以就直接用brew 其它操作系统也很简单 百度一下一把\nbrew install hugo  2 初始化站点目录 先cd到你想放置的磁盘目录 然后执行一下命令即可 会在当前目录创建站点名称同名目录\n$ hugo new site blog Congratulations! Your new Hugo site is created in /Users/ketonghe/blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026quot;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026quot; command. 2. Perhaps you want to add some content. You can add single files with \u0026quot;hugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026quot;. 3. Start the built-in live server via \u0026quot;hugo server\u0026quot;. Visit https://gohugo.io/ for quickstart guide and full documentation.  3 安装主题并修改 现在hugo主题商店挺多，我选择了相对干净的hugo-theme-pure 如果没有git环境 可自行百度安装\n$ git clone https://github.com/xiaoheiAh/hugo-theme-pure themes/pure Cloning into 'themes/pure'... remote: Enumerating objects: 13, done. remote: Counting objects: 100% (13/13), done. remote: Compressing objects: 100% (11/11), done. remote: Total 2527 (delta 2), reused 6 (delta 2), pack-reused 2514 Receiving objects: 100% (2527/2527), 4.14 MiB | 519.00 KiB/s, done. Resolving deltas: 100% (1376/1376), done.  config.yml 配置文件主要修改项\nbaseURL 主页 menu 可以将下面的title改为对应的中文 donate 改为自己的微信和支付宝 profile 修改自己头像和介绍  4 写markdown文章 $ hugo new posts/helloworld.md /Users/ketonghe/blog/content/posts/helloworld.md created  用markdown编辑器编辑文章\n5 发布预览 $ hugo server -D | ZH +------------------+----+ Pages | 13 Paginator pages | 0 Non-page files | 0 Static files | 9 Processed images | 0 Aliases | 6 Sitemaps | 1 Cleaned | 0 Total in 91 ms Watching for changes in /Users/ketonghe/blog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /Users/ketonghe/blog/config.yml Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop  接下来就可以在本地浏览器 输入http://localhost:1313/ 访问了\n这个主题支持站内搜索 还不错\n6 添加评论支持 参考 https://www.smslit.top/2018/07/08/hugo-valine/ 一步步来吧\n7 生成静态页面 ","id":1,"section":"posts","summary":"搭建hugo静态博客记录 1 安装Hugo 我这里是imac所以就直接用brew 其它操作系统也很简单 百度一下一把 brew install hugo 2 初始化站点目录 先cd到你想","tags":["搭建博客"],"title":"create_hugo_blog","uri":"http://heketong.github.io/2020/05/create_hugo_blog/","year":"2020"},{"content":" 数组 ​ 数组是一种典型的线形数据结构，特点：存放连续的相同数据类型，随机访问速度比较快。随机添加和删除，需要批量移动元素。主流编程语言基本上自身就提供了数组这种数据结构，所以这里不再练习了，数组访问注意边界，动态数组如果是C需要自己实现，C++/go标准库也都提供了动态数组的实现，可以比较方便的访问。\n链表 介绍 ​ 链表也是一种常用的线形数据结构。特点：空间不是连续的，每个节点除本身数据外，一般都存储至少一个指针数据，指向它的前驱或者后继节点，因为空间不是连续的，所以随机访问效率不高，但是删除，添加效率很高，不需要批量移动元素，这里只简单练习下双向循环链表，单链表更加简单。采用接口的方式实现，练习下go的面向接口编程\n代码  DoublyLinkedList_主要接口及结构体定义 接口用结构体指针实现\n//LinkNoder 链表接口定义 支持相关操作函数定义 type LinkNoder interface { IsEmpty() bool //返回链表释放为空链表 GetSize() int //返回链表长度 Get(index int) *LinkNode //返回下标对应的元素指针 下标从0开始 GetFirst() *LinkNode //返回第一个元素指针 也就是Head GetLast() *LinkNode //返回最后一个元素指针 也就是Tail //在对应下标位置插入元素 成功返回true 失败返回false InsertByIndex(index int, PayLoad interface{}) bool //默认在最后一个节点后面添加 PushBack(PayLoad interface{}) bool //插入到表头位置 PushFront(PayLoad interface{}) bool //释放包含某个元素 包含(true,下标) 不包含 (false,-1) IsContains(PayLoad interface{}) (bool, int, *LinkNode) //按照下标删除元素 返回元素值 DelByIndex(index int) interface{} DelHead() interface{} //删除头节点 DelTail() interface{} //删除尾节点 //按照元素值删除 成功返回true 失败返回false DelByValue(PayLoad interface{}) bool } //LinkNode 链表节点定义 type LinkNode struct { PayLoad interface{} //节点元素 Prev *LinkNode //前一个节点元素指针 Next *LinkNode //后一个节点元素指针 } //DoublyLinkList 双向循环链表定义 type DoublyLinkList struct { Head *LinkNode //双向循环链表头节点指针(这里指向第一个真正的节点 如果为nil 代表双向循环链表为空) Tail *LinkNode //双向循环链表尾部节点指针 Size int //双向循环链表长度 }  \n DoublyLinkedList详细接口方法实现\n//CreateDblist 创建一个空的dblist func CreateDblist() *DoublyLinkList { return \u0026amp;DoublyLinkList{nil, nil, 0} } //DestroyDblist 销毁双向循环链表 func DestroyDblist(dblist *DoublyLinkList) { if dblist.Size == 0 { //如果链表为空直接返回 return } pHead, p := dblist.Head, dblist.Head.Next //pHead指向第一个节点 p指向第一个节点的下一个节点 pHead.Prev, pHead.Next = nil, nil //第一个节点前驱后继都置空 for p != dblist.Head { //遍历将所有节点前驱后继都置空 pNext := p.Next //先记录当前节点的后继 p.Next, p.Prev = nil, nil //当前节点的前驱和后继指针复制为nil 等待gc回收 p = pNext //p指向下一个节点 } } func (dblist *DoublyLinkList) IsEmpty() bool { return dblist.Size == 0 } func (dblist *DoublyLinkList) GetSize() int { return dblist.Size } func (dblist *DoublyLinkList) GetFirst() *LinkNode { return dblist.Head } func (dblist *DoublyLinkList) GetLast() *LinkNode { return dblist.Tail } func (dblist *DoublyLinkList) Get(index int) *LinkNode { if index \u0026lt; 0 || index \u0026gt;= dblist.Size { fmt.Println(\u0026quot;index invalid\u0026quot;) return nil } p, i := dblist.Head, 0 for ; i \u0026lt; index; i++ { p = p.Next } return p } func (dblist *DoublyLinkList) InsertByIndex(index int, PayLoad interface{}) bool { if index \u0026lt; 0 || index \u0026gt;= dblist.Size { fmt.Println(\u0026quot;index invalid\u0026quot;) return false } //构造插入元素节点 cur := LinkNode{PayLoad, nil, nil} //当前链表为空 插入第一个元素 if dblist.Size == 0 \u0026amp;\u0026amp; index == 0 { dblist.Head = \u0026amp;cur dblist.Tail = \u0026amp;cur cur.Prev = \u0026amp;cur cur.Next = \u0026amp;cur dblist.Size++ return true } if index == 0 { //插入到表头 return dblist.PushFront(PayLoad) } if index == dblist.Size-1 { //插入到表尾 return dblist.PushBack(PayLoad) } //当前链表不为空 先得到index下标元素指针 然后插入 if p := dblist.Get(index); p != nil { cur.Prev, cur.Next = p.Prev, p p.Prev.Next = \u0026amp;cur p.Prev = \u0026amp;cur dblist.Size++ return true } fmt.Println(\u0026quot;Get(index) err\u0026quot;) return false } func (dblist *DoublyLinkList) PushBack(PayLoad interface{}) bool { //构造插入元素节点 cur := LinkNode{PayLoad, nil, nil} //当前链表为空 插入第一个元素 if dblist.Size == 0 { dblist.Head = \u0026amp;cur dblist.Tail = \u0026amp;cur cur.Prev = \u0026amp;cur cur.Next = \u0026amp;cur dblist.Size++ return true } cur.Prev, cur.Next = dblist.Tail, dblist.Head dblist.Tail.Next = \u0026amp;cur dblist.Head.Prev = \u0026amp;cur dblist.Tail = \u0026amp;cur dblist.Size++ return true } func (dblist *DoublyLinkList) PushFront(PayLoad interface{}) bool { //构造插入元素节点 cur := LinkNode{PayLoad, nil, nil} //当前链表为空 插入第一个元素 if dblist.Size == 0 { dblist.Head = \u0026amp;cur dblist.Tail = \u0026amp;cur cur.Prev = \u0026amp;cur cur.Next = \u0026amp;cur dblist.Size++ fmt.Println(\u0026quot;dblist.Size=\u0026quot;, dblist.Size) return true } cur.Prev, cur.Next = dblist.Tail, dblist.Head dblist.Head.Prev = \u0026amp;cur dblist.Tail.Next = \u0026amp;cur dblist.Head = \u0026amp;cur dblist.Size++ return true } func (dblist *DoublyLinkList) IsContains(PayLoad interface{}) (bool, int, *LinkNode) { if dblist.Size == 0 { //链表为空 直接返回不存在 return false, -1, nil } for p, i := dblist.Head, 0; i \u0026lt; dblist.Size; p, i = p.Next, i+1 { if p.PayLoad == PayLoad { return true, i, p } } return false, -1, nil } func (dblist *DoublyLinkList) DelHead() interface{} { if dblist.Size == 0 { //链表为空 直接返回不存在 return nil } if dblist.Size == 1 { //如果只有一个元素 删除完链表为空 PayLoad := dblist.Head.PayLoad dblist.Head, dblist.Tail = nil, nil dblist.Size-- return PayLoad } p := dblist.Head p.Next.Prev = dblist.Tail dblist.Tail.Next = p.Next dblist.Head = p.Next p.Prev, p.Next = nil, nil dblist.Size-- return p.PayLoad } func (dblist *DoublyLinkList) DelTail() interface{} { if dblist.Size == 0 { //链表为空 直接返回不存在 return nil } if dblist.Size == 1 { //如果只有一个元素 删除完链表为空 PayLoad := dblist.Tail.PayLoad dblist.Head, dblist.Tail = nil, nil dblist.Size-- return PayLoad } p := dblist.Tail dblist.Head.Prev = dblist.Tail.Prev dblist.Tail.Prev.Next = dblist.Head dblist.Tail = dblist.Tail.Prev p.Prev, p.Next = nil, nil dblist.Size-- return p.PayLoad } func (dblist *DoublyLinkList) DelByIndex(index int) interface{} { if index == 0 { return dblist.DelHead() } if index == (dblist.Size - 1) { return dblist.DelTail() } if p := dblist.Get(index); p != nil { p.Prev.Next = p.Next p.Next.Prev = p.Prev p.Prev, p.Next = nil, nil dblist.Size-- return p.PayLoad } return nil } func (dblist *DoublyLinkList) DelByValue(PayLoad interface{}) bool { _, index, p := dblist.IsContains(PayLoad) if index == 0 { _ = dblist.DelHead() return true } if index == (dblist.Size - 1) { _ = dblist.DelTail() return true } if p != nil { p.Prev.Next = p.Next p.Next.Prev = p.Prev p.Prev, p.Next = nil, nil return true } return false } func (dblist *DoublyLinkList) Print() { fmt.Print(\u0026quot;struct DoublyLinkList[\u0026quot;) for i, p := 0, dblist.Head; i \u0026lt; dblist.Size; i++ { fmt.Print(p.PayLoad) fmt.Print(\u0026quot;,\u0026quot;) p = p.Next } fmt.Print(\u0026quot;]\\n\u0026quot;) }  \n优化 ​ 待补充\n​ 按照下标查找元素可以用二分查找\n网搜图解 ​ 双向循环链表比较简单，很好理解 不再找图了\n栈 介绍 ​ 栈是一种后进先出的数据结构，可以用很多方式实现，因为我之前的双向循环链表已经实现了，所以直接用其实现了\n代码  Stack代码(双向循环链表实现)\n//HCStack 实现的简易栈 采用双向链表实现 type HCStack struct { Stack *doublylinkedlist.DoublyLinkList } //CreateEmptyStack 创建一个空的栈 func CreateEmptyStack() *HCStack { dblist := doublylinkedlist.CreateDblist() return \u0026amp;HCStack{dblist} } //GetSize 获取栈的真实长度 func (hcstack *HCStack) GetSize() int { return hcstack.Stack.GetSize() } //IsEmpty 返回栈是否为空 func (hcstack *HCStack) IsEmpty() bool { return hcstack.Stack.IsEmpty() } //Push 压栈操作 func (hcstack *HCStack) Push(payLoad interface{}) bool { return hcstack.Stack.PushFront(payLoad) } //Pop 出栈操作 func (hcstack *HCStack) Pop() interface{} { if hcstack.Stack.Size == 0 { fmt.Println(\u0026quot;栈为空\u0026quot;) return nil } return hcstack.Stack.DelHead() } //Peek 获取栈顶元素 不删除 func (hcstack *HCStack) Peek() interface{} { if hcstack.Stack.Size == 0 { fmt.Println(\u0026quot;栈为空\u0026quot;) return nil } return hcstack.Stack.GetFirst().PayLoad } //Clear 清空栈 func (hcstack *HCStack) Clear() { doublylinkedlist.DestroyDblist(hcstack.Stack) }  \n队列 介绍 ​ 队列是一种先进先出的数据结构，可以用很多方式实现，因为我之前的双向循环链表已经实现了，所以直接用其实现了\n代码  Queue代码(双向循环链表实现)\n//HCQueue 实现的简易队列 采用双向链表实现 type HCQueue struct { Queue *doublylinkedlist.DoublyLinkList } //CreateEmptyQueue 创建一个空的栈 func CreateEmptyQueue() *HCQueue { dblist := doublylinkedlist.CreateDblist() return \u0026amp;HCQueue{dblist} } //GetSize 获取队列的真实长度 func (hcqueue *HCQueue) GetSize() int { return hcqueue.Queue.Size } //IsEmpty 返回队列是否为空 func (hcqueue *HCQueue) IsEmpty() bool { return hcqueue.Queue.Size == 0 } //Push 入队列操作 func (hcqueue *HCQueue) Push(payLoad interface{}) bool { return hcqueue.Queue.PushBack(payLoad) } //Pop 出队列操作 func (hcqueue *HCQueue) Pop() interface{} { if hcqueue.Queue.Size == 0 { fmt.Println(\u0026quot;Pop 队列为空\u0026quot;) return nil } return hcqueue.Queue.DelHead() } //GetHead 获取队头元素 不删除 func (hcqueue *HCQueue) GetHead() interface{} { if hcqueue.Queue.Size == 0 { fmt.Println(\u0026quot;GetHead 队列为空\u0026quot;) return nil } return hcqueue.Queue.GetFirst().PayLoad } //GetTail 获取队头元素 不删除 func (hcqueue *HCQueue) GetTail() interface{} { if hcqueue.Queue.Size == 0 { fmt.Println(\u0026quot;GetTail 队列为空\u0026quot;) return nil } return hcqueue.Queue.GetLast().PayLoad } //Clear 清空栈 func (hcqueue *HCQueue) Clear() { doublylinkedlist.DestroyDblist(hcqueue.Queue) }  \n二叉树 介绍 ​ 二叉树是每个节点最多有2个子树的树结构，有5种基本形态。\n性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。 性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。 性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。\n性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1) ​ 证明：下面用\u0026rdquo;数学归纳法\u0026rdquo;进行证明。 (01) 当i=1时，第i层的节点数目为2{i-1}=2{0}=1。因为第1层上只有一个根结点，所以命题成立。 (02) 假设当i\u0026gt;1，第i层的节点数目为2{i-1}。这个是根据(01)推断出来的！ ​ 下面根据这个假设，推断出\u0026rdquo;第(i+1)层的节点数目为2{i}\u0026ldquo;即可。 ​ 由于二叉树的每个结点至多有两个孩子，故\u0026rdquo;第(i+1)层上的结点数目\u0026rdquo; 最多是 \u0026ldquo;第i层的结点数目的2倍\u0026rdquo;。即，第(i+1)层上的结点数目最大值=2×2{i-1}=2{i}。 ​ 故假设成立，原命题得证！\n性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1) ​ 证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用\u0026rdquo;性质1\u0026rdquo;可知，深度为k的二叉树的结点数至多为： 20+21+…+2k-1=2k-1 故原命题得证！\n性质3：包含n个结点的二叉树的高度至少为log2 (n+1) ​ 证明：根据\u0026rdquo;性质2\u0026rdquo;可知，高度为h的二叉树最多有2{h}–1个结点。反之，对于包含n个节点的二叉树的高度至少为log2(n+1)。\n性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1 ​ 证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=\u0026ldquo;0度结点数(n0)\u0026rdquo; + \u0026ldquo;1度结点数(n1)\u0026rdquo; + \u0026ldquo;2度结点数(n2)\u0026ldquo;。由此，得到等式一。 (等式一) n=n0+n1+n2 另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。\n​ 故二叉树中的结点总数又可表示为等式二。 (等式二) n=n1+2n2+1 由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！\n满二叉树 ​ 高度为h，并且由2{h} –1个结点的二叉树，被称为满二叉树\n完全二叉树 定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。 特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树\n二叉查找树 ​ 又叫二叉排序树 ,英文一般是binary_search_tree。这里会重点复习下二叉查找树\n 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点（no duplicate nodes）  Binary_Search_Tree 二叉查找树 重要概念介绍  一个节点一般有数据域、左孩子指针，右孩子指针，父节点指针\n 前序遍历\n  先遍历根节点 再遍历左子树 再遍历右子树\n 中序遍历  先遍历左子树 再遍历根节点 再遍历右子树\n 后序遍历  先遍历左子树 再遍历右子树 再遍历根节点\n 前驱节点  小于该节点值中最大的一个节点\n 后继节点  大于该节点值中最小的一个节点\n 插入大概逻辑\n首先要为待插入节点(toIns)找到合适的节点位置，准确来说就是要找到toIns的父节点(parent),然后比较key，判断是左孩子还是右边孩子 if ( 树为空){直接插入，也就是此节点为根节点 }else{ //树不为空 cur=root //当前节点指向根节点 while(cur != null){ parent=cur // toIns的parent也指向当前节点 if (toIns.key\u0026lt;cur.key){ //小于当前节点的值,当前节点变为其左孩子 cur=cur.left } if (toIns.key\u0026gt;cur.key){ //小于当前节点的值，当前节点变为其右孩子 cur=cur.right } if ( key == cur.key ){ return //不允许插入相同节点 } } if toIns.key\u0026lt;parent.key{ parent-\u0026gt;left=toIns }else{ parent-\u0026gt;right=toIns } }  查找前驱节点大概逻辑\npredecessor=null if ( cur.left != null ){//如果左子树不为空 则找左子树上面的最大值 for predecessor=cur.left;predecessor.right!=null;predecessor=predecessor.right{} }else{ if( cur是其父节点的右边孩子){ predecessor=cur.parent //前驱就是其父节点 }elseif (cur是其父节点的左孩子 ){ //找到爷爷 并且其父节点是其爷爷的右孩子 cur.parent.parent!=null \u0026amp;\u0026amp; cur.parent.parent.right==cur.parent predecessor=cur.parent.parent } } return predecessor  查找后继节点大值逻辑\nsuccessor=null if( cur.right != null){//如果右边子树不为空 则找右边子树上面的最小值 for successor=cur.right;successor.left!=null;successor=successor.left{} }else{ if( cur是其父节点的左孩子){ successor=cur.parent //后继就是其父节点 }elseif (cur是其父节点的右孩子 ){ //找到爷爷 并且其父节点是其爷爷的左孩子 cur.parent.parent!=null \u0026amp;\u0026amp; cur.parent.parent.left==cur.parent successor=cur.parent.parent } } return successor  删除节点逻辑\n核心逻辑 删除后不能改变二叉树的特点 if (cur为叶子节点){ cur.parent.(left|right)=null cur.parent=null }elseif ( cur有一个孩子) //将cur的父亲指向其孩子即可 cur.parent.(left|right)=cur.(left|right) cur.(left|right).parent=cur.parent cur.(left|right)=cur.parent=null }elseif (cur有2个孩子){ //找到其后继节点 successor cur.key=successor.key //删除后继节点 successor.parent.(left|right)=null successor.left=successor.right=successor.parent=null }   代码  BinarySearchTree代码实现\n//Less 比较两个元素大小 如果a\u0026lt;b 返回true 负责返回false type Less func(a interface{}, b interface{}) bool //BSTNODE 节点定义 type BSTNODE struct { Key interface{} Left *BSTNODE //左孩子 Right *BSTNODE //右孩子 Parent *BSTNODE //父节点 } //ChildVisitCount 记录某一个节点对应的孩子节点访问次数 用来判断孩子节点是否都访问过了 type ChildVisitCount struct { node *BSTNODE count int } //BSTTREE 二叉搜索树定义 type BSTTREE struct { Root *BSTNODE //根节点 Size int //当前节点数 less Less //比较是否小于函数 调用者可自行实现 } //BSTTreeInterface 二叉搜索树接口定义 type BSTTreeInterface interface { //IsEmpty 判断一个二叉搜索树是否为空 IsEmpty() bool //Insert 插入一个节点 返回是否插入成功 Insert(Key interface{}) bool //SearchKey 查找一个Key是否存在 在则返回其节点地址 不在则返回nil SearchKey(Key interface{}) *BSTNODE //DeleteByNode 删除一个节点 根据传入的节点地址删除 返回是否删除成功 DeleteByNode(cur *BSTNODE) bool //GetMax 得到树的最大值 GetMax() interface{} //GetMin 得到树的最小值 GetMin() interface{} //GetPredecessor 找到当前节点的前驱节点 GetPredecessor(cur *BSTNODE) *BSTNODE //GetSuccessor 找到当前节点的后继节点 GetSuccessor(cur *BSTNODE) *BSTNODE //前序遍历二叉树 打印到屏幕 PreOrder() //中序遍历二叉树 打印到屏幕 InOrder() //后序遍历二叉树 打印到屏幕 PostOrder() //前序遍历二叉树 返回一个slice PreOrderToSlice() []*BSTNODE //中序遍历二叉树 返回一个slice InOrderToSlice() []*BSTNODE //后序遍历二叉树 返回一个slice PostOrderToSlice() []*BSTNODE } //CreateEmptyTree 创建一个空的二叉搜索树 func CreateEmptyTree(less Less) *BSTTREE { return \u0026amp;BSTTREE{nil, 0, less} } //DestroyTree 销毁一个二叉树 前序遍历销毁BST func DestroyTree(tree *BSTTREE) { myStack := stack.CreateEmptyStack() if tree.Size \u0026gt; 0 { myStack.Push(tree.Root) //根节点先压栈 } for myStack.IsEmpty() == false { node := myStack.Pop().(*BSTNODE) //先遍历根节点 if node.Right != nil { myStack.Push(node.Right) //先压右子树 } if node.Left != nil { myStack.Push(node.Left) //再压左子树 } node.Left, node.Right, node.Parent = nil, nil, nil } myStack.Clear() } //CreateBSTree 把接口类型的切片转换为二叉查找树 返回树节点 func CreateBSTree(a []interface{}, less Less) *BSTTREE { tree := \u0026amp;BSTTREE{nil, 0, less} for i := 0; i \u0026lt; len(a); i++ { tree.Insert(a[i]) } return tree } //IsEmpty 判断一个二叉搜索树是否为空 func (tree *BSTTREE) IsEmpty() bool { return tree.Size == 0 } //Insert 插入一个节点 返回是否插入成功 func (tree *BSTTREE) Insert(Key interface{}) bool { toIns := BSTNODE{Key, nil, nil, nil} if tree.Root == nil { //当前树为空 tree.Root = \u0026amp;toIns tree.Size++ return true } //当前树不为空 cur, Parent := tree.Root, tree.Root //Parent指的是待插入节点的父节点 for cur != nil { Parent = cur // toIns的Parent也指向当前节点 if tree.less(toIns.Key, cur.Key) { //小于当前节点的值,当前节点变为其左孩子 cur = cur.Left } else if toIns.Key == cur.Key { return false //不允许插入相同节点 } else { //大于当前节点的值，当前节点变为其右孩子 cur = cur.Right } } tree.Size++ toIns.Parent = Parent if tree.less(toIns.Key, Parent.Key) { Parent.Left = \u0026amp;toIns } else { Parent.Right = \u0026amp;toIns } return true } //SearchKey 查找一个Key是否存在 在则返回其节点地址 不在则返回nil func (tree *BSTTREE) SearchKey(Key interface{}) *BSTNODE { cur := tree.Root for cur != nil \u0026amp;\u0026amp; cur.Key != Key { if tree.less(Key, cur.Key) { cur = cur.Left } else { cur = cur.Right } } return cur } //DeleteByKey 删除一个节点 根据传入的节点Key值删除 返回是否删除成功 func (tree *BSTTREE) DeleteByKey(Key interface{}) bool { node := tree.SearchKey(Key) if node != nil { return tree.DeleteByNode(node) } return false //如果node为空 代表Key不在树种 直接返回false } //DeleteByNode 删除一个节点 根据传入的节点地址删除 返回是否删除成功 func (tree *BSTTREE) DeleteByNode(delNode *BSTNODE) bool { if delNode != nil { if delNode.Left == nil { //如果其左子树为空 则用其右孩子替换被删除节点即可 当然如果右孩子是空 也就是纯叶子节点 直接删除即可 fmt.Println(\u0026quot;删除节点左子树为空\u0026quot;) tree.replaceNode(delNode, delNode.Right) } else if delNode.Right == nil { //如果其右子树为空 则用其左孩子替换被删除节点即可 fmt.Println(\u0026quot;删除节点右子树为空\u0026quot;) tree.replaceNode(delNode, delNode.Left) } else { fmt.Println(\u0026quot;删除节点左右子树都非空\u0026quot;) //左右子树都非空 这个时候就找到其后继节点 然后替换 succssor := tree.GetSuccessor(delNode) if succssor.Parent != delNode { //后继节点不是其右孩子(其右孩子还有左子树) fmt.Println(\u0026quot;后继节点的父亲节点不是删除节点\u0026quot;) //拿后继节点右孩子替换后继节点 也就是后继节点父节点的左孩子 变为后继节点的右孩子 tree.replaceNode(succssor, succssor.Right) succssor.Right = delNode.Right //更新后继节点的右孩子 指向被删除节点的右孩子 delNode.Right.Parent = succssor //同时更新被删除节点右孩子的的Parent属性 } tree.replaceNode(delNode, succssor) //拿后继节点替换被删除节点 succssor.Left = delNode.Left //后继节点的左孩子 指向被删除节点的左孩子 delNode.Left.Parent = succssor //同时更新被删除节点左孩子的Parent属性 } tree.Size-- delNode.Parent, delNode.Left, delNode.Right = nil, nil, nil //等待gc回收 return true } return false } //replaceNode 用newNode替换nodeToRepalce节点 func (tree *BSTTREE) replaceNode(nodeToReplace *BSTNODE, newNode *BSTNODE) *BSTNODE { if nodeToReplace.Parent == nil { //如果被替换的是根节点 则更新根节点指向新的节点 tree.Root = newNode } else if nodeToReplace == nodeToReplace.Parent.Left { //如果被替换节点是其父节点的左孩子 则将其父节点的左孩子指向新的节点 nodeToReplace.Parent.Left = newNode } else { //如果被替换节点是其父节点的右孩子 则将其父节点的右孩子指向新的节点 nodeToReplace.Parent.Right = newNode } if newNode != nil { //如果新的节点非空 则更改其父节点为被替换节点的父节点 newNode.Parent = nodeToReplace.Parent } return newNode } //GetMax 得到树的最大值 func (tree *BSTTREE) GetMax() interface{} { maxNode := tree.Root for ; maxNode.Right != nil; maxNode = maxNode.Right { } if maxNode != nil { return maxNode.Key } return nil } //GetMin 得到树的最小值 func (tree *BSTTREE) GetMin() interface{} { minNode := tree.Root for ; minNode.Left != nil; minNode = minNode.Left { } if minNode != nil { return minNode.Key } return nil } //GetPredecessor 找到当前节点的前驱节点 func (tree *BSTTREE) GetPredecessor(cur *BSTNODE) *BSTNODE { var predecessor *BSTNODE = nil if cur.Left != nil { //如果左子树不为空 则找左子树上面的最大值 for predecessor = cur.Left; predecessor.Right != nil; predecessor = predecessor.Right { } } else { if cur.Parent != nil \u0026amp;\u0026amp; cur == cur.Parent.Right { //cur是其父节点的右边孩子 前驱就是其父节点 predecessor = cur.Parent } else if cur.Parent != nil \u0026amp;\u0026amp; cur == cur.Parent.Left { // cur是其父节点的左孩子 找到爷爷 并且其父节点是其爷爷的右孩子 if cur.Parent.Parent != nil \u0026amp;\u0026amp; cur.Parent.Parent.Right == cur.Parent { predecessor = cur.Parent.Parent } } } return predecessor } //GetSuccessor 找到当前节点的后继节点 func (tree *BSTTREE) GetSuccessor(cur *BSTNODE) *BSTNODE { var successor *BSTNODE = nil if cur.Right != nil { //如果右边子树不为空 则找右边子树上面的最小值 for successor = cur.Right; successor.Left != nil; successor = successor.Left { } } else { if cur.Parent != nil \u0026amp;\u0026amp; cur.Parent.Left == cur { // cur是其父节点的左孩子 cur是其父节点的左孩子 successor = cur.Parent } else if cur.Parent != nil \u0026amp;\u0026amp; cur.Parent.Right == cur { //cur是其父节点的右孩子 找到爷爷 并且其父节点是其爷爷的左孩子 if cur.Parent.Parent != nil \u0026amp;\u0026amp; cur.Parent.Parent.Left == cur.Parent { successor = cur.Parent.Parent } } } return successor } //PreOrder 前序遍历二叉树 打印到屏幕 func (tree *BSTTREE) PreOrder() { a := tree.PreOrderToSlice() fmt.Print(\u0026quot;BSTTreePreOrder[\u0026quot;) for i := 0; i \u0026lt; len(a); i++ { fmt.Print(a[i].Key) if i == len(a)-1 { fmt.Print(\u0026quot;]\\n\u0026quot;) } else { fmt.Print(\u0026quot;,\u0026quot;) } } } //InOrder 中序遍历二叉树 打印到屏幕 func (tree *BSTTREE) InOrder() { a := tree.InOrderToSlice() fmt.Print(\u0026quot;BSTTreeInOrder[\u0026quot;) for i := 0; i \u0026lt; len(a); i++ { fmt.Print(a[i].Key) if i == len(a)-1 { fmt.Print(\u0026quot;]\\n\u0026quot;) } else { fmt.Print(\u0026quot;,\u0026quot;) } } } //PostOrder 后序遍历二叉树 打印到屏幕 func (tree *BSTTREE) PostOrder() { a := tree.PostOrderToSlice() fmt.Print(\u0026quot;BSTTreePostOrder[\u0026quot;) for i := 0; i \u0026lt; len(a); i++ { fmt.Print(a[i].Key) if i == len(a)-1 { fmt.Print(\u0026quot;]\\n\u0026quot;) } else { fmt.Print(\u0026quot;,\u0026quot;) } } } //PreOrderToSlice 前序遍历二叉树 根、左子树、右子树 返回一个slice func (tree *BSTTREE) PreOrderToSlice() []*BSTNODE { if tree.Size == 0 { return nil } a := make([]*BSTNODE, tree.Size) myStack := stack.CreateEmptyStack() myStack.Push(tree.Root) //根节点先压栈 for i := 0; myStack.IsEmpty() == false; { a[i] = myStack.Pop().(*BSTNODE) //先遍历根节点 if a[i].Right != nil { myStack.Push(a[i].Right) //先压右子树 } if a[i].Left != nil { myStack.Push(a[i].Left) //再压左子树 } i++ } myStack.Clear() return a } //InOrderToSlice 中序遍历二叉树 左子树、根、右子树 返回一个slice func (tree *BSTTREE) InOrderToSlice() []*BSTNODE { if tree.Size == 0 { return nil } a := make([]*BSTNODE, tree.Size, tree.Size) myStack := stack.CreateEmptyStack() //先将根节点及其左孩子一条线全部入栈 栈顶最后就是最左的节点 for p := tree.Root; p != nil; p = p.Left { myStack.Push(p) } for i := 0; myStack.IsEmpty() == false; { a[i] = myStack.Pop().(*BSTNODE) //最左边的节点直接出栈 而且其没有左孩子 if i \u0026gt; 0 \u0026amp;\u0026amp; tree.less(a[i], a[i-1]) { panic(\u0026quot;二叉查找树不正确\u0026quot;) } for p := a[i].Right; p != nil; p = p.Left { //将其右孩子及右孩子的左孩子一条线 全部入栈 myStack.Push(p) } i++ } myStack.Clear() return a } //isChildAllVisited 判断当前节点的孩子节点是否都已经访问过了 func isChildAllVisited(p *BSTNODE, visit map[*BSTNODE]int) bool { if p == nil { panic(\u0026quot;in isChildAllVisited input *BSTNODE is nil\u0026quot;) } childCount := 0 if p.Left != nil { childCount++ } if p.Right != nil { childCount++ } if childCount == 0 { //如果没有孩子 直接返回true return true } if childVisitCount, ok := visit[p]; ok { if childCount == childVisitCount { //所有孩子节点都已经访问过了 delete(visit, p) return true } return false } else { return false //孩子还没有被访问过 } } //PostOrderToSlice 后序遍历二叉树 左子树、右子树、根 返回一个slice func (tree *BSTTREE) PostOrderToSlice() []*BSTNODE { if tree.Size == 0 { return nil } visit := make(map[*BSTNODE]int) //记录某个节点的孩子节点访问次数 a := make([]*BSTNODE, tree.Size) myStack := stack.CreateEmptyStack() myStack.Push(tree.Root) for i := 0; myStack.IsEmpty() == false; { p := myStack.Peek().(*BSTNODE) //当前节点可以理解为根 if isChildAllVisited(p, visit) { //如果当前栈顶节点对应的孩子都已经访问过了 那就出栈 a[i] = myStack.Pop().(*BSTNODE) //fmt.Println(\u0026quot;节点:\u0026quot;, a[i].Key, \u0026quot; 左右孩子都已经访问过了 已经出栈 当前数组下标为:\u0026quot;, i) visit[a[i].Parent]++ i++ continue } if p.Right != nil { //将右孩子压栈 //fmt.Println(\u0026quot;当前栈顶是:\u0026quot;, p.Key, \u0026quot; 左右孩子尚未访问完成 不出栈，压入右孩子:\u0026quot;, p.Right.Key) myStack.Push(p.Right) } if p.Left != nil { //将左孩子压栈 //fmt.Println(\u0026quot;当前栈顶是:\u0026quot;, p.Key, \u0026quot; 左右孩子尚未访问完成 不出栈，压入左孩子:\u0026quot;, p.Left.Key) myStack.Push(p.Left) } } myStack.Clear() return a }  \n​ 其中中序遍历添加了判断是否递增，如果不是递增 则会报错\n 判断是否是一个BST二叉搜索树\n//ISBSTRET 判断是否是BST的返回值 type ISBSTRET struct { isBST bool //是否是BST minValNode *BSTNODE //当前树的最小值节点 maxValNode *BSTNODE //当前树的最大值节点 } //ISBST 判断当前树是否为BST树 外部使用 func ISBST(node *BSTNODE, less Less) bool { ret := isAnBinarySearchTree(node, less) return ret.isBST } //isAnBinarySearchTree 判断当前树是否为BST树 内部使用 func isAnBinarySearchTree(node *BSTNODE, less Less) ISBSTRET { if node == nil { return ISBSTRET{true, nil, nil} } retLeft, retRight := isAnBinarySearchTree(node.Left, less), isAnBinarySearchTree(node.Right, less) if retLeft.isBST \u0026amp;\u0026amp; retRight.isBST \u0026amp;\u0026amp; (retLeft.maxValNode == nil || less(retLeft.maxValNode.Key, node.Key)) \u0026amp;\u0026amp; (retRight.minValNode == nil || less(node.Key, retRight.minValNode.Key)) { ret := ISBSTRET{true, nil, nil} if retLeft.minValNode == nil { ret.minValNode = node } else { ret.minValNode = retLeft.minValNode //当前树的最小值节点赋值为左子树的最小值 } if retRight.maxValNode == nil { ret.maxValNode = node } else { ret.maxValNode = retRight.maxValNode //当前树的最大值节点赋值为右子树的最大值 } return ret } else { fmt.Println(\u0026quot;key=\u0026quot;, node.Key, \u0026quot; 不是BST\u0026quot;) if retLeft.isBST == false { fmt.Println(\u0026quot;原因:其左子树不是BST\u0026quot;) } if retRight.isBST == false { fmt.Println(\u0026quot;原因:其右子树不是BST\u0026quot;) } if retLeft.maxValNode != nil \u0026amp;\u0026amp; less(retLeft.maxValNode.Key, node.Key) == false { fmt.Println(\u0026quot;原因:其左子树存在比其大的节点:\u0026quot;, retLeft.maxValNode.Key) } if retRight.minValNode != nil \u0026amp;\u0026amp; less(node.Key, retRight.minValNode.Key) == false { fmt.Println(\u0026quot;原因:其右子树存在比其小的节点:\u0026quot;, retRight.minValNode.Key) } return ISBSTRET{false, nil, nil} } }  \nAVLTree 严格平衡二叉树 介绍 ​ AVL树是根据它的发明者G.M. Adelson-Velsky和E.M. Landis命名的。\n它是最先发明的自平衡二叉查找树，也被称为高度平衡树。相比于\u0026rdquo;二叉查找树\u0026rdquo;，它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。\n为什么要有AVL树，因为普通的二叉查找树有可能出现长斜树的情况，最快的情况直接是一棵线形的树，比如依次插入54321，所以这个时候查找的性能大幅下降，不能达到logN,而下降为N，所以才有了AVL，AVL查找的性能达到logN，多付出的代价是插入或者删除的时候要维持平衡，所以需要旋转。\n各种旋转示意图 LL旋转实现逻辑 g为待插入节点(红色部分)的爷爷节点 这个节点的平衡性受到破坏 p待插入节点的父节点，同时是爷爷节点的左孩子\n//LLRotation LL旋转 旋转一次即可 func (tree *AvlTree) LLRotation(g *AvlTreeNode) { p := g.Left gOldParent := g.Parent pOldRight := p.Right g.Left = pOldRight p.Right = g //更新相关节点的Parent属性 如果不想要Parent属性 则下面Parent相关代码可以删除 if pOldRight != nil { pOldRight.Parent = g } if g == tree.Root { //g为根节点 tree.Root = p } else { //g非根节点 if g == gOldParent.Left { gOldParent.Left = p } else { gOldParent.Right = p } } p.Parent = gOldParent g.Parent = p //更新g和p的高度 updateHeight(g) updateHeight(p) return p }  RR旋转实现逻辑 g为待插入节点(红色部分)的爷爷节点 这个节点的平衡性受到破坏 p待插入节点的父节点，同时是爷爷节点的右边\n//RRRotation RR旋转 旋转一次即可 func (tree *AvlTree) RRRotation(g *AvlTreeNode) { p := g.Right //调整节点左右孩子指向 完成旋转 gOldParent := g.Parent pOldLeft := p.Left g.Right = pOldLeft p.Left = g //更新相关节点的Parent属性 如果不想要Parent属性 则下面Parent相关代码可以删除 if pOldLeft != nil { pOldLeft.Parent = g } if g == tree.Root { //g为根节点 tree.Root = p } else { //g非根节点 if g == gOldParent.Left { gOldParent.Left = p } else { gOldParent.Right = p } } p.Parent = gOldParent g.Parent = p //更新g和p的高度 updateHeight(g) updateHeight(p) return p }  LR旋转实现逻辑 g为待插入节点(红色部分)的爷爷节点 这个节点的平衡性受到破坏 p待插入节点的父节点，同时是爷爷节点的左孩子\n这种情况要经过2次旋转 先对p节点RR旋转 再对g节点LL旋转\n//LRRotation 2次旋转 先对p节点RR旋转 再对g节点LL旋转 func (tree *AvlTree) LRRotation(g *AvlTreeNode) { g.Left=tree.RRRotation(g.Left) return tree.LLRotation(g) }  RL旋转实现逻辑 g为待插入节点(红色部分)的爷爷节点 这个节点的平衡性受到破坏 p待插入节点的父节点，同时是爷爷节点的右孩子\n这种情况要经过2次旋转 先对p节点LL旋转 再对g节点RR旋转\n//RLRotation 2次旋转 先对p节点LL旋转 再对g节点RR旋转 func (tree *AvlTree) RLRotation(g *AvlTreeNode) { g.Right=tree.LLRotation(g.Right) return tree.RRRotation(g) }  插入代码 ​ 这里先像BST一样先插入，然后针对插入的节点就行平衡性检查和调整 关键就是rebalance函数\n AvlTree插入代码\n//Insert 插入一个节点 返回插入节点的地址 func (tree *AvlTree) Insert(Key interface{}) *AvlTreeNode { newNode := tree.insertAsBST(Key) //先像BST树一样插入 然后网上逐个判断是否打破平衡因子 做适当调整 if newNode != nil { tree.rebalance(newNode) //调整平衡性 } return newNode } //rebalance 针对一个节点以及所有父辈节点进行平衡性判断与调整 func (tree *AvlTree) rebalance(node *AvlTreeNode) { for node != nil { hLeft, hRight := Height(node.Left), Height(node.Right) if hLeft-hRight == 2 { //左子树比右子树高 可能是LL或者LR if node.Left.Left != nil { // fmt.Println(\u0026quot;节点\u0026quot;, node.Key, \u0026quot;LL旋转\u0026quot;) tree.LLRotation(node) //LL break } else { // fmt.Println(\u0026quot;节点\u0026quot;, node.Key, \u0026quot;LR旋转\u0026quot;) tree.LRRotation(node) //LR break } } else if hLeft-hRight == -2 { if node.Right.Right != nil { // fmt.Println(\u0026quot;节点\u0026quot;, node.Key, \u0026quot;RR旋转\u0026quot;) tree.RRRotation(node) //RR break } else { // fmt.Println(\u0026quot;节点\u0026quot;, node.Key, \u0026quot;RL旋转\u0026quot;) tree.RLRotation(node) //RL break } } else { // fmt.Println(node.Key, \u0026quot;没有打破平衡\u0026quot;) updateHeight(node) //没有打破平衡也要更新其高度 } node = node.Parent //逐层往上对每个父辈节点都做判断调整处理 } } func updateHeight(node *AvlTreeNode) { if node == nil { return } hleft, hright := Height(node.Left), Height(node.Right) node.Height = Max(hleft, hright) + 1 }  \n删除代码 这里也是先像BST一样删除，只不过要返回删除后需要重新调整的节点起始位置(其父辈节点 全部高度都要变更，同时做平衡性检查和旋转)\n用到的rebalance函数个插入用到的函数一样\n AvlTree删除代码\n//DeleteByKey 删除一个节点 根据传入的节点值删除 返回是否删除成功 func (tree *AvlTree) DeleteByKey(Key interface{}) bool { var delNode *AvlTreeNode = tree.SearchKey(Key) if delNode != nil { node := tree.deleteByNodeAsBST(delNode) //这里node为需要重新调整高度的起始节点 其父辈都要调整 tree.recomputeHeight(node) tree.rebalance(node) return true } return false } //deleteByNodeAsBST 删除一个节点 根据传入的节点地址删除 返回删除后需要调整高度的第一个节点 其父辈节点都要更新高度 func (tree *AvlTree) deleteByNodeAsBST(delNode *AvlTreeNode) *AvlTreeNode { if delNode != nil { var retNode *AvlTreeNode = nil if delNode.Left == nil { //如果其左子树为空 则用其右孩子替换被删除节点即可 当然如果右孩子是空 也就是纯叶子节点 直接删除即可 // fmt.Println(\u0026quot;删除节点左子树为空\u0026quot;) tree.replaceNode(delNode, delNode.Right) //这种情况 被删除节点父辈节点都要调整高度 retNode = delNode.Parent } else if delNode.Right == nil { //如果其右子树为空 则用其左孩子替换被删除节点即可 // fmt.Println(\u0026quot;删除节点右子树为空\u0026quot;) tree.replaceNode(delNode, delNode.Left) //这种情况 被删除节点父辈节点都要调整高度 retNode = delNode.Parent } else { // fmt.Println(\u0026quot;删除节点左右子树都非空\u0026quot;) //左右子树都非空 这个时候就找到其后继节点 然后替换 succssor := tree.GetSuccessor(delNode) retNode = succssor.Parent //因为后继节点发生变化 if succssor.Parent != delNode { //后继节点不是其右孩子(其右孩子还有左子树) // fmt.Println(\u0026quot;后继节点的父亲节点不是删除节点\u0026quot;) //拿后继节点右孩子替换后继节点 也就是后继节点父节点的左孩子 变为后继节点的右孩子 tree.replaceNode(succssor, succssor.Right) succssor.Right = delNode.Right //更新后继节点的右孩子 指向被删除节点的右孩子 delNode.Right.Parent = succssor //同时更新被删除节点右孩子的的Parent属性 } tree.replaceNode(delNode, succssor) //拿后继节点替换被删除节点 succssor.Left = delNode.Left //后继节点的左孩子 指向被删除节点的左孩子 delNode.Left.Parent = succssor //同时更新被删除节点左孩子的Parent属性 } tree.Size-- delNode.Parent, delNode.Left, delNode.Right = nil, nil, nil //等待gc回收 return retNode } return nil } //recomputeHeight 节点和其父辈节点全部重新计算高度 func (tree *AvlTree) recomputeHeight(node *AvlTreeNode) { for node != nil { node.Height = Max(Height(node.Left), Height(node.Right)) + 1 node = node.Parent } }  \n 判断一个树是否为AVL\n//ISAVL 判断当前树是否为AVL树 外部使用 func ISAVL(node *AvlTreeNode, less Less) bool { ret := isAnAvlTree(node, less) return ret.isAVL } //isAnAvlTree 判断当前树是否为BST树 内部使用 func isAnAvlTree(node *AvlTreeNode, less Less) ISAVLRET { if node == nil { return ISAVLRET{true, nil, nil, 0} } retLeft, retRight := isAnAvlTree(node.Left, less), isAnAvlTree(node.Right, less) if retLeft.isAVL \u0026amp;\u0026amp; retRight.isAVL \u0026amp;\u0026amp; (retLeft.maxValNode == nil || less(retLeft.maxValNode.Key, node.Key)) \u0026amp;\u0026amp; (retRight.minValNode == nil || less(node.Key, retRight.minValNode.Key)) \u0026amp;\u0026amp; ABS(retLeft.height-retRight.height) \u0026lt;= 1 { ret := ISAVLRET{true, nil, nil, Max(retLeft.height, retRight.height) + 1} if retLeft.minValNode == nil { ret.minValNode = node } else { ret.minValNode = retLeft.minValNode //当前树的最小值节点赋值为左子树的最小值 } if retRight.maxValNode == nil { ret.maxValNode = node } else { ret.maxValNode = retRight.maxValNode //当前树的最大值节点赋值为右子树的最大值 } return ret } else { fmt.Println(\u0026quot;key=\u0026quot;, node.Key, \u0026quot; 不是AVL\u0026quot;) if retLeft.isAVL == false { fmt.Println(\u0026quot;原因:其左子树不是AVL\u0026quot;) } if retRight.isAVL == false { fmt.Println(\u0026quot;原因:其右子树不是AVL\u0026quot;) } if retLeft.maxValNode != nil \u0026amp;\u0026amp; less(retLeft.maxValNode.Key, node.Key) == false { fmt.Println(\u0026quot;原因:不是BST 其左子树存在比其大的节点:\u0026quot;, retLeft.maxValNode.Key) } if retRight.minValNode != nil \u0026amp;\u0026amp; less(node.Key, retRight.minValNode.Key) == false { fmt.Println(\u0026quot;原因:不是BST 其右子树存在比其小的节点:\u0026quot;, retRight.minValNode.Key) } if ABS(retLeft.height-retRight.height) \u0026gt; 1 { fmt.Println(\u0026quot;原因左右子树高度差大于1,左子树高度:\u0026quot;, retLeft.height, \u0026quot; 右子树高度:\u0026quot;, retRight.height) } return ISAVLRET{false, nil, nil, Max(retLeft.height, retRight.height) + 1} } }  \nRedBalckTree红黑树 介绍 红黑树也是二叉搜索树，也是为了高速查找才发明的，也是为了避免出现二叉搜索树的线形情况，所以想点办法让树尽量平衡，但又不像AVL树那样严格平衡，因为如果要严格平衡，则意味着很有可能随时随地都要调整树，要不断的旋转，这样也会浪费性能，红黑树是一种相对平衡的二叉查找树，有以下特点：\n 所有节点都是红色或者黑色 根节点为黑色 所有的 NULL 叶子节点都是黑色 如果该节点是红色的，那么该节点的子节点一定都是黑色 所有的 NULL 节点到根节点的路径上的黑色节点数量一定是相同的  红黑树保证了最长路径长度不会是最短路径长度的2倍 是一种相对平衡的二叉搜索树\n插入 ​ 插入相对于删除还是比较简单的 ，还是首先像BST一样插入，然后从插入节点(下面代码记为x)开始做变色和旋转处理，大值的逻辑如下：\n1 x.Color=Red //新插入是红色会较大概率不破坏红黑树的特性 2 while( x.Parent.Color==Red){//如果其父亲节点是黑色节点 不会破坏红黑树的性质 之然什么都不用做 直接插入即可 p,g,u:=x.Parent,x.Parent.Parent,getUncle(x) if getColor(u)==Red{// UncleRed_case p.Color,u.Color,g.Color=Balck,Black,Red//父节点 叔叔节点变黑色 爷爷节点变红色 x=g//x变为其爷爷节点 继续判断 }else{//叔叔节点为空也是黑色 if p==g.Left \u0026amp;\u0026amp; x==p.Left{//UncleBlack_LeftLeft_case p.Color,g.Color=Black,Red LLRotation(g) }else if p==g.Left \u0026amp;\u0026amp; x==p.Right{//UncleBlack_LeftRight_case RRRotation(p)//旋转后 x,p亲子关系调换 将p看作新插入节点 x是其父亲 又蜕变成为 Uncle Black LeftLeft case 代码有些许重复但逻辑更清晰 x,p=p,x p.Color,g.Color=Black,Red LLRotation(g) }else if p==g.Right \u0026amp;\u0026amp; x=p.Right{ //UncleBlack_RightRight_case p.Color,g.Color=Black,Red RRRotation(g) }else if p==g.Right \u0026amp;\u0026amp; x==p.Left{UncleBlack_RightLeft_case LLRotation(p)//旋转后 x,p亲子关系调换 将p看作新插入节点 x是其父亲 又蜕变成为 Uncle Black RightRight case 代码有些许重复但逻辑更清晰 x,p=p,x p.Color,g.Color=Black,Red LLRotation(g) } } } 3 Root.Color=Black//将树的根节点染为黑色  插入代码  红黑树插入代码\n//Insert 插入一个节点 返回插入节点的地址 func (tree *RBTree) Insert(Key interface{}) *RBTreeNode { newNode := tree.insertAsBST(Key) //先像BST树一样插入 if newNode != nil { tree.insertFixUp(newNode) //插入节点后调整 } return newNode } //insertFixUp 插入节点后进行颜色调整及旋转相关处理 func (tree *RBTree) insertFixUp(node *RBTreeNode) { // fmt.Println(\u0026quot;insertFixUp 当前插入节点为:\u0026quot;, node.Key, \u0026quot;Color:\u0026quot;, node.Color) for node != tree.Root \u0026amp;\u0026amp; node.Parent.Color == Red { //如果其父亲节点是黑色节点 不会破坏红黑树的性质 之然什么都不用做 直接插入即可 p, g, u := node.Parent, node.Parent.Parent, getUncle(node) if getColor(u) == Red { // UncleRed_case p.Color, u.Color, g.Color = Black, Black, Red //父节点 叔叔节点变黑色 爷爷节点变红色 node = g //x变为其爷爷节点 继续判断 } else { //叔叔节点为空也是黑色 if p == g.Left \u0026amp;\u0026amp; node == p.Left { //UncleBlack_LeftLeft_case p.Color, g.Color = Black, Red tree.LLRotation(g) } else if p == g.Left \u0026amp;\u0026amp; node == p.Right { //UncleBlack_LeftRight_case tree.RRRotation(p) //旋转后 x,p亲子关系调换 将p看作新插入节点 x是其父亲 又蜕变成为 Uncle Black LeftLeft case 代码有些许重复但逻辑更清晰 node, p = p, node p.Color, g.Color = Black, Red tree.LLRotation(g) } else if p == g.Right \u0026amp;\u0026amp; node == p.Right { //UncleBlack_RightRight_case p.Color, g.Color = Black, Red tree.RRRotation(g) } else if p == g.Right \u0026amp;\u0026amp; node == p.Left { //UncleBlack_RightLeft_case tree.LLRotation(p) //旋转后 x,p亲子关系调换 将p看作新插入节点 x是其父亲 又蜕变成为 Uncle Black RightRight case 代码有些许重复但逻辑更清晰 node, p = p, node p.Color, g.Color = Black, Red tree.RRRotation(g) } } } if tree.Root == node { //如果插入或者调整后当前节点是根节点 则将其置为黑色 node.Color = Black } }  \n删除 ​ 删除根插入比较相对复杂，但无非也是穷举的过程\n删除的节点只能存在三种情况： caseA:被删除节点是叶子节点(如图中的1,3,5,7,9){ A1:如果叶子节点是红色的，直接删除即可，无需修复 不会破坏红黑树特性 A2:如果叶子节点是黑色，删除后会破坏特性5 需要修复 } caseB:被删除节点只有一个孩子(如图中的10){ p为被删除节点 parent,c为其孩子节点 child B1:p为黑色,c为红色 {//如图中的10和9 删除10节点 交换p和c的值，然后将删除节点改为c,因为是红色，变成了A1，直接删除即可，不论孩子是左孩子还是右孩子都是一样的 } B2:p为黑色,c为黑色{ 交换p和c的值，然后将删除节点改为c,也就变成了A2的情况 } } caseC:被删除节点有2个孩子{//如图中的2,4,6,8 找到被删除节点的后继节点，然后交换被删除节点和其后继节点的值 然后将删除节点改为其后继节点(要么是叶子节点 对应caseA,要么是只有右孩子 对应caseB) } 综合上面的情况 caseC可以转化为caseB,caseB又可以转为为caseA A1情况可以直接删除，所以只有A2需要重点关注，当然也是最复杂的。很多穷举情况，上网找了一张图应该是比较全面的，也比较好理解，多看几遍就记住了。  删除代码  红黑树删除核心代码\n//DeleteByKey 删除一个节点 根据传入的节点值删除 返回是否删除成功 func (tree *RBTree) DeleteByKey(Key interface{}) bool { var delNode *RBTreeNode = tree.SearchKey(Key) //先找到被删除的节点 if delNode != nil { if delNode.Left == nil \u0026amp;\u0026amp; delNode.Right == nil { //caseA:被删除节点是叶子节点 return tree.delLeafNode(delNode) } else if delNode.Right == nil || delNode.Left == nil { //caseB:被删除节点只有一个孩子 return tree.delNodeHasOneChild(delNode) } else { //caseC:被删除节点有2个孩子 return tree.delNodeTwoOneChild(delNode) } } return false } //delLeafNode 删除叶子节点 对应删除的caseA:被删除节点是叶子节点 func (tree *RBTree) delLeafNode(delNode *RBTreeNode) bool { if delNode.Color == Red { //A1:如果叶子节点是红色的，直接删除即可，无需修复 不会破坏红黑树特性 p := delNode.Parent //肯定有父节点 因为只有根节点没有父节点 但根节点是黑色 if delNode == p.Left { p.Left = nil } else { p.Right = nil } tree.Size-- } else { //A2:如果叶子节点是黑色，删除后会破坏特性5 需要修复 tree.delBlackLeafFixUp(delNode) } return true } //delNodeHasOneChild 删除只有一个孩子节点的情况 对应caseB:被删除节点只有一个孩子 func (tree *RBTree) delNodeHasOneChild(delNode *RBTreeNode) bool { c := delNode.Left //c指向其孩子节点 if c == nil { c = delNode.Right } if delNode.Color == Black \u0026amp;\u0026amp; c.Color == Red { //B1:p为黑色,c为红色 交换p和c的值，然后将删除节点改为c,因为是红色，变成了A1，直接删除即可 delNode.Key, c.Key = c.Key, delNode.Key delNode.Left, delNode.Right = nil, nil //删除其孩子节点 c.Left, c.Right, c.Parent = nil, nil, nil } else if c.Color == Black { //B2:p为黑色或者红色,c为黑色 交换p和c的值，然后将删除节点改为c,也就变成了A2的情况 delNode.Key, c.Key = c.Key, delNode.Key tree.delBlackLeafFixUp(c) } tree.Size-- return true } //delNodeTwoOneChild 删除节点有2个孩子的情况 对应caseC:被删除节点有2个孩子 func (tree *RBTree) delNodeTwoOneChild(delNode *RBTreeNode) bool { //找到被删除节点的后继节点，然后交换被删除节点和其后继节点的值 然后将删除节点改为其后继节点(要么是叶子节点 对应caseA,要么是只有右孩子 对应caseB) successor := tree.GetSuccessor(delNode) delNode.Key, successor.Key = successor.Key, delNode.Key if successor.Right != nil { //后继节点右孩子不为空 左孩子肯定为空 蜕变为caseB return tree.delNodeHasOneChild(successor) } //后继节点为叶子节点 蜕变为caseA return tree.delLeafNode(successor) } //删除黑色叶子节点并调整 返回删除节点的位置 func (tree *RBTree) delBlackLeafFixUp(delNode *RBTreeNode) { oldDeleteNode := delNode //记录传入的节点 因为case4会改变其值 等调整完毕 再将其父节点指向它的指针改为nil 交给gc回收 tree.Size-- if delNode == tree.Root { //如果被删除节点是root节点 而且是叶子节点 说明整个树只剩下1个root节点了 直接删除即可 tree.Root = nil } else { for delNode != tree.Root \u0026amp;\u0026amp; delNode.Color == Black { p, b := delNode.Parent, getBrother(delNode) if delNode == p.Left { //当前节点是左节点 if b.Color == Red { //case5 : 如果该兄弟节点是红色的，那么根据红黑树的特性可以得出它的一定有两个黑色的子节点 b.Color, p.Color = Black, Red tree.RRRotation(p) } else { if b.Right != nil \u0026amp;\u0026amp; b.Right.Color == Red { //case1和case3 //对应case1 : 兄弟节点是黑色的，且有一个右节点（可以断定 右节点是红色的 //也对应case3 : 兄弟节点是黑色的，且有两个节点（可以断定 左右节点都是红色的）这两种情况一样 b.Color, p.Color = p.Color, b.Color //交换兄弟节点和父节点的颜色 b.Right.Color = Black tree.RRRotation(p) break } else if b.Left != nil \u0026amp;\u0026amp; b.Left.Color == Red { //case2 //对应case2: 兄弟节点是黑色的，且有一个左节点（可以断定 左节点是红色的） b.Left.Color, b.Color = Black, Red tree.LLRotation(b) //经过LL旋转也就是右旋 就蜕变为了case1 } else { //case4:兄弟节点是黑色的，且没有红色子节点 b.Color = Red if p.Color == Red { //将父节点直接染黑就结束了 也就是相当于父子颜色交换 黑色节点个数不变 p.Color = Black break } else { delNode = p //将删除节点改为其父亲节点 递归,直到遇到根节点 或者其父亲节点是红色的 } } } } else { //当前节点是右孩子 if b.Color == Red { //case5: 如果该兄弟节点是红色的，那么根据红黑树的特性可以得出它的一定有两个黑色的子节点 b.Color, p.Color = Black, Red tree.LLRotation(p) } else { if b.Left != nil \u0026amp;\u0026amp; b.Left.Color == Red { //case1和case3 //对应case1 : 兄弟节点是黑色的，且有一个右节点（可以断定 右节点是红色的 //也对应case3 : 兄弟节点是黑色的，且有两个节点（可以断定 左右节点都是红色的）这两种情况一样 b.Color = p.Color p.Color, b.Left.Color = Black, Black tree.LLRotation(p) break } else if b.Right != nil \u0026amp;\u0026amp; b.Right.Color == Red { //case2 //对应case2: 兄弟节点是黑色的，且有一个左节点（可以断定 左节点是红色的） b.Right.Color, b.Color = Black, Red tree.RRRotation(b) //经过RR旋转也就是右旋 就蜕变为了case1 } else { //case4:兄弟节点是黑色的，且没有红色子节点 b.Color = Red if p.Color == Red { //将父节点直接染黑就结束了 也就是相当于父子颜色交换 黑色节点个数不变 p.Color = Black break } else { delNode = p //将删除节点改为其父亲节点 递归,直到遇到根节点 或者其父亲节点是红色的 } } } } } } //颜色调整和旋转完毕 将oldDeleteNode对应父节点指向它的指针改为nil 等待gc回收 if oldDeleteNode == oldDeleteNode.Parent.Left { oldDeleteNode.Parent.Left = nil } else { oldDeleteNode.Parent.Right = nil } }  \n判断是否是红黑树  检查一个树是否是红黑树\n//ISRBTRET 判断是否是RBT的返回值 type ISRBTRET struct { ISRBT bool //是否是RBT minValNode *RBTreeNode //当前树的最小值节点 maxValNode *RBTreeNode //当前树的最大值节点 BlackCount int //左右子树路径的黑色节点个数这里应该相同 否则就不是红黑树 } //ISRBT 判断当前树是否为AVL树 外部使用 func ISRBT(node *RBTreeNode, less Less) bool { if node == nil { return true } if node.Color == Red { return false } ret := isAnRBTree(node, less) return ret.ISRBT } //isAnRBTree 判断当前树是否为BST树 内部使用 func isAnRBTree(node *RBTreeNode, less Less) ISRBTRET { if node == nil { return ISRBTRET{true, nil, nil, 0} } if node.Color == Red \u0026amp;\u0026amp; (getColor(node.Left) == Red || getColor(node.Right) == Red) { fmt.Println(\u0026quot;不是RBT 原因是节点:\u0026quot;, node.Key, \u0026quot; 颜色为红,其子节点还有红色\u0026quot;) if getColor(node.Left) == Red { fmt.Println(\u0026quot;左孩子为红色:\u0026quot;, node.Left.Key) } if getColor(node.Right) == Red { fmt.Println(\u0026quot;右孩子为红色:\u0026quot;, node.Right.Key) } return ISRBTRET{false, nil, nil, 0} } retLeft, retRight := isAnRBTree(node.Left, less), isAnRBTree(node.Right, less) if retLeft.ISRBT \u0026amp;\u0026amp; retRight.ISRBT \u0026amp;\u0026amp; (retLeft.maxValNode == nil || less(retLeft.maxValNode.Key, node.Key)) \u0026amp;\u0026amp; (retRight.minValNode == nil || less(node.Key, retRight.minValNode.Key)) \u0026amp;\u0026amp; retLeft.BlackCount == retRight.BlackCount { blackCount := retLeft.BlackCount if node.Color == Black { //如果当前节点是黑色 黑色节点数量加一 blackCount++ } ret := ISRBTRET{true, nil, nil, blackCount} if retLeft.minValNode == nil { ret.minValNode = node } else { ret.minValNode = retLeft.minValNode //当前树的最小值节点赋值为左子树的最小值 } if retRight.maxValNode == nil { ret.maxValNode = node } else { ret.maxValNode = retRight.maxValNode //当前树的最大值节点赋值为右子树的最大值 } return ret } else { fmt.Println(\u0026quot;key=\u0026quot;, node.Key, \u0026quot; 不是RBT\u0026quot;) if retLeft.ISRBT == false { fmt.Println(\u0026quot;原因:其左子树不是RBT\u0026quot;) } if retRight.ISRBT == false { fmt.Println(\u0026quot;原因:其右子树不是RBT\u0026quot;) } if retLeft.maxValNode != nil \u0026amp;\u0026amp; less(retLeft.maxValNode.Key, node.Key) == false { fmt.Println(\u0026quot;原因:不是BST 其左子树存在比其大的节点:\u0026quot;, retLeft.maxValNode.Key) } if retRight.minValNode != nil \u0026amp;\u0026amp; less(node.Key, retRight.minValNode.Key) == false { fmt.Println(\u0026quot;原因:不是BST 其右子树存在比其小的节点:\u0026quot;, retRight.minValNode.Key) } if retLeft.BlackCount != retRight.BlackCount { fmt.Println(\u0026quot;原因左右子树黑色节点个数不相等,左子树黑节点个数:\u0026quot;, retLeft.BlackCount, \u0026quot; 右子树黑节点个数:\u0026quot;, retRight.BlackCount) } return ISRBTRET{false, nil, nil, -1} } }  \n从上到下按照层次 从左到右按照顺序打印红黑树 红色节点打印红色  逐层，每层从左到右形象化打印红黑树\n//PrintVisually 逐层打印 方向 从左往右形象化更直观的打印二叉树 func (tree *RBTree) PrintVisually() { if tree.Size == 0 { return } nilNode := \u0026amp;RBTreeNode{nil, nil, nil, nil, false} //定义一个空节点 depth := getMaxDepth(tree.Root) //最深层次 // fmt.Println(\u0026quot;depth=\u0026quot;, depth) //申请2个队列 从1个队列出队 同时将其左右子树依次入队到另外一个队列 myQueue1, myQueue2 := queue.CreateEmptyQueue(), queue.CreateEmptyQueue() myQueue1.Push(tree.Root) //根节点先入队列1 //终止条件 最大层次打印完毕 for i, cur, next := 1, myQueue1, myQueue2; i \u0026lt;= depth; i, cur, next = i+1, next, cur { count := 1 //标记打印当前层次的第几个元素 tabCount := (1\u0026lt;\u0026lt;(depth+1-i) - 1) / 2 //打印元素 计算打印前面\\t个数 for cur.IsEmpty() == false { //队列1不为空 if count \u0026gt; 1 { tabCount = (1\u0026lt;\u0026lt;(depth+1-i) - 1) } node := cur.Pop().(*RBTreeNode) if node != nilNode { //不是空节点 //将其左右孩子入到下一层队列 for j := 0; j \u0026lt; tabCount; j++ { fmt.Print(\u0026quot; \u0026quot;) } if node.Color == Red { fmt.Print(redBg, node.Key, reset) } else { fmt.Print(node.Key) } count++ if node.Left != nil { next.Push(node.Left) } else { next.Push(nilNode) //加入一个空节点 为了打印好看 } if node.Right != nil { next.Push(node.Right) } else { next.Push(nilNode) //加入一个空节点 为了打印好看 } } else { //空节点 for j := 0; j \u0026lt; tabCount; j++ { fmt.Print(\u0026quot; \u0026quot;) } fmt.Print(\u0026quot;*\u0026quot;) count++ next.Push(nilNode) //加入一个空节点 为了打印好看 next.Push(nilNode) //加入一个空节点 为了打印好看 } } fmt.Print(\u0026quot;\\n\u0026quot;) } myQueue1.Clear() myQueue2.Clear() }  \nB树 待补充 B+树 待补充 ","id":2,"section":"posts","summary":"数组 ​ 数组是一种典型的线形数据结构，特点：存放连续的相同数据类型，随机访问速度比较快。随机添加和删除，需要批量移动元素。主流编程语言基本上自","tags":["数据结构"],"title":"常用数据结构","uri":"http://heketong.github.io/2020/05/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","year":"2020"},{"content":" 冒泡排序 介绍 ​ 冒泡排序是一种比较简单的排序，之所以叫冒泡，是因为在两两比较的过程中较大的数就像冒泡一样被换到后面。详细解释：依次比较相邻的两个数，前面的数大于后面的数，则交换，将较大的数挪动到后面\n 第1轮: 比较1 \u0026ndash; N 经过依次相邻两两比较交换 最大的数则放到了最后 第2轮: 比较1 \u0026ndash;N-1 经过依次相邻两两比较交换 第2大的数则放到了N-1的位置 第N-1轮:比较1 \u0026ndash; 2 前2个数两两比较交换 整个过程完成  代码  BubbleSort\nfunc BubbleSort(a []int) { if len(a) \u0026lt; 2 { //一个数或者为空 不用排序 return } //外层循环控控制每轮循环两两比较的最大下标 第1次为N-1 最后一次为1(也就是最前面的2个元素) for endPos := len(a) - 1; endPos \u0026gt; 0; endPos-- { //内层循环完成两两比较交换 for i := 0; i \u0026lt; endPos; i++ { if a[i] \u0026gt; a[i+1] { a[i], a[i+1] = a[i+1], a[i] } } } }  \n时间复杂度 ​ O($N^2$)\n稳定性 ​ 稳定 因为如果2个数相等 则他们的相对位置 并没有发生改变\n优化 ​ 看内层循环 如果并没有发生数据交换 则证明所有数据已经排序完成，这个时候直接结束即可 加一个标志判断即可\n BubbleSortOpt\nfunc BubbleSort(a []int) { if len(a) \u0026lt; 2 { //一个数或者为空 不用排序 return } isChg := false //外层循环控控制每轮循环两两比较的最大下标 第1次为N-1 最后一次为1(也就是最前面的2个元素) for endPos := len(a) - 1; endPos \u0026gt; 0; endPos-- { //内层循环完成两两比较交换 for i := 0; i \u0026lt; endPos; i++ { if a[i] \u0026gt; a[i+1] { a[i], a[i+1] = a[i+1], a[i] isChg = true } } if !isChg { //如果内层循环没有发生数据交换 则表明所有数据都已经排序完成 直接退出循环即可 break } } }  \n网搜图解 ​ 摘自: https://www.cnblogs.com/onepixel/p/7674659.html\n插入排序 介绍 ​ 插入排序顾名思义就是将一个待排序的元素，插入到一组已经排好序的元素中，如果形象比喻下，可以想象一下打牌，拿起来第一张牌自然就是排好序的，拿起第二张则跟第一张进行比较，插入到合适的位置。接下来拿第三张 跟前面2张已经排好序的比较，插入合适的位置，依次类推，拿完所有的牌，顺序自然也排好了。\n​ 将待排序的元素分为有序区和无序区，按照顺序每次从无序区拿一个元素，插入插入到有序区，直到所有无序区的元素都插入有序区，整个排序过程结束。第一次有序区为第1个元素，无序区为第2\u0026mdash;N个元素，拿出第2个元素插入到有序区。\n代码  InsertSort\nfunc InsertSort(a []int) { if len(a) \u0026lt; 2 { //一个数或者为空 不用排序 return } //j为无序区的第一个元素 对应下标从1开始，每次后移一个位置 for j := 1; j \u0026lt; len(a); j++ { //内层循环完成比较插入 倒序依次跟有序区的元素进行比较，如果小于有序区的元素 则交换 for i := j; i \u0026gt; 0; i-- { if a[i] \u0026lt; a[i-1] { a[i], a[i-1] = a[i-1], a[i] } } } }  \n时间复杂度 ​ O($N^2$)\n算法稳定性 ​ 稳定 没有改变两个相等元素的相对位置\n优化 ​ 上面代码内层循环在查找待插入位置时是倒序逐个比较的，在查找待插入位置时候是可以优化的，采用二分查找可以有效减少比较次数，但优化后的插入算法则变为不稳定的\n InsertSortOpt\n//BinSerachInsertIndex 二分查找在a数组 begin到end区间 key元素的插入位置 func BinSerachInsertIndex(a []int, begin int, end int, key int) int { pos := -1 //需要插入的位置 for begin \u0026lt;= end { mid := begin + (end-begin)/2 if a[mid] == key { //如果等于key 则找到位置 pos = mid + 1 break } else if a[mid] \u0026lt; key { begin = mid + 1 } else { end = mid - 1 } } if pos == -1 { pos = begin } return pos } func InsertSortOpt(a []int) { if len(a) \u0026lt; 2 { //一个数或者为空 不用排序 return } for j := 1; j \u0026lt; len(a); j++ { begin, end, key := 0, j-1, a[j] //找到插入的位置 pos := BinSerachInsertIndex(a, begin, end, key) //将pos到end区间的元素逐个后移 for index := j; index \u0026gt; pos; index-- { a[index] = a[index-1] } //插入待排序元素 a[pos] = key } }  \n网搜图解 ​ 摘自:https://www.cnblogs.com/onepixel/p/7674659.html\n归并排序 介绍 ​ MergeSort 合并两个有序的序列为1的大的有序的序列，最典型的归并排序可以分2个大的步骤：\n1 采用递归思想 将一个大的序列:二分为大致平均的子序列，然后针对每个子序列都再递归二分(最后每个子序列长度都为1)\n2 两两子序列合并为有序序列 直到所有子序列合并完成\n​ 整体归并排序也用到了很重要的分治思想，也就是将大的问题分为小的问题 逐个解决\n代码  MergeSort\nfunc MergeSort(a []int, left int, right int) { //校验 if len(a) \u0026lt; 2 || left \u0026lt; 0 || right \u0026gt; len(a) || left \u0026gt;= right { return } mid := left + (right-left)/2 //数组中间位置 MergeSort(a, left, mid) //左边归并排序 MergeSort(a, mid+1, right) //右边递归排序 MergeSlice(a, left, mid, right) //合并2个子序列为大的有序序列 } func MergeSlice(a []int, left int, mid int, right int) { //先生成1个辅助空间 长度 容量都是right-left+1 help := make([]int, right-left+1, right-left+1) helpIndex := 0 //help数组起始位置 填入一个数值 往后移动一位 //定义2个下标 开始分别指向2个子区间的最开始位置 然后逐个遍历 LIndex := left RIndex := mid + 1 for LIndex \u0026lt;= mid \u0026amp;\u0026amp; RIndex \u0026lt;= right { if a[LIndex] \u0026lt;= a[RIndex] { //左边区间数值较小 左边进辅助空间 help[helpIndex] = a[LIndex] LIndex++ } else { help[helpIndex] = a[RIndex] RIndex++ } helpIndex++ //不管左边区间进辅助还是右边区间 辅助数组下标下移一个位置 因为必定进了一个数 } for LIndex \u0026lt;= mid { //如果遍历完成 左边区间还有数没放进辅助数组 那就说明剩下的左边区间数较大 依次cp进辅助 help[helpIndex] = a[LIndex] LIndex++ helpIndex++ } for RIndex \u0026lt;= right { //如果遍历完成 左边区间还有数没放进辅助数组 那就说明剩下的左边区间数较大 依次cp进辅助 help[helpIndex] = a[RIndex] RIndex++ helpIndex++ } //辅助空间已经排好序 覆盖填回原数组 for i := 0; i \u0026lt; helpIndex; i++ { a[left+i] = help[i] } }  \n时间复杂度 ​ O( NLogN)\n算法稳定性 ​ 稳定\n优化 规模较小的时候 不用归并，改为插排 ​ 递归其实非常消耗性能 规模较小的时候可以不再递归 较少递归调用次数\n MergeSortOpt\nfunc MergeSortOpt(a []int, left int, right int) { //一个数 为空 下标不合法 拆分完成 if len(a) \u0026lt; 2 || left \u0026lt; 0 || right \u0026gt; len(a) || left \u0026gt;= right { return } if left+20 \u0026gt;= right {//这里增加几行代码 规模较小 改为插排 InsertSort(a[left : right+1]) return } mid := left + (right-left)/2 //数组中间位置 MergeSort(a, left, mid) //左边归并排序 MergeSort(a, mid+1, right) //右边递归排序 MergeSlice(a, left, mid, right) //合并2个子序列为大的有序序列 }  \n检查合并前两个数组是否已经有序 没有必要再调用合并了  MergeSortOpt2\nfunc MergeSortOpt2(a []int, left int, right int) { //一个数 为空 下标不合法 拆分完成 if len(a) \u0026lt; 2 || left \u0026lt; 0 || right \u0026gt; len(a) || left \u0026gt;= right { return } if left+20 \u0026gt;= right {//这里增加几行代码 规模较小 改为插排 InsertSort(a[left : right+1]) return } mid := left + (right-left)/2 //数组中间位置 MergeSort(a, left, mid) //左边归并排序 MergeSort(a, mid+1, right) //右边递归排序 if a[mid]\u0026lt;=a[mid+1]{//如果2个子序列本身已经有序 无需再合并 return } MergeSlice(a, left, mid, right) //合并2个子序列为大的有序序列 }  \n网搜图解 选择排序 介绍 ​ 每轮都选择一个极值(最大或者最小)放到数组的某一端，其实也是分为有序区和无序区，刚开始全是无序区，\n第1轮 遍历N个数 挑选极值放到数组最左侧 有序区有1个数\n第2轮 遍历剩下的N-1个数，挑选极值放入数组第2个位置，也就是依次放入有序区\n\u0026hellip;\n直到剩下最后一个元素 这个元素自然是整个数组的极值 整个数组排序完成\n代码  SelectSort\nfunc SelectSort(a []int) { if len(a) \u0026lt; 2 { //一个数或者为空 不用排序 return } for j := 0; j \u0026lt; len(a)-1; j++ {//控制每轮循环 遍历比较的元素个数 min := j\t//min记录最小元素下标 for i := j + 1; i \u0026lt; len(a); i++ { if a[min] \u0026gt; a[i] { min = i } } a[j], a[min] = a[min], a[j] //将最小元素依次放入有序区 } }  \n时间复杂度 ​ O($N^2$)\n算法稳定性 ​ 不稳定 会改变两个相等元素本身的相对位置 如 (7) 2 4 8 3 4 [7] 1 第一轮下来(7)会跑到最后\n优化 ​ 修改内层循环，每一轮遍历 不仅找到最小下标 也要找到最大下标 最小放数组左边，最大放数组右边，减少循环次数，当然外层循环条件也要修改，最开始无序区为整个数组 每一轮下来 数组两端2个元素变为有序，有序区从两端往中间扩大，直到所有元素都为有序  SelectSortOpt\nfunc SelectSortOPT(a []int) { if len(a) \u0026lt; 2 { //一个数或者为空 不用排序 return } //刚开始left right分别为数组最小和最大下标 每轮循环left和rignt分别放置最小和最大值 //终止条件为left==right 每轮循环后left右移 right左移 for left, right := 0, len(a)-1; left \u0026lt; right; left, right = left+1, right-1 { minIndex, maxIndex := left, right for i := left; i \u0026lt;= right; i++ { if a[i] \u0026lt; a[minIndex] { //找到最小值下标 minIndex = i } if a[i] \u0026gt; a[maxIndex] { //找到最大值下标 maxIndex = i } } a[left], a[minIndex] = a[minIndex], a[left]//最小的放当前无序区最左边 if left == maxIndex { //如最大下标就是刚开始的最小下标 因为已经交换到了minIndex位置 所以最大下标也要跟着修改 maxIndex = minIndex } a[maxIndex], a[right] = a[right], a[maxIndex]//最大值放到当前无序区最右边 } }  \n网搜图解 ​ 摘自： https://www.cnblogs.com/onepixel/p/7674659.html\n堆排序 介绍 二叉堆介绍 堆排序是借助堆这种数据结构进行排序，又分为最大堆和最小堆。堆也分很多种，这里用二叉堆，下面从网上找到的2张图展示下最大堆和最小堆。\n​ 最大堆 所有父节点都\u0026gt;=两个子节点 最小堆 所有父节点都\u0026lt;=两个子节点\n​ 最大堆 可用于升序排序 最小堆可用于降序排序\n​ 二叉堆实现方式不止一种，这里选择最简单的数组实现，下图展示二叉堆如何用数组存放以及父子节点关系如何对应到数组下标关系。\n堆排序大致过程  首选遍历数组 构建二叉堆(数组实现)\n 交换堆头尾两个元素，也就是数组头尾元素，最大值放到了数组最后一个元素。因为根节点发生变化\n  所以重新堆化，范围不包括最后一个元素，最后一个元素相当于已经输出排序完成，为最大值。\n 对于重新堆化的前面N-1个元素 循环执行第2步 直到输出所有堆节点 完成最终排序  代码 最大堆  MaxHeapSort\nfunc MaxHeapSort(a []int) { size:=len(a)//数组长度 if size \u0026lt; 2 { return } for i := 0; i \u0026lt; len(a); i++ {//遍历数组 构建堆 MaxHeapInsert(a, i) } for size \u0026gt; 0 { a[0], a[size-1] = a[size-1], a[0] //将当前堆顶也就是最大值放到最后 把最后的元素换到堆顶 然后重塑堆 size-- MaxHeapify(a, 0, size) } } func MaxHeapInsert(a []int, index int) { //如果插入节点大于父节点 则需要向上调整 先跟父节点交换 然后再比较上面的父节点 for parentIndex := (index - 1) / 2; a[index] \u0026gt; a[parentIndex]; index, parentIndex = parentIndex, (index-1)/2 { a[index], a[parentIndex] = a[parentIndex], a[index] } } //大堆 重新堆化过程 func MaxHeapify(a []int, index int, size int) { for maxIndex := -1; maxIndex != index; { maxIndex = index leftIndex := 2*index + 1 rightIndex := 2*index + 2 //求当前节点 左孩子 右孩子中最大值对应的下标 if leftIndex \u0026lt; size \u0026amp;\u0026amp; a[maxIndex] \u0026lt; a[leftIndex] { maxIndex = leftIndex } if rightIndex \u0026lt; size \u0026amp;\u0026amp; a[maxIndex] \u0026lt; a[rightIndex] { maxIndex = rightIndex } if maxIndex != index { a[index], a[maxIndex] = a[maxIndex], a[index] //跟左孩子、右孩子中最大的交换 index = maxIndex maxIndex = -1 } } }  \n最小堆  MinHeapSort\nfunc MinHeapSort(a []int) { if len(a) \u0026lt; 2 { return } for i := 0; i \u0026lt; len(a); i++ { MinHeapInsert(a, i) } size := len(a) for size \u0026gt; 0 { a[0], a[size-1] = a[size-1], a[0] //将当前堆顶也就是最大值放到最后 把最后的元素换到堆顶 然后重塑堆 size-- MinHeapify(a, 0, size) } } //MinHeapInsert 创建大堆 数组实现 index为要插入的元素下标 //节点下标为i 对应左孩子为2*i+1 右边孩子为2*i+2 //节点下标为i 对应父节点为(i-1)/2 func MinHeapInsert(a []int, index int) { parentIndex := (index - 1) / 2 for a[index] \u0026lt; a[parentIndex] { //如果插入节点小于父节点 则需要向上调整 先跟父节点交换 然后再比较上面的父节点 a[index], a[parentIndex] = a[parentIndex], a[index] index = parentIndex parentIndex = (index - 1) / 2 } } //MinHeapify 下标index发生了变化 重塑堆 一路向下调整 如果两个孩子中有一个比自己小 则交换 然后继续往下调整找到比自己小的孩子 然后跟其交换 //节点下标为i 对应左孩子为2*i+1 右边孩子为2*i+2 //节点下标为i 对应父节点为(i-1)/2 func MinHeapify(a []int, index int, size int) { for minIndex := -1; minIndex != index; { minIndex = index leftIndex := 2*index + 1 rightIndex := 2*index + 2 //求当前节点 左孩子 右孩子中最小值对应的下标 if leftIndex \u0026lt; size \u0026amp;\u0026amp; a[minIndex] \u0026gt; a[leftIndex] { minIndex = leftIndex } if rightIndex \u0026lt; size \u0026amp;\u0026amp; a[minIndex] \u0026gt; a[rightIndex] { minIndex = rightIndex } if minIndex != index { a[index], a[minIndex] = a[minIndex], a[index] //跟左孩子、右孩子中最小的交换 index = minIndex minIndex = -1 } } }  \n时间复杂度 ​ O(NlogN)\n算法稳定性 ​ 不稳定\n优化 ​ 当前实现的就是原地堆排序，没有使用额外的辅助空间，暂无好的优化思路，待补充\n网搜图解 希尔排序 介绍 ​ 希尔排序是直接插入排序的优化版本，由一个叫shell的人提出来的，核心思想是按照步长分组，然后每组分组插排，然后缩短步长分组，继续每组插排，最后步长为1，变为直接插排。\n​ 关于步长及缩短步长如何选择，有很多种方案，可以直接分半，然后再除以2 最后为1，这里采用的Knuth序列，也就是按照下面的规律递增\ngap=1\u0026mdash;\u0026ndash;\u0026gt;\u0026gt;gap=3*gap+1\n代码  ShellSort\nfunc ShellSort(a []int) { //步长采用knuth序列 变化规律为 h=1 ---\u0026gt; h = 3*h+1 h := 1 for h \u0026lt;= len(a)/3 { h = 3*h + 1 } //控制gap递减 最后变为1 for gap := h; gap \u0026gt; 0; gap = (gap - 1) / 3 { //控制分组 for j := gap; j \u0026lt; len(a); j++ { //每组进行直接插排 for i := j; i \u0026gt; gap-1; i = i - gap { if a[i] \u0026lt; a[i-gap] { a[i], a[i-gap] = a[i-gap], a[i] } } } } }  \n时间复杂度 O($N^3\u0026frasl;2$)\n算法稳定性 ​ 不稳定\n优化 ​ 待补充\n网搜图解 快速排序 介绍 ​ 快速排序主要用到了分治和递归思想，跟归并排序差不多，快速排序一般要选择一个基准值(pivot),然后将小于这个基准的放左边，大于这个基准的放右边，基准值放那边无所谓，这样一轮下来，数组分成了2个区域，左边区域比右边区域小，然后对2个区域用递归的方法继续快排。\n​ 这里的快速用荷兰国旗问题分成了3个区域，pivot 然后递归 pivot的区域 继续分区快排序\n​ 关于基准值的选取可以有很多种，可以随机选取，可以最前面的，可以最后面的，这里采用的是最常见(选取最末端元素)\n代码  QuickSort\nfunc QuickSort(a []int, left int, right int) { if len(a) \u0026lt; 2 || left \u0026gt;= right { return } base := a[right] //基准选取最末端元素 equalArea := PartitionIntSlice(a, left, right, base) QuickSort(a, left, equalArea[0]-1) //递归快排小于区间 QuickSort(a, equalArea[1]+1, right) //递归快排大于区间 } //PartitionIntSlice 给定一个数组，左边界left 右边界right 比较基准base //返回一个2个数值的int数组 该数组第一个值为等于base的开始位置 第二个值为等于base的结束位置 //所以下标小于该数组第一个值的区间都小于base 下标大于数组第二个值的区间都大于base func PartitionIntSlice(a []int, left int, right int, base int) [2]int { l := left - 1 //l为小于区间的结束下标 刚开始指向最小下标左边 r := right + 1 //l为大于区间的开始下标 刚开始指向最大下标右边 cur := left //当前遍历的数设置为整个区间最左边 for cur \u0026lt; r { if a[cur] \u0026lt; base { //如果当前数小于基数 当前数和小于区间的下一个数交换 小于区间扩一个 a[cur], a[l+1] = a[l+1], a[cur] l++ cur++ } else if a[cur] \u0026gt; base { //如果当前数大于基数 则cur下标++ a[cur], a[r-1] = a[r-1], a[cur] r-- } else { //当前数跟基数相等 不变 cur++ } } return [2]int{l + 1, r - 1} }  \n时间复杂度 ​ O(NlogN)\n算法稳定性 ​ 不稳定\n优化 ​ 可以选择双轴快排序，也就是选择2个base(不相同,相同的话就又变成了荷兰国旗) 分区为 maxbase\n代码后续补充\n网搜图解 计数排序 介绍 ​ 计数排序的应用场景比较清晰，也是桶排序的一种。明确的知道一个数组有N的整数，量比较大，但是数据范围比较小 都是[0,MAX), 然后创建一个计数数组，长度为MAX,计数数组值都初始化为0，然后遍历原数组，将原数组的值和计数数组的下标对应起来，比如原数组某个元素值为1，则计数数组下标为1的元素加1，表示1的元素出现过一次，这个步骤可以叫做入桶。然后顺序遍历计数数组，如果该下标的元素出现过(也就是值\u0026gt;0)，数组元素值为多少，则该下标出桶多少次，依次填回原数组即可。\n​\n代码  CountingSort\nfunc CountSort(a []int, max int) { if len(a) \u0026lt; 2 { return } count := make([]int, max, max) //创建计数的桶 for i := 0; i \u0026lt; len(a); i++ { count[a[i]]++ } indexOfa := 0 for i := 0; i \u0026lt; len(count); i++ { for count[i] \u0026gt; 0 { a[indexOfa] = i indexOfa++ count[i]-- } } }  \n时间复杂度 O(N)\n算法稳定性 ​ 直接计数排序本身是不稳定的，如果采用累加计数数组，然后倒序遍历原数组结合累加计数数组 则可以实现成稳定的，下面优化版本给出了一个稳定版本\n优化 ​ 分桶方法可以有很多种，比如0号桶 存放0-9数据 1号桶存放10-19等等都是可以的，每个桶可以再放一个数组 然后对于这个数组进行快排或者插排之类的\n如果某个桶数量太大，可以针对这个桶继续分桶等等 这里不再赘述，后续有兴趣再补充。\n这里列出一个稳定版本的计数排序\n CountSortStable\n//CountSortStable 桶排序的一种 应用场景 知道一个数组有N个整数 并且范围都是[0 ,MAX) //也就是量大 但是数据范围比较小 稳定版本 采用累加计数数组+倒序遍历原数组 func CountSortStable(a []int, max int) { if len(a) \u0026lt; 2 { return } count := make([]int, max, max) //创建桶 for i := 0; i \u0026lt; len(a); i++ { count[a[i]]++ } //累加计数数组 从下标1开始 其值等于count[i]+count[i-1] for i := 1; i \u0026lt; len(count); i++ { count[i] += count[i-1] //记录原数组元素在原数组出现的最后一个位置 } //然后倒序遍历原数组 这里要用到一个附加数组 help := make([]int, len(a), len(a)) for k := len(a) - 1; k \u0026gt;= 0; k-- { count[a[k]]-- lastIndex := count[a[k]] //这里为了代码好理解 多写一行 help[lastIndex] = a[k] } for i := 0; i \u0026lt; len(help); i++ { a[i] = help[i] } }  \n网搜图解 基数排序 介绍 ​ 基数排序也是桶排序的一种，主要思想是按照低优先级先排序 然后再按照高优先级再排序，最后完成排序。\n比如整数排序，先按照个位排序，再按照十位排序 再按照百位、千位排序，可以参看图解，比较一目了然\n代码  RadixSort\n//GetMax 返回数组中的最大值 func GetMax(a []int) int { max := a[0] for i := 1; i \u0026lt; len(a); i++ { if a[i] \u0026gt; max { max = a[i] } } return max } //radixSort 传入按照什么基数排序 1 个位 10十位 100百位... func radixSort(a []int, radix int) { help := make([]int, len(a), len(a)) //无论是个位、十位、百位... 都只有0-9 10个数字 所以准备10个桶 bucket := make([]int, 10, 10) for i := 0; i \u0026lt; len(a); i++ { radixNum := (a[i] / radix) % 10 //得到某个基数位的数字 比如345 传入radix是1 也就是个位数也就是3 bucket[radixNum]++ } //这个for循环完成 也就完成了个位数桶计数 比如bucket[1]=3 也就是个位数是1的数字有3个 for j := 1; j \u0026lt; len(bucket); j++ { bucket[j] += bucket[j-1] } //这个for循环完成 桶计数含义发生改变 bucket[1]=3表示个位数\u0026lt;=1的数字有3个 //倒序遍历原数组 按照基数位排序后输出到辅助数组 for k := len(a) - 1; k \u0026gt;= 0; k-- { bucket[(a[k]/radix)%10]-- help[bucket[(a[k]/radix)%10]] = a[k] } for i := 0; i \u0026lt; len(a); i++ { a[i] = help[i] } } //RadixSort 基数排序 先按照个位排序 再按照10位排序 再按照百位排序 ... func RadixSort(a []int) { max := GetMax(a) for radix := 1; max/radix \u0026gt; 0; radix *= 10 { radixSort(a, radix) //依次按照个位 十位 百位 ...排序 } }  \n时间复杂度 ​ O(X*2N) 这里的X 主要是指分了多少个基数 比如个位、十位、百位 那X=3 对于每个基数 内部都至少需要2N的时间复杂度\n算法稳定性 ​ 上面实现的是稳定的 就是采用累加计数 然后倒序遍历数组的方法\n优化 ​ 待补充\n网搜图解 桶排序 介绍 计数排序和基数排序是最常见的2种桶排序思想，不是基于比较的排序思想，桶排序的前提假设大致如下：   假设原数据是大值均匀分布的 量也比较大 在原数据上建立1个函数映射关系 将原数据映射到有限个数的桶上 然后针对每个桶再想办法排序(比如插排、快排等) 最后按照桶顺序依次输出桶里的元素 就完成了整个排序  代码 ​ 这里不写代码了\n时间复杂度 ​ 去掉常数项就是O(N)\n算法稳定性 可以做到稳定\n优化 待补充\n网搜图解 待补充\n","id":3,"section":"posts","summary":"冒泡排序 介绍 ​ 冒泡排序是一种比较简单的排序，之所以叫冒泡，是因为在两两比较的过程中较大的数就像冒泡一样被换到后面。详细解释：依次比较相邻的两","tags":["数据结构","算法","排序"],"title":"排序_数据结构与算法","uri":"http://heketong.github.io/2020/05/%E6%8E%92%E5%BA%8F_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","year":"2020"}],"tags":[{"title":"marathons","uri":"http://heketong.github.io/tags/marathons/"},{"title":"排序","uri":"http://heketong.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"title":"搭建博客","uri":"http://heketong.github.io/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"title":"数据结构","uri":"http://heketong.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"算法","uri":"http://heketong.github.io/tags/%E7%AE%97%E6%B3%95/"}]}